# Leetcode

Repository of my Leetcode journey, starting September 23, 2023. 

Including my solutions for daily challenges, problems and contests. 

Leetcode is a website for technical interview preparation that offers coding problems, challenges, contests, enhancement of problem-solving skills, algorithms and data structures. 

My profile is linked below:

https://leetcode.com/Sshahryar/

Below will be updates on the Daily Challenge Solutions**. Info on other folders in the repository such as courses, challenges, etc. can be found in the wiki. 

**The daily challenge updates are based on this title format: Solution (date) (language, leetcode) (name of challenge) (difficulty). 

**The daily challenge solutions are designed to work on the leetcode, and may or may not work on ide's outside of 
leetcode, because of test cases and specific parameters. 

## Leetcode Daily Challenge Solutions (From .LeetcodeDailySolution)

### Solution Sept 23, 2023 (Java, leetcode) 1048. LongestStrChain (Medium) 

In .LeetcodeDailySolution folder as Sept23,2023.java

#### Prompt:

You are given an array of words where each word consists of lowercase English letters.

wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.

For example, "abc" is a predecessor of "abac", while "cba" is not a predecessor of "bcad".
A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.

Return the length of the longest possible word chain with words chosen from the given list of words.

#### Solution:

    class Solution {
        public int longestStrChain(String[] words) {
            int ans = 0;
            Arrays.sort(words, (a, b) -> Integer.compare(a.length(), b.length()));
        
        Map<String, Integer> dp = new HashMap<String, Integer>();
        
        for (String w: words) {
            int best = 0;
            for (int i = 0; i < w.length(); i++) {
                String prev = w.substring(0, i) + w.substring(i + 1);
                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);
            }
            dp.put(w, best);
            ans = Math.max(ans, best);
        }
        return ans;
    }
    }

Runtime: 41 ms, beating 31.27% of leetcode users solutions using java.
Memory: 43.9 mb, beating 34.67% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming, arrays, map, and hashmap.
    
### Solution Sept 25, 2023 (Java, leetcode) 389. Find the Difference (Easy)
In .LeetcodeDailySolution folder as Sept25,2023.java

#### Prompt:

You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.

Return the letter that was added to t.

#### Solution:

    class Solution {
        public char findTheDifference(String s, String t) {
            int[] charCount = new int[26];
        
        for (char c : s.toCharArray()) {
            charCount[c - 'a']++;
        }
        
        for (char c : t.toCharArray()) {
            charCount[c - 'a']--;
        }
        
        for (int i = 0; i < 26; i++) {
            if (charCount[i] < 0) {
                return (char) (i + 'a');
            }
        }
        
        return ' ';
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String s = "abcd";
        String t = "abcde";
        char addedLetter = solution.findTheDifference(s, t);
        System.out.println("The added letter is: " + addedLetter);
    }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java.
Memory: 40.9 mb, beating 20.52% of leetcode users solutions using java.

#### Concepts Applied:

Character arrays and for loop. 

### Solution Sept 26, 2023 (Java, leetcode) 316. Remove Duplicate Letters (Medium) 
In .LeetcodeDailySolution folder as Sept26,2023.java

#### Prompt:

Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is 
the smallest in lexicographical order among all possible results.
 
#### Solution:

    import java.util.Stack;

    class Solution {
    public String removeDuplicateLetters(String s) {
        int[] count = new int[26];
        boolean[] used = new boolean[26];
        Stack<Character> stack = new Stack<>();

        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }

        for (char c : s.toCharArray()) {
            count[c - 'a']--;
            if (used[c - 'a']) {
                continue;
            }

            while (!stack.isEmpty() && c < stack.peek() && count[stack.peek() - 'a'] > 0) {
                used[stack.pop() - 'a'] = false;
            }

            stack.push(c);
            used[c - 'a'] = true;
        }

        StringBuilder result = new StringBuilder();
        for (char c : stack) {
            result.append(c);
        }

        return result.toString();
    }
    }
    
Runtime: 2 ms, beating 96.27% of leetcode users solutions using java.
Memory: 41.1 mb, beating 62.98% of leetcode users solutions using java.

#### Concepts Applied:

CharacterArray and stack. 

### Solution Sept 27, 2023 (Java, leetcode) 880. Decoded String at Index (Medium)
In .LeetcodeDailySolution folder as Sept27,2023.java

#### Prompt:

You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken:

If the character read is a letter, that letter is written onto the tape.
If the character read is a digit d, the entire current tape is repeatedly written d - 1 more times in total.
Given an integer k, return the kth letter (1-indexed) in the decoded string.

#### Solution:

    class Solution {
    public String decodeAtIndex(String encodedString, int k) {
       Stack<Long> characterLengths = new Stack<>();

        characterLengths.push(0L); 

        for (int i = 0; i < encodedString.length(); i++) {
            char c = encodedString.charAt(i);
            if (Character.isDigit(c)) {

                long length = characterLengths.peek() * (c - '0');
                characterLengths.push(length);
            } else {

                long length = characterLengths.peek() + 1;
                characterLengths.push(length);
            }
        }

        int ln = characterLengths.size();
        while (!characterLengths.isEmpty()) {
            k %= characterLengths.peek(); 
            ln--;

            if (k == 0 && Character.isLetter(encodedString.charAt(ln - 1))) {
                return String.valueOf(encodedString.charAt(ln - 1));
            }


            characterLengths.pop();
        }

        return ""; 
    }
    }

Runtime: 1 ms, beating 13.46% of leetcode users solutions using java.
Memory: 40.8 mb, beating 8.48% of leetcode users solutions using java.

#### Concepts Applied:

Strings, stack, character lengths, e.t.c

### Solution Sept 28, 2023 (Java, leetcode) 905. Sort Array by Parity (Easy)
In .LeetcodeDailySolution folder as Sept28,2023.java

#### Prompt:

Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.

Return any array that satisfies this condition.

#### Solution:

    class Solution {
      public int[] sortArrayByParity(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            if (nums[left] % 2 == 0) {
                left++;  

            } else if (nums[right] % 2 == 1) {
                right--;  

            } else {
                
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++;
                right--;
            }
        }

        return nums;
     }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 44.1 mb, beating 40.77% of leetcode users solutions using java.

#### Concepts Applied:

While loop, if and else-if. 

### Solution Sept 29, 2023 (Java, leetcode) 896. Monotonic Array (Easy)
In .LeetcodeDailySolution folder as Sept29,2023.java

#### Prompt: 

An array is monotonic if it is either monotone increasing or monotone decreasing.

An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].

Given an integer array nums, return true if the given array is monotonic, or false otherwise.

#### Solution:

    class Solution {
       public boolean isMonotonic(int[] nums) {
        boolean increasing = true;
        boolean decreasing = true;

        for (int i = 1; i < nums.length; i++) {
            if (nums[i - 1] > nums[i]) {
                increasing = false; 
            } else if (nums[i - 1] < nums[i]) {
                decreasing = false; 
            }
            
            if (!increasing && !decreasing) {
                return false;
            }
        }

        return true; 
      }
    }

Runtime: 2 ms, beating 58.97% of leetcode users solutions using java.
Memory: 54.4 mb, beating 73.26% of leetcode users solutions using java.

#### Concepts Applied:

Booleans, for loop, if, and else-if. 

### Solution Sept 30, 2023 (Java, leetcode) 456. 132 Pattern (Medium)
In .LeetcodeDailySolution folder as Sept30,2023.java

#### Prompt:

Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].

Return true if there is a 132 pattern in nums, otherwise, return false.

Example 1:

Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.
Example 2:

Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
Example 3:

Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
 
Constraints:

n == nums.length
1 <= n <= 2 * 105
-109 <= nums[i] <= 109

#### Solution:

    import java.util.Stack;

    class Solution {
       public boolean find132pattern(int[] nums) {
        int n = nums.length;
        int[] minLeft = new int[n];
        minLeft[0] = nums[0];
        
        for (int i = 1; i < n; i++) {
            minLeft[i] = Math.min(minLeft[i - 1], nums[i]);
        }
        
        Stack<Integer> stack = new Stack<>();
        
        for (int j = n - 1; j >= 0; j--) {
            if (nums[j] > minLeft[j]) {
                while (!stack.isEmpty() && stack.peek() <= minLeft[j]) {
                    stack.pop();
                }
                if (!stack.isEmpty() && stack.peek() < nums[j]) {
                    return true;
                }
                stack.push(nums[j]);
            }
        }
        
        return false;
      }
    }

Runtime: 15 ms, beating 68.8% of leetcode users solutions using java.
Memory: 64.1 mb, beating 8.57% of leetcode users solutions using java.

#### Concepts Applied:

Stack, for and while loop. 

### Solution Oct 1, 2023 (Java, leetcode) 557. Reverse Words In a String III (Easy) 
In .LeetcodeDailySolution folder as Oct1,2023.java

#### Prompt:

Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

Example 1:

Input: s = "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
Example 2:

Input: s = "God Ding"
Output: "doG gniD"

Constraints:

1 <= s.length <= 5 * 104
s contains printable ASCII characters.
s does not contain any leading or trailing spaces.
There is at least one word in s.
All the words in s are separated by a single space.

#### Solution:

    class Solution {
       public String reverseWords(String s) {
          String[] words = s.split(" "); 

        StringBuilder result = new StringBuilder();

        for (String word : words) {
            
            result.append(reverseWord(word)).append(" ");
        }

        return result.toString().trim(); 

    }

    private String reverseWord(String word) {
        char[] chars = word.toCharArray(); 
        int left = 0;
        int right = chars.length - 1;

        while (left < right) {

            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;

            left++;
            right--;
        }

        return new String(chars); 
      }
    }

Runtime: 4 ms, beating 87.77% of leetcode users solutions using java.
Memory: 43.9 mb, beating 85.88% of leetcode users solutions using java.

#### Concepts Applied:

Character arrays, for and while loop. 

### Solution Oct 2, 2023 (Java, leetcode) 2038. Remove Colored Pieces if Both Neighbors are the Same (Medium) 
In .LeetcodeDailySolution folder as Oct2,2023.java

#### Prompt:

There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.

Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.

Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.
Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.
Alice and Bob cannot remove pieces from the edge of the line.
If a player cannot make a move on their turn, that player loses and the other player wins.
Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.

#### Solution:

    class Solution {
      public boolean winnerOfGame(String colors) {
        int n = colors.length();
        int aliceCount = 0;
        int bobCount = 0;
        
        for (int i = 1; i < n - 1; i++) {
            if (colors.charAt(i) == 'A' && colors.charAt(i - 1) == 'A' && colors.charAt(i +         1) == 'A') {
                aliceCount++;
            } else if (colors.charAt(i) == 'B' && colors.charAt(i - 1) == 'B' && colors.    charAt(i + 1) == 'B') {
                bobCount++;
            }
        }
        
        return aliceCount > bobCount;
      }
    }

Runtime: 16 ms, beating 52.45% of leetcode users solutions using java.
Memory: 44.2 mb, beating 55.98% of leetcode users solutions using java. 

#### Concepts Applied:

Strings, for loop, if, else-if, and charAt. 

### Solution Oct 3, 2023 (Java, leetcode) 1512. Number of Good Pairs (Easy) 
In .LeetcodeDailySolution folder as Oct3,2023.java

#### Prompt:

Given an array of integers nums, return the number of good pairs.

A pair (i, j) is called good if nums[i] == nums[j] and i < j.

#### Solution:

    class Solution {
       public int numIdenticalPairs(int[] nums) {
           int[] count = new int[101]; 

        for (int num : nums) {
            count[num]++;
        }
        
        int goodPairs = 0;
        
        for (int c : count) {
            if (c > 1) {
                goodPairs += (c * (c - 1)) / 2;
            }
        }
        
        return goodPairs;
      }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40 mb, beating 34.61% of leetcode users solutions using java. 

#### Concepts Applied:

For loop.

### Solution Oct 4, 2023 (Java, leetcode) 706. Design HashMap (Easy)
In .LeetcodeDailySolution folder as Oct4,2023.java

#### Prompt:

Design a HashMap without using any built-in hash table libraries.

Implement the MyHashMap class:

MyHashMap() initializes the object with an empty map.
void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.

#### Solution

    import java.util.ArrayList;
    import java.util.List;
  
    class MyHashMap {

    private static final int SIZE = 1000;
    private List<List<int[]>> data;

    public MyHashMap() {
        data = new ArrayList<>(SIZE);
        for (int i = 0; i < SIZE; i++) {
            data.add(new ArrayList<>());
        }
    }

    private int getIndex(int key) {
        return Integer.hashCode(key) % SIZE;
    }

    public void put(int key, int value) {
        int index = getIndex(key);
        for (int[] entry : data.get(index)) {
            if (entry[0] == key) {
                entry[1] = value;
                return;
            }
        }
        data.get(index).add(new int[]{key, value});
    }

    public int get(int key) {
        int index = getIndex(key);
        for (int[] entry : data.get(index)) {
            if (entry[0] == key) {
                return entry[1];
            }
        }
        return -1;
    }

    public void remove(int key) {
        int index = getIndex(key);
        List<int[]> entries = data.get(index);
        for (int i = 0; i < entries.size(); i++) {
            if (entries.get(i)[0] == key) {
                entries.remove(i);
                return;
            }
        }
      }
    }

    public class Main {
      public static void main(String[] args) {
        MyHashMap myHashMap = new MyHashMap();
        myHashMap.put(1, 1);
        myHashMap.put(2, 2);
        System.out.println(myHashMap.get(1)); 
        System.out.println(myHashMap.get(3)); 
        myHashMap.put(2, 1);
        System.out.println(myHashMap.get(2)); 
        myHashMap.remove(2);
        System.out.println(myHashMap.get(2)); 
      }
    }

Runtime: 17 ms, beating 65.77% of leetcode users using java.
Memory: 47.6 mb, beating 69.68% of leetcode users using java.

#### Concepts Applied:

Array, hash table, linked list, design, and hash function.

### Soluton Oct 5, 2023 (Java, leetcode) 229. Majorty Element II (Medium)
In .LeetcodeDailySolution folder as Oct5,2023.java

#### Prompt:

Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

#### Solution:

    import java.util.ArrayList;
    import java.util.List;

    class Solution {
      public List<Integer> majorityElement(int[] nums) {
        List<Integer> result = new ArrayList<>();
        int n = nums.length;

        if (n == 0) return result;

        int candidate1 = 0, candidate2 = 0, count1 = 0, count2 = 0;

        for (int num : nums) {
            if (num == candidate1) {
                count1++;
            } else if (num == candidate2) {
                count2++;
            } else if (count1 == 0) {
                candidate1 = num;
                count1 = 1;
            } else if (count2 == 0) {
                candidate2 = num;
                count2 = 1;
            } else {
                count1--;
                count2--;
            }
        }

        count1 = 0;
        count2 = 0;
        for (int num : nums) {
            if (num == candidate1) {
                count1++;
            } else if (num == candidate2) {
                count2++;
            }
        }

        if (count1 > n / 3) {
            result.add(candidate1);
        }
        if (count2 > n / 3) {
            result.add(candidate2);
        }

        return result;
      }
    }

Runtime: 1 ms, beating 99.94% of leetcode users solutions using java. 
Memory: 47.2 mb, beating 10.66% of leetcode users solutions using java.

#### Concepts Applied:

Array, hash table, sorting, and counting.

### Solution Oct 6, 2023 (Java, leetcode) 343. Integer Break (Medium)
In .LeetcodeDailySolution folder as Oct6,2023.java

#### Prompt:

Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.

Return the maximum product you can get.

#### Solution:

    class Solution {
        public int integerBreak(int n) {
                if(n == 1) return 1;
                        int[] dp = new int[n + 1];
                                dp[1] = 1;
                                        for(int i = 2; i <= n; i++){
                                                    for(int j = 1; j < i; j++){
                                                                    dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
                                                                                }
                                                                                        }
                                                                                                return dp[n];
                                                                                                    }
                                                                                                    }
                                                                                                    
Runtime: 1 ms, beating 33.22% of leetcode users solutions using java.
Memory: 39.9 mb, beating 6.52% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming and for loop.

### Solution Oct 7, 2023 (Java, leetcode) 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons (Hard)
Im .LeetcodeDailySolution folder as Oct7,2023.java

#### Prompt:

You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers:

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/213847ce-4a27-441a-9b8a-06910e1736ce)

You should build the array arr which has the following properties:

arr has exactly n integers.
1 <= arr[i] <= m where (0 <= i < n).
After applying the mentioned algorithm to arr, the value search_cost is equal to k.
Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7.

#### Solution:

    class Solution {
        public int numOfArrays(int n, int m, int k) {
        long[][][] dp = new long[n][k][m];
        long mod = 1000000007;
        Arrays.fill(dp[0][0], 1);
        
        for (int i = 1; i < n; i++) {
            for (int cost = 0; cost < Math.min(i + 1, k); cost++) {
                for (int max = 0; max < m; max++) {
                    dp[i][cost][max] = (dp[i][cost][max] + (max + 1) * dp[i - 1][cost][max]) % mod;
                    if (cost != 0) {
                        long sum = 0;
                        for (int prevMax = 0; prevMax < max; prevMax++) {
                            sum += dp[i - 1][cost - 1][prevMax];
                            sum %= mod;
                        }
                        dp[i][cost][max] = (dp[i][cost][max] + sum) % mod;
                    }
                }
            }
        }
        long ans = 0;
        for (int max = 0; max < m; max++) {
            ans += dp[n - 1][k - 1][max];
            ans %= mod;
        }
        return (int) ans;
      }
    }

Runtime: 27 ms, beating 85.37% of leetcode users solutions using java.
Memory: 43.6 mb, beating 24.29% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loop, dynamic programming, and if statements.

### Solution Oct 8, 2023 (Java, leetcode) 1458. Max Dot Product of Two Subtances (Hard)
In .LeetcodeDailySolutions folder as Oct8,2023.java

#### Prompt:

Given two arrays nums1 and nums2.

Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.

A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).

#### Solution:

    class Solution {
        public int maxDotProduct(int[] nums1, int[] nums2) {
        int[][] marks = new int[nums1.length][nums2.length];
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < nums2.length; j++) {
                int max = nums1[i] * nums2[j];
                if (i > 0 && j > 0) {
                    max = Math.max(max, max + marks[i - 1][j - 1]);
                }
                if (i > 0) {
                    max = Math.max(max, marks[i - 1][j]);
                }
                if (j > 0) {
                    max = Math.max(max, marks[i][j - 1]);
                }
                marks[i][j] = max;
            }
        }
        return marks[nums1.length - 1][nums2.length - 1];
      }
    }
    
Runtime: 10 ms, beating 81.94% of leetcode users solutions using java.
Memory: 42.9 mb, beating 80.56% of leetcode users solutions using java.

#### Concepts Applied:

Math, for-loop and if statements.

### Solution Oct 9, 2023 (Java, leetcode) 34. Find First and Last Position of Element in Sorted Array (Medium)
In .LeetcodeDailySolution folder as Oct9,2023.java

#### Prompt:

Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

#### Solution:

    class Solution {
    public int[] searchRange(int[] nums, int target) {
        int first = -1, last = -1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                if (first == -1) {
                    first = i;
                }
                last = i;
            }
        }
        return new int[]{first, last};
      }
    }

Runtime: 1 ms, beating 20.94% of leetcode users solutions using java.
Memory: 44.1 mb, beating 82.90% of leetcode users solutions using java. 

#### Concepts Applied:

If statements.

### Solution Oct 10, 2023 (Java, leetcode) 2009. Minimum Number of Operation to Make Array Continuous
In .LeetcodeDailySolution folder as Oct10,2023.java

#### Prompt:

You are given an integer array nums. In one operation, you can replace any element in nums with any integer.

nums is considered continuous if both of the following conditions are fulfilled:

All elements in nums are unique.
The difference between the maximum element and the minimum element in nums equals nums.length - 1.
For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous.

Return the minimum number of operations to make nums continuous.

#### Solution:

    class Solution {
      public int minOperations(int[] nums) {
        Arrays.sort(nums);
        int uniqueLen = 1;
        for (int i = 1; i < nums.length; ++i) {
            if (nums[i] != nums[i - 1]) {
                nums[uniqueLen++] = nums[i];
            }
        }
        
        int ans = nums.length;
        for (int i = 0, j = 0; i < uniqueLen; ++i) {
            while (j < uniqueLen && nums[j] - nums[i] <= nums.length - 1) {
                ++j;
            }
            ans = Math.min(ans, nums.length - (j - i));
        }
        
        return ans;
      }
    }

Runtime: 36 ms, beating 99.3% of leetcode users solutions using java.
Memory: 58 mb, beating 43.69% of leetcode users solutons using java.

#### Concepts Applied:

Arrays, for loop, while loop, and if statements.

### Solution Oct 11, 2023 (Java, leetcode) 2251. Numbers of Flowers in Full Bloom (Hard)
In .LeetcodeDailySolution folder as Oct11,2023.java

#### Prompt: 

You are given a 0-indexed 2D integer array flowers, where flowers[i] = [starti, endi] means the ith flower will be in full bloom from starti to endi (inclusive). You are also given a 0-indexed integer array people of size n, where people[i] is the time that the ith person will arrive to see the flowers.

Return an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the ith person arrives.

Example 1:

Input: flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]
Output: [1,2,2,2]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.

Example 2:

Input: flowers = [[1,10],[3,3]], people = [3,3,2]
Output: [2,2,1]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.

#### Solution:

    class Solution {
    public int[] fullBloomFlowers(int[][] flowers, int[] persons) {
        int n = persons.length;
        int[] result = new int[n];

        TreeMap<Integer, Integer> treeMap = new TreeMap<>();
        for (int i = 0; i < flowers.length; i++) {
        
            treeMap.put(flowers[i][0], treeMap.getOrDefault(flowers[i][0], 0) + 1);

            treeMap.put(flowers[i][1] + 1, treeMap.getOrDefault(flowers[i][1] + 1, 0) - 1);
        }
        
        TreeMap<Integer, Integer> sum = new TreeMap<>();
        int prev = 0;
        for (Map.Entry<Integer, Integer> entry : treeMap.entrySet()) {
            prev += entry.getValue();
            sum.put(entry.getKey(), prev);
        }

        for (int i = 0; i < n; i++) {

            Map.Entry<Integer, Integer> entry = sum.floorEntry(persons[i]);
            if (entry != null) {
                result[i] = entry.getValue(); 
            }
        }
        return result;
        }
    }

Runtime: 102 ms, beating 19.78% of leetcode users using java.
Memory: 73.5 mb, beating 22.1% of leetcode users using java.

#### Concepts Applied:

Treemap, for loop, and if statements. 

### Solution Oct 12, 2023 (Java, leetcode) 1095. Find in Mountain Array (Hard)
In .LeetcodeDailySolution folder as Oct12,2023.java

#### Prompt:

(This problem is an interactive problem.)

You may recall that an array arr is a mountain array if and only if:

arr.length >= 3
There exists some i with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target. If such an index does not exist, return -1.

You cannot access the mountain array directly. You may only access the array using a MountainArray interface:

MountainArray.get(k) returns the element of the array at index k (0-indexed).
MountainArray.length() returns the length of the array.
Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.

#### Solution:
     
    class Solution {
    public int findInMountainArray(int target, MountainArray mountainArr) {
        int length = mountainArr.length();
        int peakIndex = findPeak(mountainArr, length);

        int result = findTarget(mountainArr, 0, peakIndex, target, true);
        if (result != -1) {
            return result;
        }

        return findTarget(mountainArr, peakIndex + 1, length - 1, target, false);
    }

    private int findTarget(MountainArray mountainArr, int left, int right, int target, boolean isUpside) {
        while (left <= right) {
            int mid = (left + right) / 2;
            int midVal = mountainArr.get(mid);

            if (midVal == target) {
                return mid;
            }

            if (isUpside) {
                if (target > midVal) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            } else {
                if (target > midVal) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }

        return -1;
    }

    private int findPeak(MountainArray mountainArr, int length) {
        int left = 0;
        int right = length - 1;

        while (left < right) {
            int mid = (left + right) / 2;
            if (mountainArr.get(mid) < mountainArr.get(mid + 1)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
        }    
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 42.9 mb, beating 85.75% of leetcode users solutions using java.

#### Concepts Applied: 

Dynamic programming, math and for loop.

### Solution Oct 13, 2023 (Java, leetcode) 746. Min Cost Climbing Stairs (Easy)
In .LeetcodeDailySolution folder as Oct13,2023.java

#### Prompt:

You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index 0, or the step with index 1.

Return the minimum cost to reach the top of the floor.

#### Solution:

    class Solution {

    public int minCostClimbingStairs(int[] cost) {

        int n = cost.length;

        int[] dp = new int[n];

        dp[0] = cost[0];

        dp[1] = cost[1];

        

        for (int i = 2; i < n; i++) {

            dp[i] = cost[i] + Math.min(dp[i-1], dp[i-2]);

        }

        

        return Math.min(dp[n-1], dp[n-2]);

        }

    }
    
Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.1 mb, beating 24.85% of leetcode users solutions using java.

#### Concepts Applied:

Dyanmic programming, math and for loop.

### Solution Oct 14, 2023 (Java, leetcode) 2742. Painting the Walls (Hard)
In .LeetcodeDailySolution folder as Oct14,2023.java

#### Prompt:

You are given two 0-indexed integer arrays, cost and time, of size n representing the costs and the time taken to paint n different walls respectively. There are two painters available:

A paid painter that paints the ith wall in time[i] units of time and takes cost[i] units of money.
A free painter that paints any wall in 1 unit of time at a cost of 0. But the free painter can only be used if the paid painter is already occupied.
Return the minimum amount of money required to paint the n walls.

#### Solution:

    class Solution {
    public int paintWalls(int[] cost, int[] time) {
        int n = cost.length;
        int[] money = new int[n+1];
        Arrays.fill(money,(int)1e9);
        money[0]=0;
        for(int i=0;i<n;i++)
        {
            for(int j=n;j>0;j--)
            {
                money[j]=Math.min(money[j],money[Math.max(j-time[i]-1,0)]+cost[i]);
            }
        }
        return money[n];
        }
    }

Runtime: 8 ms, beating 98.47% of leetcode users solutions using java.
Memory: 43.3 mb, beating 95.41% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, math and for loop. 

### Solution Oct 15, 2023 (Java, leetcode) 1269. Number of Ways to Stay in the Same Place After Some Steps (Hard)
In .LeetcodeDailySolution as Oct15,2023.java

#### Prompts:

You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).

Given two integers steps and arrLen, return the number of ways such that your pointer is still at index 0 after exactly steps steps. Since the answer may be too large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public int numWays(int steps, int arrLen) {
        int m = steps;
        int n = Math.min(steps / 2 + 1, arrLen);
        
        int[][] dp = new int[m + 1][n];
        dp[0][0] = 1;
        
        int mod = 1000000007;
        
        for (int i = 1; i <= m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j > 0) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;
                }
                if (j < n - 1) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod;
                }
            }
        }
        
        return dp[m][0];
        }
    }

Runtime: 9 ms, beating 67.90% of leetcode users solutions using java.
Memory: 42.1 mb, beating 89.20% of leetcode users solutions using java.

#### Concepts Applied:

Math, dynamic programming, for loops, and if statements.

### Solution Oct 16, 2023 (Java, leetcode) 119. Pascals Triangle II (Easy) 
In .LeetcodeDailySolution folder as Oct16,2023.java

#### Prompt:

Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.

In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/4de7c43b-3fb2-43b2-8d4f-806d74ff3e22)

#### Solution:

    class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> res = new ArrayList<>();

        res.add(1);
        long prev = 1;

        for (int k = 1; k<= rowIndex; k++) {
            long next_val = prev * (rowIndex - k+1) / k;
            res.add((int) next_val);
            prev = next_val;

        }
        return res;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.9 mb, beating 78.30% of leetcode users solutions using java.

#### Concepts Applied:

Lists and for loop.

### Solution Oct 17, 2023 (Java, leetcode) 1361. Validate Binary Tree Nodes (Medium)
In. LeetcodeDailySolution folder as Oct17,2023.java

#### Prompt:

You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.

If node i has no left child then leftChild[i] will equal -1, similarly for the right child.

Note that the nodes have no values and that we only use the node numbers in this problem.

#### Solution:

    class Solution {
    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
        int[] indegree = new int[n];
        for (int i = 0; i < n; i++) {
            if (leftChild[i] != -1) indegree[leftChild[i]]++;
            if (rightChild[i] != -1) indegree[rightChild[i]]++;
        }
        int root = -1;
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                if (root == -1) root = i;
                else return false;
            }
        }
        if (root == -1) return false;
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int node = queue.poll();
            if (visited[node]) return false;
            visited[node] = true;
            if (leftChild[node] != -1) queue.offer(leftChild[node]);
            if (rightChild[node] != -1) queue.offer(rightChild[node]);
        }
                int trueCount = 0;
        for (boolean b : visited) {
            if (b) trueCount++;
        }
        return trueCount == n;

        }
    }

Runtime: 5 ms, beating 76.45% of leetcode users solutions using java.
Memory: 44.2 mb, beating 91.61% of leetcode users solutions using java.

#### Concepts Applied:

For loop, if statements, linked lists, and while loop.

### Solution Oct 18, 2023 (Java, leetcode) 2050, Parallel Courses III (Hard)
In .LeetcodeDailySolution folder as Oct18,2023.java

#### Prompt:

You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course.

You must find the minimum number of months needed to complete all the courses following these rules:

You may start taking a course at any time if the prerequisites are met.
Any number of courses can be taken at the same time.
Return the minimum number of months needed to complete all the courses.

Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).

#### Solution:

    class Solution {
    private int[] startNodes;
    private int[][] graph;
    private int[] time;
    private boolean[] visited;
    private int[] ans;

    private void toGraph(int[][] edges, int n) {
        int[] incoming = new int[n], outgoing = new int[n];
        for(int[] e : edges) {
            outgoing[e[0] - 1]++;
            incoming[e[1] - 1]++;
        }
        int startCnt = 0;
        for(int i : incoming) {
            if (i == 0) {
                startCnt++;
            }
        }
        startNodes = new int[startCnt];
        for(int sni = 0, i = 0; sni < startNodes.length; i++) {
            if (incoming[i] == 0) {
                startNodes[sni++] = i;
            }
        }
        graph = new int[n][];
        for(int i = 0; i < n; i++) {
            graph[i] = new int[outgoing[i]];
        }
        for(int[] e : edges) {
            graph[e[0] - 1][--outgoing[e[0] - 1]] = e[1] - 1;
        }
    }

    private int calculate(int node) {
        if (ans[node] > 0) {
            return ans[node];
        }

        int worstPrereq = 0;
        visited[node] = true;
        for(int child : graph[node]) {
            if (!visited[child]){
                worstPrereq = Math.max(calculate(child), worstPrereq);
            }
        }
        visited[node] = false;
        return ans[node] = worstPrereq + time[node];
    }

    public int minimumTime(int n, int[][] relations, int[] time) {
        toGraph(relations, n);
        this.time = time;
        ans = new int[n];
        visited = new boolean[n];
        int longest = 0;
        for(int node : startNodes) {
            longest = Math.max(longest, calculate(node));
        }
        return longest;
        }
    }

Runtime: 13 ms, beating 99.56% of leetcode users solutions using java.
Memory: 68 mb, beating 56.45% of leetcode users solutions using java.

#### Concepts Applied:

Graphs, boolean, and for loops.

### Solution Oct 19, 2023 (Java, leetcode) 844. Backspace String Compare (Easy)
In .LeetcodeDailySolution folder as Oct19,2023.java

#### Prompt:

Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.

Note that after backspacing an empty text, the text will continue empty.

#### Solution:

    class Solution {
    public boolean backspaceCompare(String s, String t) {
        int ps = s.length() - 1;
        int pt = t.length() - 1;

        while (ps >= 0 || pt >= 0) {
            ps = get_next_valid_char_index(s, ps);
            pt = get_next_valid_char_index(t, pt);

            if (ps < 0 && pt < 0) {
                return true;
            }
            if (ps < 0 || pt < 0) {
                return false;
            } else if (s.charAt(ps) != t.charAt(pt)) {
                return false;
            }

            ps--;
            pt--;
        }

        return true;        
    }

    private int get_next_valid_char_index(String str, int end) {
        int backspace_count = 0;
        while (end >= 0) {
            if (str.charAt(end) == '#') {
                backspace_count++;
            } else if (backspace_count > 0) {
                backspace_count--;
            } else {
                break;
            }
            end--;
        }
        return end;
        }    
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.5 mb, beating 67.63% of leetcode users solutions using java.

#### Concepts Applied:

CharAt, while loop, if, else and else-if statements.

### Solution Oct 20, 2023 (Java, leetcode) 341. Flatten Nested List Iterator
In .LeetcodeDailySolution folder as Oct20,2023.java

#### Prompt:

You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.

Implement the NestedIterator class:

NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList.
int next() Returns the next integer in the nested list.
boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.
Your code will be tested with the following pseudocode:

initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
If res matches the expected flattened list, then your code will be judged as correct.

#### Solution:

    class NestedIterator implements Iterator<Integer> {
    private Stack<NestedInteger> stack;

    public NestedIterator(List<NestedInteger> nestedList) {
        stack = new Stack<>();
        for (int i = nestedList.size() - 1; i >= 0; i--) {
            stack.push(nestedList.get(i));
        }
    }

    @Override
    public Integer next() {
        return stack.pop().getInteger();
    }

    @Override
    public boolean hasNext() {
        while (!stack.isEmpty()) {
            if (stack.peek().isInteger()) {
                return true;
            }
            List<NestedInteger> nestedList = stack.pop().getList();
            for (int i = nestedList.size() - 1; i >= 0; i--) {
                stack.push(nestedList.get(i));
            }
        }
        return false;
        }
    }

Runtime: 4 ms, beating 25.17% of leetcode users solutions using java.
Memory: 44.26 mb, beating 74.13% of leetcode users solutions using java.

#### Concepts Applied:

NestedIterator, Iterators, Stack, nestedList, boolean, and list.

### Solution Oct 21, 2023 (Java, leetcode) 1425. Constrained Subsequence Sum (Hard)
In .LeetcodeDailySolution folder as Oct21,2023.java

#### Prompt:

Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.

A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.

#### Solution:

    class Solution {
    public int constrainedSubsetSum(int[] nums, int k) {
        Deque<Integer> queue = new ArrayDeque<>();
        int dp[] = new int[nums.length];
        
        for (int i = 0; i < nums.length; i++) {
            if (!queue.isEmpty() && i - queue.peek() > k) {
                queue.poll();
            }
            
            dp[i] = (!queue.isEmpty() ? dp[queue.peek()] : 0) + nums[i];
            while (!queue.isEmpty() && dp[queue.peekLast()] < dp[i]) {
                queue.pollLast();
            }
            
            if (dp[i] > 0) {
                queue.offer(i);
            }
        }
        
        int ans = Integer.MIN_VALUE;
        for (int num : dp) {
            ans = Math.max(ans, num);
        }
        
        return ans;
        }
    }

Runtime: 33 ms, beating 94.49% of leetcode users solutions using java.
Memory: 56.2 mb, beating 85.83% of leetcode users solutions using java.

#### Concepts Applied:

Deque, dynamic programming, for loop, and if statement.

### Solution Oct 22, 2023 (Java, leetcode) 1793. Maximum Score of a Good Subarray (Hard)
In .LeetcodeDailySolution folder as Oct22,2023.java

#### Prompt:

You are given an array of integers nums (0-indexed) and an integer k.

The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.

Return the maximum possible score of a good subarray.

#### Solution:

    class Solution {
    public int maximumScore(int[] nums, int k) {
        int n = nums.length;
        int left = k;
        int right = k;
        int ans = nums[k];
        int currMin = nums[k];
        
        while (left > 0 || right < n - 1) {
            if ((left > 0 ? nums[left - 1]: 0) < (right < n - 1 ? nums[right + 1] : 0)) {
                right++;
                currMin = Math.min(currMin, nums[right]);
            } else {
                left--;
                currMin = Math.min(currMin, nums[left]);
            }
            
            ans = Math.max(ans, currMin * (right - left + 1));
        }
        
        return ans;
        }
    }    

Runtime: 7 ms, beating 88.29% of leetcode users solutions using java.
Memory: 59.22 mb, beating 39.39% of leetcode users solutions using java. 

#### Concepts Applied:

While loop, if-statement, else-statement, and math.

### Solution Oct 23, 2023 (Java, leetcode) 342. Power of Four (Easy)
In .LeetcodeDailySolution folder as Oct23,2023.java

#### Prompt:

Given an integer n, return true if it is a power of four. Otherwise, return false.

An integer n is a power of four, if there exists an integer x such that n == 4x.

#### Solution:

    class Solution {
       public boolean isPowerOfFour(int n) {
       for(int i = 2 ;i<=32;i+=2){
           if((1<<i) == n) return true;
       }
       return false;
       }
    }
    
Runtime: 1 ms, beating 76.50% of leetcode users solutions using java.
Memory: 39.00 mb, beating 93.98% of leetcode users solutions using java.

#### Concepts Applied:

For loop and if-statement.

### Solution Oct 24, 2023 (Java, leetcode) 515. Find Largest Value in Each Tree Row (Medium)
In .LeetcodeDailySolution folder as Oct24,2023.java

#### Prompt:

Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).

Example 1:

Input: root = [1,3,2,5,3,null,9]
Output: [1,3,9]
Example 2:

Input: root = [1,2,3]
Output: [1,3]
 
Constraints:

The number of nodes in the tree will be in the range [0, 104].
-231 <= Node.val <= 231 - 1

#### Solution:

    class Solution {
    public List<Integer> largestValues(TreeNode root) {
       Map <Integer , Integer> map = new HashMap(); 
       dfs(root, 0, map);
       return new ArrayList(map.values());
    }

    private void dfs(TreeNode root, int level, Map<Integer , Integer> map){
        if(root==null) return;

        map.put(level, Math.max(root.val, map.getOrDefault(level, Integer.MIN_VALUE)));
        dfs(root.left, level+1, map);
        dfs(root.right, level+1, map);
        }
    }

Runtime: 1 ms, beating 98.02% of leetcode users solutions using java.
Memory: 43.94 mb, beating 61.09% of leetcode users solutions using java.

#### Concepts Applied:

Lists, HashMap, ArrayList, TreeNode, Map, Math, if-statement, and dfs. 

### Solution Oct 25, 2023 (Java, leetcode) 779. K-th Symbol in Grammar (Medium)
In .LeetcodeDailySolution folder as Oct25,2023.java

#### Prompt:

We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.

For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.

#### Solution:

    class Solution {
    public int kthGrammar(int n, int k) {
        if (n == 1) {
            return 0;
        }
        
        int parent = kthGrammar(n - 1, (int) Math.ceil(k / 2.0));
        boolean isOdd = k % 2 == 1;

        if (parent == 0) {
            return isOdd ? 0 : 1;
        } else {
            return isOdd ? 1 : 0;
            }  
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.04 mb, beating 49.27% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, Math, and if-statements.

### Solution Oct 26, 2023 (Java, leetcode) 823. Binary Trees With Factors (Medium)
In .LeetcodeDailySolution folder as Oct26,2023.java

#### Prompt:

Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.

We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.

Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.

#### Solution:

    class Solution {
    private static final int MOD = 1000000007;

    public int numFactoredBinaryTrees(int[] arr) {
        Arrays.sort(arr);
        Set<Integer> s = new HashSet<>();
        for (int x : arr) s.add(x);

        Map<Integer, Integer> dp = new HashMap<>();
        for (int x : arr) dp.put(x, 1);
        
        for (int i : arr) {
            for (int j : arr) {
                if (j > Math.sqrt(i)) break;
                if (i % j == 0 && s.contains(i / j)) {
                    long temp = (long) dp.get(j) * dp.get(i / j);
                    dp.put(i, (int) ((dp.get(i) + (i / j == j ? temp : temp * 2)) % MOD));
                }
            }
        }
        
        int result = 0;
        for (int val : dp.values()) {
            result = (result + val) % MOD;
        }
        return result;
        }
    }

Runtime: 14 ms, beating 82.51% of leetcode users solutions using java.
Memory: 43.46 mb, beating 36.41% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, Set, HashSet, for-loops, Map, HashMap, if statements, and dp.

### Solution Oct 27, 2023 (Java, leetcode) 5. Longest Palindromic String (Medium)
In .LeetcodeDailySolution folder as Oct27,2023.java

#### Prompt:

Given a string s, return the longest palindromic substring in s.

#### Solution:

    class Solution {
    public String longestPalindrome(String s) {
        StringBuilder sPrime = new StringBuilder("#");
        for (char c: s.toCharArray()) {
            sPrime.append(c).append("#");
        }
        
        int n = sPrime.length();
        int[] palindromeRadii = new int[n];
        int center = 0;
        int radius = 0;
        
        for (int i = 0; i < n; i++) {
            int mirror = 2 * center - i;
            
            if (i < radius) {
                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);
            }
            
            while (i + 1 + palindromeRadii[i] < n &&
                   i - 1 - palindromeRadii[i] >= 0 &&
                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {
                palindromeRadii[i]++;
            }
            
            if (i + palindromeRadii[i] > radius) {
                center = i;
                radius = i + palindromeRadii[i];
            }
        }
        
        int maxLength = 0;
        int centerIndex = 0;
        for (int i = 0; i < n; i++) {
            if (palindromeRadii[i] > maxLength) {
                maxLength = palindromeRadii[i];
                centerIndex = i;
            }
        }
        
        int startIndex = (centerIndex - maxLength) / 2;
        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);
        
        return longestPalindrome;
        }
    }

Runtime: 11 ms, beating 88.50% of leetcode users solutions using java.
Memory: 43.47 mb, beating 53.35% of leetcode users solutions using java.

#### Concepts Applied:

Char, charArray, for loops, if-statments, while loops, Math, charAt, strings.

### Solution Oct 28, 2023 (Java, leetcode) 1220. Count Vowels Permutation (Hard)
In .LeetcodeDailySolution folder as Oct28,2023.java

#### Prompt:

Given an integer n, your task is to count how many strings of length n can be formed under the following rules:

Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u')
Each vowel 'a' may only be followed by an 'e'.
Each vowel 'e' may only be followed by an 'a' or an 'i'.
Each vowel 'i' may not be followed by another 'i'.
Each vowel 'o' may only be followed by an 'i' or a 'u'.
Each vowel 'u' may only be followed by an 'a'.
Since the answer may be too large, return it modulo 10^9 + 7.

#### Solution:

    class Solution {
    public int countVowelPermutation(int n) {
        final int MOD = 1000000007;

        long a = 1, e = 1, i = 1, o = 1, u = 1;

        for (int j = 1; j < n; j++) {
            long a_next = e;
            long e_next = (a + i) % MOD;
            long i_next = (a + e + o + u) % MOD;
            long o_next = (i + u) % MOD;
            long u_next = a;
            a = a_next;
            e = e_next;
            i = i_next;
            o = o_next;
            u = u_next;
            
        }
        return (int)((a + e + i + o + u) % MOD);
        }
    }

Runtime: 5 ms, beating 99.02% of leetcode users solutions using java.
Memory: 39.30 mb, beating 84.92% of leetcode users solutions using java.

#### Concepts Applied:

Long and for loop.

### Solution Oct 29, 2023 (Java, leetcode) 458. Poor Pigs (Hard)
In .LeetcodeDailySolution folder as Oct29,2023.java

#### Prompt:

There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.

You can feed the pigs according to these steps:

Choose some live pigs to feed.
For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.
Wait for minutesToDie minutes. You may not feed any other pigs during this time.
After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.
Repeat this process until you run out of time.
Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.

#### Solution:

    class Solution{
    public int poorPigs(int buckets, int tdie, int ttest){
        int test = ttest/tdie;
        int i=0;
        
        while(Math.pow(test+1,i)< buckets)
        {
            i++;
        }
        return i;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 38.70 mb, beating 95.03% of leetcode users solutions using java.

#### Concepts Applied:

Math and while loop.

### Solution Oct 30, 2023 (Java, leetcode) 1356. Sort Integers by The Number of 1 Bits (Easy)
In .LeetcodeDailySolution folder as Oct30,2023.java

#### Prompt:

You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation and in case of two or more integers have the same number of 1's you have to sort them in ascending order.

Return the array after sorting it.

#### Solution:

    class Solution {
    public int[] sortByBits(int[] arr) {
        for ( int i =0 ;i< arr.length ;i++){
            arr[i] += Integer.bitCount(arr[i])*10001;
        }
        Arrays.sort(arr);
         for ( int i =0 ;i< arr.length ;i++){
             arr[i] = arr[i] %10001;
         }
        return arr;
        }
    }    

Runtime: 3 ms, beating 99.12% of leetcode users solutions using java.
Memory: 43.92 mb, beating 29.36% of leetcode users solutions using java.

#### Concepts Applied:

For loops and arrays.

### Solution Oct 31, 2023 (Java, leetcode) 2433. Find The Original Array of Prefix Xor (Medium)
In .LeetcodeDailySolution folder as Oct31,2023.java

#### Prompt:

You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:

pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
Note that ^ denotes the bitwise-xor operation.

It can be proven that the answer is unique.

#### Solution:

    class Solution {
    public int[] findArray(int[] pref) {
        int prev = pref[0];
        
        for (int i = 1; i < pref.length; i++) {
            pref[i] ^= prev;
            prev ^= pref[i];
        }
        return pref;        
        }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java. 
Memory: 58.68 mb, beating 54.80% of leetcode users solutions using java.

#### Concepts Applied:

findArray and for loop.

### Solution Nov 1, 2023 (Java, leetcode) 501. Find Mode in Binary Search Tree (Easy)
In .LeetcodeDailySolution folder as Nov1,2023.java

#### Prompt:

Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.

If the tree has more than one mode, return them in any order.

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than or equal to the node's key.
The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
Both the left and right subtrees must also be binary search trees.

#### Solution:

    class Solution {
    private int currentVal;
    private int currentCount = 0;
    private int maxCount = 0;
    private int modeCount = 0;
    private int[] modes;
    public int[] findMode(TreeNode root) {
        inOrderTraversal(root);

        modes = new int[modeCount];
        modeCount = 0;
        currentCount = 0;

        inOrderTraversal(root);

        return modes;
    }
    private void inOrderTraversal(TreeNode node) {
        if (node == null) return;
        inOrderTraversal(node.left);
        handleValue(node.val);
        inOrderTraversal(node.right);
    }
    private void handleValue(int val) {
        if (val == currentVal) {
            currentCount++;
        } else {
            currentVal = val;
            currentCount = 1;
        }
        if (currentCount > maxCount) {
            maxCount = currentCount;
            modeCount = 1;
        } else if (currentCount == maxCount) {
            if (modes != null) {
                modes[modeCount] = currentVal;
            }
            modeCount++;
            }
        }
    }    

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.46 mb, beating 93.96% of leetcode users solutions using java.

#### Concepts Applied: 

Treenodes, traversals, if-statements, else statements, and else-if statements.

### Solution Nov 2, 2023 (Java, leetcode) 2265. Count Nodes Equal to Average of Subtree (Medium)
In .LeetcodeDailySolution folder as Nov2,2023.java

#### Prompt:

Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.

Note:

The average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.
A subtree of root is a tree consisting of root and all of its descendants.

#### Solution:

    class Solution {
    int count = 0;
    public int averageOfSubtree(TreeNode root) {
        dfs(root);
        return count;
    }
        private int[] dfs(TreeNode node) {
        if(node == null) {
            return new int[]{0, 0};
        } 
        int[] leftResults = dfs(node.left);
        int[] rightResults = dfs(node.right);
        
        int totalSum = node.val + leftResults[0] + rightResults[0];

        int totalCount = 1 + leftResults[1] + rightResults[1];

        if(node.val == totalSum/totalCount) count++;

        return new int[]{totalSum, totalCount};
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 42.40 mb, beating 95.77% of leetcode users solutions using java.

#### Concepts Applied:

dfs, Treenode, and if-statements.

### Solution Nov 4, 2023 (Java, leetcode) 1503. Last Momment Before All Ants Fall Out of a Plank (Medium)
In .LeetcodeDailySolution folder as Nov4,2023.java

#### Prompt:

We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.

When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.

When an ant reaches one end of the plank at a time t, it falls out of the plank immediately.

Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.

#### Solution:

    class Solution {
        public int getLastMoment(int n, int[] left, int[] right) {
        int res = 0;
        for (int i: left)
            res = Math.max(res, i);
        for (int i: right)
            res = Math.max(res, n - i);
        return res;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.49 mb, beating 92.47% of leetcode users solutions using java.

#### Concepts Applied:

For loops and Math.

### Solution Nov 5, 2023 (Java, leetcode) 1535. Find the Winner of an Array Game (Medium)
In .LeetcodeDailySolution folder as Nov5,2023.java

#### Prompt:

Given an integer array arr of distinct integers and an integer k.

A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.

Return the integer which will win the game.

It is guaranteed that there will be a winner of the game.

#### Solution:

    class Solution {
    public int getWinner(int[] A, int k) {
        int cur = A[0]; int win = 0;
        
        for (int i = 1; i < A.length; ++i) {
            if (A[i] > cur) {
                cur = A[i];
                win = 0;
            }
            if (++win == k) {
                break;
            }
        }
        return cur;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 56.40 mb, beating 69.18% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loops, and if statements. 

### Solution Nov 6, 2023 (Java, leetcode) 1845. Seat Reservation Manager (Medium)
In .LeetcodeDailySolution folder as Nov6,2023.java

#### Prompt: 

Design a system that manages the reservation state of n seats that are numbered from 1 to n.

Implement the SeatManager class:

SeatManager(int n) Initializes a SeatManager object that will manage n seats numbered from 1 to n. All seats are initially available.
int reserve() Fetches the smallest-numbered unreserved seat, reserves it, and returns its number.
void unreserve(int seatNumber) Unreserves the seat with the given seatNumber.

#### Solution:

    class SeatManager {
    private PriorityQueue<Integer> queue;

    public SeatManager(int n) {
        queue = new PriorityQueue<>();
        for (int i = 1; i <= n; i++) {
            queue.offer(i);
        }
    }
    public int reserve() {
        return (!queue.isEmpty())? queue.poll() : -1;
    }
    public void unreserve(int seatNumber) {
        queue.offer(seatNumber);
      }
    }

Runtime: 88 ms, beating 50.38% of leetcode users solutions using Java.
Memory: 89.30 mb, beating 34.40% of leetcode users solutions using Java.

#### Concepts Applied:

Queues and for loop.

### Solution Nov 7, 2023 (Java, leetcode) 1921. Eliminate Maximum Number of Monsters (Medium)
In .LeetcodeDailySolution folder as Nov7,2023.java

#### Prompt:

You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.

The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.

You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start.

You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.

Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.

#### Solution:

    class Solution {
    public int eliminateMaximum(int[] dist, int[] speed) {
        int[] time = new int[dist.length];

        for(int i=0;i<dist.length;i++)
            time[i] = (int)Math.ceil((double)dist[i]/speed[i]);

        Arrays.sort(time);

        int ans = 0;
        int T = 0;
        for(int i=0;i<time.length;i++)
        {
            if(T++<time[i])
                ans++;
            else
                break;
        }
        return ans;
        }
    }

Runtime: 19 ms, beating 62.18% of leetcode users solutions using java.
Memory: 54.50 mb, beating 83.52% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, Math, for loops, and else condition. 

### Solution Nov 8, 2023 (Java, leetcode) 2849. Determine if a Cell is Reachable at a Given Time (Medium)
In .LeetcodeDailySolution folder as Nov8,2023.java

#### Prompt:

You are given four integers sx, sy, fx, fy, and a non-negative integer t.

In an infinite 2D grid, you start at the cell (sx, sy). Each second, you must move to any of its adjacent cells.

Return true if you can reach cell (fx, fy) after exactly t seconds, or false otherwise.

A cell's adjacent cells are the 8 cells around it that share at least one corner with it. You can visit the same cell several times.

#### Solution:

    class Solution {
    public static boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {
        int minsteps = 0;
        int a = Math.abs(fx - sx);
        int b = Math.abs(fy - sy);
        
        if (a == 0 && b == 0) {
            return t != 1;
        }
        if (a < b) {
            if (sy < fy) {
                return (fy - (sy + a) + a) <= t;
            } else {
                return (sy - (fy + a) + a) <= t;
            }
        } else {
            if (sx < fx) {
                return (fx - (sx + b) + b) <= t;
            } else {
                return (sx - (fx + b) + b) <= t;
                }
            }
        }
    }

Runtime: 1 ms, beating 91.04% of leetcode users solutions using java.
Memory: 39.60 mb, beating 53.57% of leetcode users solutions using java.

#### Concepts Applied:

Math, boolean, if and else statements.

### Solution Nov 9, 2023 (Java, leetcode) 1759. Count Number of Homogenous Substrings (Medium)
In .LeetcodeDailySolution folder as Nov9,2023.java

#### Prompt:

Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.

A string is homogenous if all the characters of the string are the same.

A substring is a contiguous sequence of characters within a string.

#### Solution: 

    class Solution {
    public int countHomogenous(String s) {
    var prev = '?'; var cnt = 1; var sum = 0;

    for (var c : s.toCharArray()) {
      if (c != prev) {
        cnt = 1;
        prev = c;
          }
      sum = (sum + cnt++) % 1000000007;
        }
    return sum;
      }
    }

Runtime: 6 ms, beating 95.62% of leetcode users solutions using java.
Memory: 44.08 mb, beatiing 63.58% of leetcode users solutions using java.

#### Concepts Applied:

Var, charArray, and if statement.

### Solution Nov 10, 2023 (Java, leetcode) 1743. Restore the Array From Adjacent Pairs (Medium)
In .LeetcodeDailySolution folder as Nov10,2023.java

#### Prompt:

There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.

You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.

It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.

Return the original array nums. If there are multiple solutions, return any of them.

#### Solution:

    class Solution {
    private static final int MINV = -100000, MAXV = 100000,
    RANGEV = MAXV - MINV + 1;
    private static final long UINT_MAX = 0xFFFFFFFFl;
    private static long[] index = new long[RANGEV];

    public int[] restoreArray(int[][] apairs) {
        final int n = apairs.length;
        if (n == 1) return apairs[0];
        int minv = MAXV, maxv = MINV;
        for (int i = 0; i < n; i++) {
            final var ap = apairs[i];
            final int v0 = ap[0], v1 = ap[1];
            final long j = i + 1;
            index[v0-MINV] += index[v0-MINV] == 0 ? j : j << 32;
            index[v1-MINV] += index[v1-MINV] == 0 ? j : j << 32;
            final int mn = Math.min(v0, v1);
            final int mx = Math.max(v0, v1);
            minv = Math.min(mn, minv);
            maxv = Math.max(mx, maxv);
        }

        int head = minv;
        while (head <= maxv
            && (index[head-MINV] > UINT_MAX || index[head-MINV] == 0))
            head++;

        int[] r = new int[n + 1];
        r[0] = head;
        int ri = 1;
        for (long idx = index[head-MINV]; idx != 0; idx = index[head-MINV]) {
            final int loidx = (int)(idx & UINT_MAX);
            final var ap = apairs[loidx - 1];
            index[head-MINV] >>>= 32;
            r[ri++] = head = ap[ap[0] == head ? 1 : 0];
            final int lonext = (int)(index[head-MINV] & UINT_MAX),
                      hinext = (int)(index[head-MINV] >>> 32);
            if (lonext == loidx) index[head-MINV] = hinext;
            else if (hinext == loidx) index[head-MINV] = lonext;
        }
        return r;
        }
    }

Runtime: 18 ms, beating 99.78% of leetcode users solutions using java.
Memory: 87.14 mb, beating 68.17% of leetcode users solutions using java.

#### Concepts Applied:

Long, apairs, index, Math, if statements, while and for loops.

### Solution Nov 11, 2023 (Java, leetcode) 2642. Design Graph With Shortest Path Calculator (Hard)
In .LeetcodeDailySolution folder as Nov11,2023.java

#### Prompt:

There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.

Implement the Graph class:

Graph(int n, int[][] edges) initializes the object with n nodes and the given edges.
addEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.
int shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.

#### Solution:

    class Graph {
    int[][] distance; int n;
    final int MAX_VALUE = 500_000_000;

    public Graph(int n, int[][] edges) {
        this.n = n;
        distance = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                distance[i][j] = MAX_VALUE;
            }
            distance[i][i] = 0;
        }
        for (int[] edge : edges) {
            distance[edge[0]][edge[1]] = edge[2];
        }
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    distance[i][j] = Math.min(
                        distance[i][j],
                        distance[i][k] + distance[k][j]
                    );
                }
            }
        }
    }
    
    public void addEdge(int[] edge) {
        if (distance[edge[0]][edge[1]] <= edge[2]) {
            return;
        }
        distance[edge[0]][edge[1]] = edge[2];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                distance[i][j] = Math.min(
                    distance[i][j],
                    distance[i][edge[0]] + edge[2] + distance[edge[1]][j]
                );
            }
        }
    }
    public int shortestPath(int node1, int node2) {
        if (distance[node1][node2] == MAX_VALUE) {
            return -1;
        }
        return distance[node1][node2];
        }
    }

Runtime: 64 ms, beating 97.92% of leetcode users solutions using java.
Memory: 54.40 mb, beating 76.67% of leetcode users solutions using java.

#### Concepts Applied:

Graph, for loops, if statements, Math, and nodes.

### Solution Nov 12, 2023 (Java, leetcode) 815 Bus Routes (Hard)
In .LeetcodeDailySolution folder as Nov12,2023.java

#### Prompt:

You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.

For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.
You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.

Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.

#### Solution:

    class Solution {
    public int numBusesToDestination(int[][] routes, int source, int target) {
        if (source == target) {
            return 0;
        }
        int maxStop = -1;
        for (int[] route : routes) {
            for (int stop : route) {
                maxStop = Math.max(maxStop, stop);
            }
        }
        if (maxStop < target) {
            return -1;
        }
        int n = routes.length;
        int[] minBusesToReach = new int[maxStop + 1];
        Arrays.fill(minBusesToReach, n + 1);
        minBusesToReach[source] = 0;
        boolean flag = true;
        while (flag) {
            flag = false;
            for (int[] route : routes) {
                int min = n + 1;
                for (int stop : route) {
                    min = Math.min(min, minBusesToReach[stop]);
                }
                min++;
                for (int stop : route) {
                    if (minBusesToReach[stop] > min) {
                        minBusesToReach[stop] = min;
                        flag = true;
                    }
                }
            }
            
        }
        return (minBusesToReach[target] < n + 1 ? minBusesToReach[target] : -1);
        }
    }

Runtime: 4 ms, beating 82.66% of leetcode users solutions using java.
Memory: 53.89 mb, beating 97.41% of leetcode users solutions using java.

#### Concepts Applied:

For loops, Math, Arrays, boolean, while loop, and if statements.

### Solution Nov 13, 2023 (Java, leetcode) 2785. Sort Vowels in a String (Medium)
In .LeetcodeDailySolution folder as Nov13,2023.java

#### Prompt:

Given a 0-indexed string s, permute s to get a new string t such that:

All consonants remain in their original places. More formally, if there is an index i with 0 <= i < s.length such that s[i] is a consonant, then t[i] = s[i].
The vowels must be sorted in the nondecreasing order of their ASCII values. More formally, for pairs of indices i, j with 0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must not have a higher ASCII value than t[j].
Return the resulting string.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.

#### Solution:

    class Solution {
    boolean isVowel(Character c) {
        return c == 'a' || c == 'e' || c == 'o'|| c == 'u'|| c == 'i'
                || c == 'A' || c == 'E' || c == 'O'|| c == 'U'|| c == 'I';
    }
    public String sortVowels(String s) {
        int[] count = new int[1000];
        for (char c : s.toCharArray()) {
            if (isVowel(c)) {
                count[c - 'A']++;
            }
        }
        String sortedVowel = "AEIOUaeiou";
        StringBuilder ans = new StringBuilder();
        int j = 0;
        for (int i = 0; i < s.length(); i++) {
            if (!isVowel(s.charAt(i))) {
                ans.append(s.charAt(i));
            } else {
                while (count[sortedVowel.charAt(j) - 'A'] == 0) {
                    j++;
                }
                ans.append(sortedVowel.charAt(j));
                count[sortedVowel.charAt(j) - 'A']--;
            }
        }
        return ans.toString();
        }
    }

Runtime: 21 ms, beating 82.90% of leetcode users solutions using java.
Memory: 44.37 mb, beating 91.33% of leetcode users solutions using java.

#### Concepts Applied:

Booleans, chars, charArr, strings, for loops, charAt, if statements, else statements, and while loop.

### Solution Nov 14, 2023 (Java, leetcode) 1930. Unique Length-3 Palindromic Subsequences (Medium)
In .LeetcodeDailySolution folder as Nov14,2023.java

#### Prompt:

Given a string s, return the number of unique palindromes of length three that are a subsequence of s.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

A palindrome is a string that reads the same forwards and backwards.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".

#### Solution:

    class Solution {
    public int countPalindromicSubsequence(String inputString) {
        int[] minExist = new int[26];
        int[] maxExist = new int[26];
        for (int i = 0; i < 26; i++) {
            minExist[i] = Integer.MAX_VALUE;
            maxExist[i] = Integer.MIN_VALUE;
        }
        for (int i = 0; i < inputString.length(); i++) {
            int charIndex = inputString.charAt(i) - 'a';
            minExist[charIndex] = Math.min(minExist[charIndex], i);
            maxExist[charIndex] = Math.max(maxExist[charIndex], i);
        }
        int uniqueCount = 0;
        for (int charIndex = 0; charIndex < 26; charIndex++) {
            if (minExist[charIndex] == Integer.MAX_VALUE || maxExist[charIndex] == Integer.MIN_VALUE) {
                continue; 
            }
            HashSet<Character> uniqueCharsBetween = new HashSet<>();
            for (int j = minExist[charIndex] + 1; j < maxExist[charIndex]; j++) {
                uniqueCharsBetween.add(inputString.charAt(j));
            }
            uniqueCount += uniqueCharsBetween.size();
        }
        return uniqueCount;
        }
    }

Runtime: 155 ms, beating 75.16% of leetcode users solutions using java.
Memory: 44.29 mb, beating 71.41% of leetcode users solutions using java.

#### Concepts Applied:

Strings, for loops, charIndex, charAt, Math, and HashSet.

### Solution Nov 15, 2023 (Java, leetcode) 1846. Maximum Element After Decreasing and Rearranging (Medium)
In .LeetcodeDailySolution folder as Nov15,2023.java

#### Prompt:

You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:

The value of the first element in arr must be 1.
The absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.
There are 2 types of operations that you can perform any number of times:

Decrease the value of any element of arr to a smaller positive integer.
Rearrange the elements of arr to be in any order.
Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.

#### Solution:

    class Solution {
    public int maximumElementAfterDecrementingAndRearranging(int[] arr) {
        Arrays.sort(arr);
        arr[0] = 1;

        for (int i = 1; i < arr.length; ++i) {
            if (Math.abs(arr[i] - arr[i - 1]) <= 1) {
                continue; 
            } else {
                arr[i] = arr[i - 1] + 1; 
            }
        }
        return arr[arr.length - 1]; 
        }
    }

Runtime: 6 ms, beating 62.75% of leetcode users solutions using java.
Memory: 56.68 mb, beating 48.40% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loop, Math, if and else statements.

### Solution Nov 16, 2023 (Java, leetcode) 1980. Find Unique Binary String (Medium)
In .LeetcodeDailySolution folder as Nov16,2023.java

#### Prompt:

Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. 
If there are multiple answers, you may return any of them.

#### Solution:

    class Solution {
    public String findDifferentBinaryString(String[] nums) {
        StringBuilder sb = new StringBuilder();

        for(int i=0;i<nums.length;i++)
        {
            sb.append(nums[i].charAt(i) == '0'? "1": "0");
        }
        return new String(sb);
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.43 mb, beating 73.89% of leetcode users solutions using java.

#### Concepts Applied:

Strings, for loop, and charAt.

### Solution Nov 17, 2023 (Java, leetcode) 1877. Minimize Maximum Pair Sum in Array (Medium)
In .LeetcodeDailySolution folder as Nov17,2023.java

#### Prompt:

The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.

For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.
Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:

Each element of nums is in exactly one pair, and
The maximum pair sum is minimized.
Return the minimized maximum pair sum after optimally pairing up the elements.

#### Solution: 

    class Solution {
    public int minPairSum(int[] nums) {
        Arrays.sort(nums);
        int left = 0, right = nums.length - 1;
        int minMaxPairSum = Integer.MIN_VALUE;

        while (left < right) {
            int currentPairSum = nums[left] + nums[right];
            minMaxPairSum = Math.max(minMaxPairSum, currentPairSum);
            left++;
            right--;
        }
        return minMaxPairSum;
        }
    }

Runtime: 53 ms, beating 86.60% of leetcode users solutions using java.
Memory: 56.48 mb, beating 96.69% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, while loop, and Math.

### Solution Nov 18, 2023 (Java, leetcode) 1838. Frequency of the Most Frequent Element (Medium)
In .LeetcodeDailySolution folder as Nov18,2023.java

#### Prompt:

The frequency of an element is the number of times it occurs in an array.

You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.

Return the maximum possible frequency of an element after performing at most k operations.

#### Solution:

    class Solution {
    public int maxFrequency(int[] nums, int k) {
        Arrays.sort(nums);
        int i = 0;
        int j = 0;
        int sum = 0;
        int maxLength = 0;

        for (i = 0; i < nums.length; i++) {
            sum += nums[i];
            while ((i - j + 1) * nums[i] - sum > k) {
                sum -= nums[j];
                j++;
            }
            maxLength = Math.max(maxLength, i - j + 1);
        }
        return maxLength;
        }
    }

Runtime: 29 ms, beating 77.42% of leetcode users solutions using java.
Memory: 56.53 mb, beating 83.11% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loop, while loop, and Math.

### Solution Nov 19, 2023 (Java, leetcode) 1887. Reduction Operations to Make the Array Element Equal (Medium)
In .LeetcodeDailySolution folder as Nov19,2023.java

#### Prompt:

Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:

Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.

#### Solution:

    class Solution {
    public int reductionOperations(int[] nums) {
        int n = nums.length;
        int[] freq = new int[50001];

        for (int i = 0; i < n; i++) {
            freq[nums[i]]++;
        }
        int res = 0, operations = 0;

        for (int i = 50000; i >= 1; i--) {

            if (freq[i] > 0) {

                operations += freq[i];

                res += operations - freq[i];
            }
        }
        return res;
        }
    }

Runtime: 7 ms, beating 99.25% of leetcode users solutions using java.
Memory: 53.99 mb, beating 98.99% of leetcode users solutions using java.

#### Concepts Applied:

Array, for loop, and if statements.

### Solution Nov 20, 2023 (Java, leetcode) 2391. Minimum Amount of Time to Collect Garbage (Medium)
In .LeetcodeDailySolution folder as Nov20,2023.java

#### Prompt:

You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.

You are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.

There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.

Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.

Return the minimum number of minutes needed to pick up all the garbage.

#### Solution:

    class Solution {
    boolean hasG = false, hasP = false, hasM = false;
    public int garbageCollection(String[] garbage, int[] travel) {
        int n = garbage.length;
        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            ans += 3 * travel[i];
        }
        for (String s : garbage) {
            ans += s.length();
        }
        for (int i = n - 1; i > 0; i--) {
            if (!garbage[i].contains("G")) {
                ans -= travel[i - 1];
            } else {
                break;
            }
        }
        for (int i = n - 1; i > 0; i--) {
            if (!garbage[i].contains("P")) {
                ans -= travel[i - 1];
            } else {
                break;
            }
        }
        for (int i = n - 1; i > 0; i--) {
            if (!garbage[i].contains("M")) {
                ans -= travel[i - 1];
            } else {
                break;
            }
        }
        return ans;
        }
    }

Runtime: 2 ms, beating 99.33% of leetcode users solutions using java.
Memory: 60.74 mb, beating 88.61% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, for loops, and strings.

### Solution Nov 21, 2023 (Java, leetcode) 1814. Count Nice Pairs in an Array (Medium)
In .LeetcodeDailySolution folder as Nov21,2023.java

#### Prompt:

You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:

0 <= i < j < nums.length
nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public int countNicePairs(int[] nums) {
        final int mod = 1000000007;
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            nums[i] = nums[i] - reverse(nums[i]);
        }
        Arrays.sort(nums);
        long res = 0;
        for (int i = 0; i < len - 1; i++) {
            long count = 1;
            while (i < len - 1 && nums[i] == nums[i + 1]) {
                count++;
                i++;
            }
            res = (res % mod + (count * (count - 1)) / 2) % mod;
        }

        return (int) (res % mod);
    }
    private int reverse(int num) {
        int rev = 0;
        while (num > 0) {
            rev = rev * 10 + num % 10;
            num /= 10;
        }
        return rev;
        }
    }

Runtime: 20 ms, beating 100% of leetcode users solutions using java.
Memory: 54.70 mb, beating 63.24% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, long, for loops, and while loops.

### Solution Nov 22, 2023 (Java, leetcode) 1424. Diagonal Traverse II (Medium)
In .LeetcodeDailySolution folder as Nov22,2023.java

#### Prompt:

Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.

#### Solution:

    class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        Queue<Pair<Integer, Integer>> queue = new LinkedList();
        queue.offer(new Pair(0, 0));
        List<Integer> ans = new ArrayList();
        
        while (!queue.isEmpty()) {
            Pair<Integer, Integer> p = queue.poll();
            int row = p.getKey();
            int col = p.getValue();
            ans.add(nums.get(row).get(col));
            
            if (col == 0 && row + 1 < nums.size()) {
                queue.offer(new Pair(row + 1, col));
            }
            if (col + 1 < nums.get(row).size()) {
                queue.offer(new Pair(row, col + 1));
            }
        }
        int[] result = new int[ans.size()];
        int i = 0;
        for (int num : ans) {
            result[i] = num;
            i++;
        }
        return result;
        }
    }

Runtime: 28 ms, beating 72% of leetcode users solutions using java.
Memory: 68.89 mb, beating 63.64% of leetcode users solutions using java.

#### Concepts Applied:

List, linkedlist, queue, and Arraylist.

### Solution Nov 23, 2023 (Java, leetcode) 1630. Arithmetic Subarrays (Medium)
In .LeetcodeDailySolution folder as Nov23,2023.java

#### Prompt:

A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.

For example, these are arithmetic sequences:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic:

1, 1, 2, 5, 7
You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.

Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.

#### Solution:

    class Solution {
    public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {
        List<Boolean> res=new ArrayList<>();
        
        for(int i=0;i<l.length;i++){
            if(r[i]-l[i]<2) res.add(true);
            else{
                int minNum=minNum(nums,l[i],r[i]);
                int maxNum=maxNum(nums,l[i],r[i]);
                int diff=maxNum-minNum;
                int countDiff=r[i]-l[i];
                if(minNum==maxNum) res.add(true);
                else if(diff%countDiff!=0) res.add(false);
                else{
                    int d=diff/countDiff;
                    boolean[] mark=new boolean[r[i]-l[i]+1];
                    boolean flag=true;
                    for(int p=l[i];p<=r[i];p++){
                        if((nums[p]-minNum)%d!=0) {
                            flag=false;
                            break;
                        }
                        if(mark[(nums[p]-minNum)/d]){
                            flag=false;
                            break;
                        }
                        else {
                            mark[(nums[p]-minNum)/d]=true;
                        }

                    }
                    res.add(flag);
                }
                }
        }
        System.gc();
        return res;
    }  
        public int minNum(int[] nums,int left,int right){
            int ans=nums[left];
            for(int i=left;i<=right;i++){
                ans=Math.min(ans,nums[i]);
            }
            return ans;
        }
        public int maxNum(int[] nums,int left,int right){
            int ans=nums[left];
            for(int i=left;i<=right;i++){
                ans=Math.max(ans,nums[i]);
            }
            return ans;
        }
    }

Runtime: 10 ms, beating 97.52% of leetcode users solutions using java.
Memory: 42.34 mb, beating 99.72% of leetcode users solutions using java.

#### Concepts Applied:

Lists, booleans, ArrayLists, for loops, if statements, else statements, and Math.

### Solution Nov 24, 2023 (Java, leetcode) 1561. Maximum Number of Coins You Can Get (Medium)
In .LeetcodeDailySolution folder as Nov24,2023.java

#### Prompt:

There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:

In each step, you will choose any 3 piles of coins (not necessarily consecutive).
Of your choice, Alice will pick the pile with the maximum number of coins.
You will pick the next pile with the maximum number of coins.
Your friend Bob will pick the last pile.
Repeat until there are no more piles of coins.
Given an array of integers piles where piles[i] is the number of coins in the ith pile.

Return the maximum number of coins that you can have.

#### Solution:

    class Solution {
    public int maxCoins(int[] piles) {
        int ans = 0; int n = piles.length;
        Arrays.sort(piles);

        for (int i = n / 3; i < n; i += 2) {
            ans += piles[i];
        }
        return ans;
        }
    }

Runtime: 27 ms, beating 98.94% leetcode users solutions using java.
Memory: 54.45 mb, beating 72.08% leetcode users solutions using java.

#### Concepts Applied:

Arrays and for loop.

### Solution Nov 25, 2023 (Java, leetcode) 1685. Sum of Absolute Differences in a Sorted Array (Medium)
In .LeetcodeDailySolution folder as Nov25,2023.java

#### Prompt:

You are given an integer array nums sorted in non-decreasing order.

Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.

In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).

#### Solution:

    class Solution {
    public int[] getSumAbsoluteDifferences(int[] nums) {
        int n = nums.length;
        int[] prefix = new int[n];

        prefix[0] = nums[0];

        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] + nums[i];
        }
        
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int leftSum = prefix[i] - nums[i];
            int rightSum = prefix[n - 1] - prefix[i];
            
            int leftCount = i;
            int rightCount = n - 1 - i;
            
            int leftTotal = leftCount * nums[i] - leftSum;
            int rightTotal = rightSum - rightCount * nums[i];
            
            ans[i] = leftTotal + rightTotal;
        }
        return ans;
        }
    }

Runtime: 4 ms, beating 62.31% of leetcode users solutions using java.
Memory: 57.61 mb, beating 68.89% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loops, and prefix sums.

### Solution Nov 26, 2023 (Java, leetcode) 1727. Largest Submatrix With Rearrangements (Medium)
In .LeetcodeDailySolution folder as Nov26,2023.java

#### Prompt:

You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.

Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.

#### Solution:

    class Solution {
    public int largestSubmatrix(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;

        for (int i = 1; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == 1) {
                    matrix[i][j] += matrix[i - 1][j];
                }
            }
        }

        int res = 0;
        for (int i = 0; i < row; i++) {
            Arrays.sort(matrix[i]);

            for (int j = 0; j < col; j++) {
                int height = matrix[i][j];
                int width = col - j;
                res = Math.max(res, height * width);
            }
        }

        return res;        
        }
    }

Runtime: 8 ms, beating 100% of leetcode users solutions using java.
Memory: 67.44 mb, beating 56.32% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, for loops, and Math.

### Solution Nov 27, 2023 (Java, leetcode) 935. Knight Dealer (Medium)
In .LeetcodeDailySolution folder as Nov27,2023.java

#### Prompt:

The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:

A chess knight can move as indicated in the chess diagram below:

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/9f5adc8f-5fb5-4f5b-a3bb-bd91026b6958)

We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/9f358451-bcd4-481a-aefe-0b60f9d69667)

Given an integer n, return how many distinct phone numbers of length n we can dial.

You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.

As the answer may be very large, return the answer modulo 109 + 7.

#### Solution:

    class Solution {
    static final int MOD = 1_000_000_007;
    public int knightDialer(int n) {
        long[] curPos = new long[10];

        Arrays.fill(curPos, 1);

        for (int jump = 2; jump <= n; jump++) {
            long[] newPos = new long[10];

            newPos[0] = (curPos[6] + curPos[4]) % MOD;
            newPos[1] = (curPos[6] + curPos[8]) % MOD;
            newPos[2] = (curPos[7] + curPos[9]) % MOD;
            newPos[3] = (curPos[4] + curPos[8]) % MOD;
            newPos[4] = (curPos[0] + curPos[3] + curPos[9]) % MOD;
            newPos[5] = 0;  
            newPos[6] = (curPos[0] + curPos[1] + curPos[7]) % MOD;
            newPos[7] = (curPos[2] + curPos[6]) % MOD;
            newPos[8] = (curPos[1] + curPos[3]) % MOD;
            newPos[9] = (curPos[2] + curPos[4]) % MOD;

            curPos = newPos;
        }
        long totalCount = 0;
        for (int i = 0; i < 10; i++) {
            totalCount = (totalCount + curPos[i]) % MOD;
        }
        return (int) totalCount;
        }
    }

Runtime: 20 ms, beating 83.37% of leetcode users solutions using java.
Memory: 43.23 mb, beating 69.42% of leetcode users solutions using java.

#### Concepts Applied:

Long, arrays, pos, and for loop.

### Solution Nov 28, 2023 (Java, leetcode) 2147. Number of Ways to Divide a Long Corrdior (Hard)
In .LeetcodeDailySolution folder as Nov28,2023.jaca

#### Prompt:

Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant.

One room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.

Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.

Return the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.

#### Solution:

    class Solution {
    public int numberOfWays(String corridor) {
        int x = 1;
        int y = 0; 
        int z = 0;
        int mod = (int)1e9 + 7;
        
        for (int i = 0; i < corridor.length(); ++i)
            if (corridor.charAt(i) == 'S') {
                x = (x + z) % mod;
                z = y; 
                y = x;
                x = 0;
            } else {
                x = (x + z) % mod;
            }
        return z;
        }
    }

Runtime: 21 ms, beating 97.30% of leetcode users solutions using java.
Memory: 44.83 mb, beating 70.27% of leetcode users solutions using java.

#### Concepts Applied:

charAt, strings, for loop, if statement, and else statement.

### Solution Nov 29, 2023 (Java, leetcode) 191. Number of 1 Bits (Easy)
In .LeetcodeDailySolution folder as Nov29,2023.java

#### Prompt:

Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).

Note:

Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.

#### Solution:

    class Solution {
    public int hammingWeight(int n) {
        int count = 0;

        while (n != 0) {
            n = n & (n - 1);
            count++;
        }
        return count;
      }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.80 mb, beating 6.93% of leetcode users solutions using java.

#### Concepts Applied:

While loop, and Brian Kernighan's Algorithm.

### Solution Nov 30, 2023 (Java, leetcode) 1611. Minimum One Bit Operations to Make Integers Zero (Hard) 
In .LeetcodeDailySolution folder as Nov30,2023.java

#### Prompt:

Given an integer n, you must transform it into 0 using the following operations any number of times:

Change the rightmost (0th) bit in the binary representation of n.
Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.
Return the minimum number of operations to transform n into 0.

#### Solution:

    class Solution {
        public int minimumOneBitOperations(int n) {
        int sign = 1, res = 0;

        while (n > 0) {
            res += n ^ (n - 1) * sign;
            n &= n - 1;
            sign = -sign;
        }
        return Math.abs(res);
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.27 mb, beating 56.86% of leetcode users solutions using java.

#### Concepts Applied:

Math, recursion, and while loop.

### Solution Dec 1, 2023 (Java, leetcode) 1662. Check If Two String Arrays are Equivalent (Easy)
In .LeetcodeDailySolution folder as Dec1,2023.java

#### Prompt:

Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.

A string is represented by an array if the array elements concatenated in order forms the string.

#### Solution:

    class Solution {
    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {

        StringBuilder sb1 = new StringBuilder();

        for ( String str : word1 ) sb1.append(str);
        StringBuilder sb2 = new StringBuilder();

        for ( String str : word2 ) sb2.append(str);
        
        return (sb1.toString().equals(sb2.toString()));
        
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.35 mb, beating 55.19% of leetcode users solutions using java.

#### Concepts Applied:

Strings, stringbuilder, boolean, and for loop.

### Solution Dec 2, 2023 (Java, leetcode) 1160. Find Words That Can Be Formed by Characters (Easy)
In .LeetcodeDailySolution folder as Dec2,2023.java

#### Prompt:

You are given an array of strings words and a string chars.

A string is good if it can be formed by characters from chars (each character can only be used once).

Return the sum of lengths of all good strings in words.

#### Solution:

    class Solution {
    public int countCharacters(String[] words, String chars) {
        int[] counts = new int[26];

        for(int i=0;i<chars.length();i++){
            counts[chars.charAt(i)-'a']++;
        }
        
        int res =0 ;

        for(String s : words)
        {
            if(canForm(s,counts))
                res+=s.length();
        }
        return res;
    }

    boolean canForm(String word, int[] counts){
        int[] c = new int[26];

        for(int i =0;i<word.length();i++)
        {
            int x = word.charAt(i)-'a';
            c[x]++;
            if(c[x] > counts[x])
                return false;
        }
        return true;
        }
    }

Runtime: 2 ms, beating 100% of leetcode users solutions using java.
Memory: 44.00 mb, beating 79.77% of leetcode users solutions using java.

#### Concepts Applied:

Strings, chars, charAt, for loops, and boolean.

### Solution Dec 3, 2023 (Java, leetcode) 1266. Minimum Time Visiting All Points (Easy)
In .LeetcodeDailySolution folder as Dec3,2023.java

#### Prompt:

On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.

You can move according to these rules:

In 1 second, you can either:
move vertically by one unit,
move horizontally by one unit, or
move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).
You have to visit the points in the same order as they appear in the array.
You are allowed to pass through points that appear later in the order, but these do not count as visits.

#### Solution:

    class Solution {
    public int toTime(int[] from, int[] to) {
        int xDiff = Math.abs(from[0] - to[0]);
        int yDiff = Math.abs(from[1] - to[1]);
        
        return Math.max(xDiff, yDiff);
    }
    
    public int minTimeToVisitAllPoints(int[][] points) {
        int time = 0;
    
        for (int i = 1; i < points.length; i++) {
            time += toTime(points[i - 1], points[i]);
        }
        return time;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.16 mb, beating 60.89% of leetcode users solutions using java.

#### Concepts Applied:

Math, and for loop.

### Solution Dec 4, 2023 (Java, leetcode) 2264. Largest 3-Same-Digit Number in String (Easy)
In .LeetcodeDailySolution folder as Dec4,2023.java

#### Prompt:

You are given a string num representing a large integer. An integer is good if it meets the following conditions:

It is a substring of num with length 3.
It consists of only one unique digit.
Return the maximum good integer as a string or an empty string "" if no such integer exists.

Note:

A substring is a contiguous sequence of characters within a string.
There may be leading zeroes in num or a good integer.

#### Solution:

    class Solution {
    public String largestGoodInteger(String num) {
        char maxDigit = '\0';

        for (int index = 0; index <= num.length() - 3; ++index) {
            if (num.charAt(index) == num.charAt(index + 1) && num.charAt(index) == num.charAt(index + 2)) {
                maxDigit = (char) Math.max(maxDigit, num.charAt(index));
            }
        }

        return maxDigit == '\0' ? "" : new String(new char[]{maxDigit, maxDigit, maxDigit});
        }
    }

Runtime: 2 ms, beating 80.42% of leetcode users solutions using java.
Memory: 40.70 mb, beating 82.25% of leetcode users solutions using java.

#### Concepts Applied:

Char, charAt, for loop, index, and if statement.

### Solution Dec 5, 2023 (Java, leetcode) 1688. Count of Matches in Tournament (Easy)
In .LeetcodeDailySolution folder as Dec5,2023.java

#### Prompt:

You are given an integer n, the number of teams in a tournament that has strange rules:

If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.
If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.
Return the number of matches played in the tournament until a winner is decided.

#### Solution:

    class Solution {
    public int numberOfMatches(int n) {
        
        return n - 1;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.16 mb, beating 61.47% of leetcode users solutions using java.

#### Concepts Applied:

If after each match one team needs to be eliminated, n-1 satisfies all conditions. 

### Solution Dec 6, 2023 (Java, leetcode) 1716. Calculate Money in Leetcode Bank (Easy)
In .LeetcodeDailySolution folder as Dec6,2023.java

#### Prompt:

Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.

He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday.
Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.

#### Solution:

    class Solution {
    public int totalMoney(int n) {
        int total = 0;

        for (int day = 0; day < n; day++) {
            total += (day / 7 + 1) + (day % 7);
        }

        return total;        
        }
    }

Runtime: 1 ms, beating 60.52% of leetcode users solutions using java.
Memory: 39.10 mb, beating 67.38% of leetcode users solutions using java.

#### Concepts Applied:

For loop and simple calculations.

### Solution Dec 7, 2023 (Java, leetcode) 1903. Largest Odd Number in String (Easy)
In .LeetcodeDailySolution folder as Dec7,2023.java

#### Prompt:

You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string "" if no odd integer exists.

A substring is a contiguous sequence of characters within a string.

#### Solution:

    class Solution {
    public String largestOddNumber(String num) {

        for(int i=num.length()-1; i>=0; i--){
            if((num.charAt(i)-'0')%2==1)  
            return num.substring(0,i+1);
        }
        return "";
        }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java.
Memory: 44.19 mb, beating 94% of leetcode users solutions using java.

#### Concepts Applied:

Strings, for loop, if statement, charAt, and substring.

### Solution Dec 8, 2023 (Java, leetcode) 606. Construct String from Binary Tree (Easy)
In .LeetcodeDailySolution folder as Dec8,2023.java

#### Prompt:

Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.

Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.

#### Solution:

    class Solution {
    public String tree2str(TreeNode t) {
        StringBuilder res = new StringBuilder();
        dfs(t, res);
        return res.toString();
    }
    public static void dfs(TreeNode t, StringBuilder res) {
        if (t == null)
            return;

        res.append(String.valueOf(t.val));
        if (t.left == null && t.right == null)
            return;

        res.append('(');
        dfs(t.left, res);
        res.append(')');
        
        if (t.right != null) {
            res.append('(');
            dfs(t.right, res);
            res.append(')');
            }
        }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java.
Memory: 43.30 mb, beating 86.73% of leetcode users solutions using java.

#### Concepts Applied:

StringBuilder, strings, dfs, and if statements.

### Solution Dec 9, 2023 (Java, leetcode) 94. Binary Tree Inorder Traversal (Easy)
In .LeetcodeDailySolution folder as Dec9,2023.java

#### Prompt:

Given the root of a binary tree, return the inorder traversal of its nodes' values.

#### Solution:

    class Solution {
    List<Integer> ans = new ArrayList<>();
        public List<Integer> inorderTraversal(TreeNode root) {

        if (root == null) return Collections.emptyList();

        inorderTraversal(root.left);
        ans.add(root.val);
        inorderTraversal(root.right);

        return ans;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.30 mb, beating 92.99% of leetcode users solutions using java.

#### Concepts Applied:

Lists, ArrayList, inorderTraversal, and TreeNode.

### Solution Dec 10, 2023 (Java, leetcode) 867. Transpose Matrix (Easy)
In .LeetcodeDailySolution folder as Dec10,2023.java

#### Prompt:

Given a 2D integer array matrix, return the transpose of matrix.

The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/05c43a56-2bf7-4781-95a2-c061ad8608cd)

#### Solution:

    class Solution {
    public int[][] transpose(int[][] matrix) {
        int row=matrix.length;
        int col=matrix[0].length;
        int arr[][]=new int[col][row];
    
        for(int i=0;i<col;i++){
            for(int j=0;j<row;j++){
            arr[i][j]=matrix[j][i];
            }
        }
        return arr;
        }
    }   

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.88 mb, beating 97.49% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, row, col, arr, and for loop. 

### Solution Dec 11, 2023 (Java, leetcode) 1287. Element Appearing More Than 25% In Sorted Array (Easy)
In .LeetcodeDailySolution folder as Dec11,2023.java

#### Prompt:

Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.

#### Solution:

    class Solution {
    public int findSpecialInteger(int[] arr) {
        int size = arr.length;
        int qtr = size / 4;
        int cnt = 1;
        int p = arr[0];

        for (int i = 1 ; i < arr.length ; i++) {
            if ( p == arr[i]) cnt++;
            else cnt = 1;
            if (cnt > qtr) return arr[i];
            p = arr[i];
        }
        return p;
        }
    }

Runtime: 1 ms, beating 64.27% of leetcode users solutions using java.
Memory: 43.13 mb, beating 72.62% of leetcode users solutions using java.

#### Concepts Applied:

arr, for loop, else statement, and if statement.

### Solution Dec 12, 2023 (Java, leetcode) 1464. Maximum Product of Two Elements in an Array (Easy)
In .LeetcodeDailySolution folder as Dec12,2023.java

#### Prompt:

Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).

#### Solution:

    class Solution {
    public int maxProduct(int[] nums) {
        int firstMax = 0;
        int secondMax = 0;

        for (int num : nums) {
            if (num > firstMax) {
                secondMax = firstMax;
                firstMax = num;
            } else {
                secondMax = Math.max(secondMax, num);
            }
        }
        return (firstMax - 1) * (secondMax - 1);        
        }
    }

Runtime: 1 ms, beating 78.60% of leetcode users solutions using java.
Memory: 41.46 mb, beating 71.33% of leetcode users solutions using java.

#### Concepts Applied:

For loop, if statement, else statement, and Math.

### Solution Dec 13, 2023 (Java, leetcode) 1582. Special Positions in a Binary Matrix (Easy)
In .LeetcodeDailySolution folder as Dec13,2023.java

#### Prompt:

Given an m x n binary matrix mat, return the number of special positions in mat.

A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).

#### Solution:

    class Solution {
    public int numSpecial(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int[] rowCount = new int[m];
        int[] colCount = new int[n];
        
        for (int row = 0; row < m; row++) {
            for (int col = 0; col < n; col++) {
                if (mat[row][col] == 1) {
                    rowCount[row]++;
                    colCount[col]++;
                }
            }
        }
        int ans = 0;
        for (int row = 0; row < m; row++) {
            for (int col = 0; col < n; col++) {
                if (mat[row][col] == 1) {
                    if (rowCount[row] == 1 && colCount[col] == 1) {
                        ans++;
                    }
                }
            }
        }
        return ans;
        }
    }

Runtime: 2 ms, beating 89.24% of leetcode users solutions using java.
Memory: 43.70 mb, beating 75.07% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, row, col, for loops, and if statements.

### Solution Dec 14, 2023 (Java, leetcode) 2482. Difference Between Ones and Zeros in Row and Column (Medium)
In .LeetcodeDailySolution folder as Dec14,2023.java

#### Prompt:

You are given a 0-indexed m x n binary matrix grid.

A 0-indexed m x n difference matrix diff is created with the following procedure:

Let the number of ones in the ith row be onesRowi.
Let the number of ones in the jth column be onesColj.
Let the number of zeros in the ith row be zerosRowi.
Let the number of zeros in the jth column be zerosColj.
diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
Return the difference matrix diff.

#### Solution:

    class Solution {
    public int[][] onesMinusZeros(int[][] grid) {
        int row = grid.length; 
        int col = grid[0].length;
        int[][] diff = new int[row][col];
        int[] r = new int[row]; 
        int[] c = new int[col]; 

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                r[i] += grid[i][j]; 
                c[j] += grid[i][j];
            }
        }
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                diff[i][j] = 2 * (r[i] + c[j]) - row - col;
            }
        }
        return diff; 
        }
    }

Runtime: 9 ms, beating 70.09% of leetcode users solutions using java.
Memory: 71.60 mb, beating 64.84% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, row, col, grid, and for loops.

### Solution Dec 15, 2023 (Java, leetcode) 1436. Destination City (Easy)
In .LeetcodeDailySolution folder as Dec15,2023.java

#### Prompt:

You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.

It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.

#### Solution:

    class Solution {
    public String destCity(List<List<String>> paths) {
        Set<String> cities = new HashSet<>(); 
        for (List<String> path : paths) {
            cities.add(path.get(0)); 
        }
        
        for (List<String> path : paths) {
            String dest = path.get(1); 
            if (!cities.contains(dest)) {
                return dest; 
            }
        }
        return "";
        }
    }

Runtime: 2 ms, beating 79.16% of leetcode users solutions using java.
Memory: 42.93 mb, beating 60.20% of leetcode users solutions using java.

#### Concepts Applied:

List, Set, HashSet, for loops, and if statement.

### Solution Dec 16, 2023 (Java, leetcode) 241. Valid Anagram (Easy)
In .LeetcodeDailySolution folder Dec16,2023.java

#### Prompt:

Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

#### Solution:

    class Solution {
    public boolean isAnagram(String s, String t) {
        int[] count = new int[26];

        if (s.length() != t.length()) {
            return false;
        }
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a'] += 1;
        }
        for (int i = 0; i < t.length(); i++) {
            if (count[t.charAt(i) - 'a'] == 0) {
                return false;
            }
            count[t.charAt(i) - 'a'] -= 1;
        }
        return true;        
        }
    }

Runtime: 4 ms, beating 73.09% of leetcode users solutions using java.
Memory: 42.18 mb, beating 78.86% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, strings, if statements, for loops, and charAt.

### Solution Dec 17, 2023 (Java, leetcode) 2353. Design a Food Rating System (Medium)
In .LeetcodeDailySolution folder as Dec17,2023.java

#### Prompt:

Design a food rating system that can do the following:

Modify the rating of a food item listed in the system.
Return the highest-rated food item for a type of cuisine in the system.
Implement the FoodRatings class:

FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods, cuisines and ratings, all of which have a length of n.
foods[i] is the name of the ith food,
cuisines[i] is the type of cuisine of the ith food, and
ratings[i] is the initial rating of the ith food.
void changeRating(String food, int newRating) Changes the rating of the food item with the name food.
String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine. If there is a tie, return the item with the lexicographically smaller name.
Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.

#### Solution:

    class Food implements Comparable<Food> {
    public int foodRating;
    public String foodName;
    public Food(int foodRating, String foodName) {
        this.foodRating = foodRating;
        this.foodName = foodName;
    }
    @Override
    public int compareTo(Food other) {
        if (foodRating == other.foodRating) {
            return foodName.compareTo(other.foodName);
        }
        return -1 * Integer.compare(foodRating, other.foodRating);
        }
    }
    class FoodRatings {
    private Map<String, Integer> foodRatingMap;
    private Map<String, String> foodCuisineMap;
    private Map<String, PriorityQueue<Food>> cuisineFoodMap;

    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
        foodRatingMap = new HashMap<>();
        foodCuisineMap = new HashMap<>();
        cuisineFoodMap = new HashMap<>();

        for (int i = 0; i < foods.length; ++i) {

            foodRatingMap.put(foods[i], ratings[i]);
            foodCuisineMap.put(foods[i], cuisines[i]);
            cuisineFoodMap.computeIfAbsent(cuisines[i], k -> new PriorityQueue<>()).add(new Food(ratings[i] , foods[i]));
        }
    } 
    public void changeRating(String food, int newRating) {
        foodRatingMap.put(food, newRating);
        String cuisineName = foodCuisineMap.get(food);
        cuisineFoodMap.get(cuisineName).add(new Food(newRating, food));
    }
    public String highestRated(String cuisine) {
        Food highestRated = cuisineFoodMap.get(cuisine).peek();

        while (foodRatingMap.get(highestRated.foodName) != highestRated.foodRating) {
            cuisineFoodMap.get(cuisine).poll();
            highestRated = cuisineFoodMap.get(cuisine).peek();
        }        
        return highestRated.foodName;
        }
    }

Runtime: 157 ms, beating 93.68% of leetcode users solutions using java.
Memory: 68.66 mb, beating 95.40% of leetcode users solutions using java.

#### Concepts Applied:

Maps, overriding, strings, HashMaps, if statement, for loops, and while loop.

### Solution Dec 18, 2023 (Java, leetcode) 1913. Maximum Product Difference Between Two Pairs (Easy)
In .LeetcodeDailySolution folder as Dec18,2023.java

#### Prompt:

The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).

For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.

Return the maximum such product difference.

#### Solution:

    class Solution {
    public int maxProductDifference(int[] nums) {
        int firstBig = 0, secondBig = 0;
        int firstSmall = Integer.MAX_VALUE, secondSmall = Integer.MAX_VALUE;

        for (int n : nums) {
            if (n < firstSmall) {
                secondSmall = firstSmall;
                firstSmall = n;
            } else if (n < secondSmall) {
                secondSmall = n;
            }
            if (n > firstBig) {
                secondBig = firstBig;
                firstBig = n;
            } else if (n > secondBig) {
                secondBig = n;
            }
        }
        return firstBig * secondBig - firstSmall * secondSmall;        
        }
    }

Runtime: 2 ms, beating 97.52% of leetcode users solutions using java.
Memory: 44.11 mb, beating 55.36% of leetcode users solutions using java.

#### Concepts Applied:

For loops, if statements, else-if statements, and integer pairs.

### Solution Dec 19, 2023 (Java, leetcode) 661. Image Smoother 
In .LeetcodeDailySolution folder as Dec19,2023.java

#### Prompt:

An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/80c006ea-91de-46dc-abc7-2d79623dd15f)

Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.

#### Solution:

    class Solution {
    public int[][] imageSmoother(int[][] img) {
        int rows = img.length;
        int cols = img[0].length;
        int[][] result = new int[rows][cols];

        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                int totalSum = 0;
                int count = 0;

                for (int x = Math.max(0, i-1); x < Math.min(rows, i+2); ++x) {
                    for (int y = Math.max(0, j-1); y < Math.min(cols, j+2); ++y) {
                        totalSum += img[x][y];
                        count += 1;
                    }
                }
                result[i][j] = totalSum / count;
            }
        }
        return result;
        }
    }

Runtime: 6 ms, beating 80% of leetcode users solutions using java.
Memory: 44.46 mb, beating 71.94% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, rows, cols, for loops, and Math.

### Solution Dec 20, 2023 (Java, leetcode) 2706. Buy Two Chocolates (Easy)
In .LeetcodeDailySolution folder as Dec20,2023.java

#### Prompt:

You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.

You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.

Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.

#### Solution:

    class Solution {
    public int buyChoco(int[] prices, int money) {
        Arrays.sort(prices);
        int minCost = prices[0] + prices[1];

        if (minCost <= money) {
            return money - minCost;
        }
        return money;
        }
    }

Runtime: 2 ms, beating 79% of leetcode users solutions using java.
Memory: 44.49 mb, beating 5.58% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, and if statement.

### Solution Dec 21, 2023 (Java, leetcode) 1637. Widest Vertical Area Between Two Points Containing No Points (Medium)
In .LeetcodeDailySolution folder as Dec21,2023.java

#### Prompt:

Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.

A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.

Note that points on the edge of a vertical area are not considered included in the area.

#### Solution:

    class Solution {
    public int maxWidthOfVerticalArea(int[][] points) {
        int[] X = new int[points.length];
        
        for (int i = 0; i < points.length; i++) {
            X[i] = points[i][0];
        }
        Arrays.sort(X);

        int maxWidth = 0;

        for (int i = 1; i < X.length; i++) {
            int width = X[i] - X[i - 1];

            if (width > maxWidth) {
                maxWidth = width;
            }
        }
        return maxWidth;
        }
    }

Runtime: 13 ms, beating 98.07% of leetcode users solutions using java. 
Memory: 72.73 mb, beating 5.41% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, for loops, and if statement.

### Solution Dec 22, 2023 (Java, leetcode) 1422. Maximum Score After Splitting a String (Easy)
In .LeetcodeDailySolution folder as Dec22,2023.java

#### Prompt:

Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).

The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.

#### Solution:

    class Solution {
    public int maxScore(String s) {
        int left = -1;
        int zeros = 0;
        int ones = 0;

        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) == '0') {
                zeros++;
            } else {
                ones++;
            }
            left = Math.max(left, zeros - ones);
        }
        if (s.charAt(s.length() - 1) == '1') {
            ones += 1;
        }
        return left + ones;       
        }
    }

Runtime: 1 ms, beating 97.83% of leetcode users solutions using java.
Memory: 41.36 mb, beating 34.35% of leetcode users solutions using java.

#### Concepts Applied:

For loops, charAt, strings, Math, else statement, and if statements. 

### Solution Dec 23, 2023 (Java, leetcode) 1496. Path Crossing (Easy)
In .LeetcodeDailySolution folder as Dec23,2023.java

#### Prompt:

Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.

Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.

#### Solution:

    class Solution {
    public boolean isPathCrossing(String path) {
        Map<Character, Pair<Integer, Integer>> moves = new HashMap();
        moves.put('N', new Pair(0, 1));
        moves.put('S', new Pair(0, -1));
        moves.put('W', new Pair(-1, 0));
        moves.put('E', new Pair(1, 0));
        
        Set<Pair<Integer, Integer>> visited = new HashSet();
        visited.add(new Pair(0, 0));
        
        int x = 0;
        int y = 0;
        
        for (Character c : path.toCharArray()) {
            Pair<Integer, Integer> curr = moves.get(c);
            int dx = curr.getKey();
            int dy = curr.getValue();
            x += dx;
            y += dy;
            
            Pair<Integer, Integer> pair = new Pair(x, y);
            
            if (visited.contains(pair)) {
                return true;
            }
            visited.add(pair);
        }
        return false;
        }
    }

Runtime: 1 ms, beating 96.48% of leetcode users solutions using java.
Memory: 42.31 mb, beating 5.29% of leetcode users solutions using java.

#### Concepts Applied:

Map, HashMap, Set, HashSet, Pairs, for loop, and if statement. 

### Solution Dec 24, 2023 (Java, leetcode) 1758. Minimum Charges To Make Alternating Binary String (Easy)
In .LeetcodeDailySolution folder as Dec24,2023.java

#### Prompt:

You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.

The string is called alternating if no two adjacent characters are equal. For example, the string "010" is alternating, while the string "0100" is not.

Return the minimum number of operations needed to make s alternating.

#### Solution:

    class Solution {
    public int minOperations(String s) {
        int n = s.length(), count = 0;

        if (n == 1) return 0;
        
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0 && s.charAt(i) == '1') count++;
            if (i % 2 == 1 && s.charAt(i) == '0') count++;
        }
        return Math.min(count, n - count); 
        }
    }

Runtime: 3 ms, beating 91.88% of leetcode users solutions using java.
Memory: 42.29 mb, beating 10.06% of leetcode users solutions using java.

#### Concepts Applied:

If statements, for loop, charAt, strings, and Math.

### Solution Dec 25, 2023 (Java, leetcode) 91. Decode Ways (Medium)
In .LeetcodeDailySolution folder as Dec25,2023.java 

#### Prompt:

A message containing letters from A-Z can be encoded into numbers using the following mapping:

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, "11106" can be mapped into:

"AAJF" with the grouping (1 1 10 6)
"KJF" with the grouping (11 10 6)
Note that the grouping (1 11 06) is invalid because "06" cannot be mapped into 'F' since "6" is different from "06".

Given a string s containing only digits, return the number of ways to decode it.

The test cases are generated so that the answer fits in a 32-bit integer.

#### Solution:

    class Solution {
    public int numDecodings(String s) {
        int n=s.length();
        int[] dp=new int[n+1];

        dp[n]=1 ;

        for(int i = n-1 ; i >= 0 ; i--)
            if(s.charAt(i)!='0') {

                dp[i] = dp[i+1] ;
                
                if(i < n-1 && (s.charAt(i)=='1' || s.charAt(i)=='2' && s.charAt(i+1)<'7')) 
				    dp[i]+=dp[i+2];
            }
        return dp[0];   
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 41.78 mb, beating 10.62% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming, for loop, if statements, and charAt.

### Solution Dec 26, 2023 (Java, leetcode) 1155. Number of Dice Rolls With Target Sum (Medium)
In .LeetcodeDailySolution folder as Dec26,2023.java

#### Prompt:

You have n dice, and each die has k faces numbered from 1 to k.

Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice, so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public int numRollsToTarget(int d, int f, int target) {
        final int mod = 1000000007;

        int[] dp1 = new int[target + 1];  
        int[] dp2 = new int[target + 1];  

        dp1[0] = 1;

        for (int i = 1; i <= d; ++i) {

            int prev = dp1[0];  

            for (int j = 1; j <= target; ++j) {
                dp2[j] = prev; 
                prev = (int) ((prev + dp1[j]) % mod);

                if (j >= f) prev = (int) ((prev - dp1[j - f] + mod) % mod);
            }
            int[] temp = dp1;
            dp1 = dp2;
            dp2 = temp;
            dp2[0] = 0;
        }
        return dp1[target];
    	}
    }

Runtime: 5 ms, beating 94.68% of leetcode users solutions using java.
Memory: 40.54 mb, beating 78.19% of leetcode users solutions using java.

#### Concepts Applied:

Modulo, dynamic programming, for loops, and if statements.

### Solution Dec 27, 2023 (Java, leetcode) 1578. Minimum Time to Make Rope Colorful (Medium)
In .LeetcodeDailySolution folder as Dec27,2023.java

#### Prompt:

Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.

Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.

Return the minimum time Bob needs to make the rope colorful.

#### Solution:

    class Solution {
    public int minCost(String colors, int[] neededTime) {
        int time = 0;
        int n = colors.length();

        for (int i = 1; i < n; i++) {
            if (colors.charAt(i) == colors.charAt(i - 1)) {
                time += Math.min(neededTime[i], neededTime[i - 1]);
                neededTime[i] = Math.max(neededTime[i], neededTime[i - 1]);
           }
        }      
        return time;
   	}
    }

Runtime: 7 ms, beating 89.50% of leetcode users solutions using java.
Memory: 60.46 mb, beating 21.50% of leetcode users solutions using java.

#### Concepts Applied:

For loop, if statement, charAt, and Math.

### Solution Dec 28, 2023 (Java, leetcode) 1531. String Compression II (Hard)
In .LeetcodeDailySolution folder as Dec28,2023.java

#### Prompt:

Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "aabccc" we replace "aa" by "a2" and replace "ccc" by "c3". Thus the compressed string becomes "a2bc3".

Notice that in this problem, we are not adding '1' after single characters.

Given a string s and an integer k. You need to delete at most k characters from s such that the run-length encoded version of s has minimum length.

Find the minimum length of the run-length encoded version of s after deleting at most k characters.

#### Solution:

    class Solution {
    private int[][] memo = new int[101][101];
    private int recursion(String s, int i, int K) {
        int n = s.length();
        int k = K;

        if (n - i <= k) {
            return 0;
        }
        if (memo[i][k] != -1) {
            return memo[i][k];
        }
        int ans = k > 0 ? recursion(s, i + 1, k - 1) : 101;
        int c = 1;
        
        for (int j = i + 1; j <= n; j++) {

            ans = Math.min(ans, 1 + ((c > 99) ? 3 : (c > 9) ? 2 : (c > 1) ? 1 : 0) + 		recursion(s, j, k));

            if (j < n && s.charAt(i) == s.charAt(j)) {
                c++;
            } else if (--k < 0) {
                break;
            }
        }
        return memo[i][K] = ans;
    }
    public int getLengthOfOptimalCompression(String s, int k) {
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
        return recursion(s, 0, k);
      }
    }

Runtime: 42 ms, beating 73.33% of leetcode users solutions using java.
Memory: 42.29 mb, beating 51.11% of leetcode users solutions using java.

#### Concepts Applied:

Recursion, Math, charAt, if statements, for loops, else if statement, and Arrays.

### Solution Dec 29, 2023 (Java, leetcode) 1335. Minimum Difficulty of a Job Schedule (Hard)
In .LeetcodeDailySolution folder as Dec29,2023.java

#### Prompt:

You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 <= j < i).

You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done on that day.

You are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i].

Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.

#### Solution:

    class Solution {
    public int minDifficulty(int[] jobDifficulty, int d){
        int jobs = jobDifficulty.length;
        
        if (jobs < d)
            return -1;

        int[][] dp = new int[d][jobs];

        dp[0][0] = jobDifficulty[0];
        
        for (int i = 1; i < jobs; i++)
            dp[0][i] = Math.max(dp[0][i - 1], jobDifficulty[i]);

        
        for (int days = 1; days < d; days++) {

            for (int i = days; i < jobs; i++) {
                int localMax = jobDifficulty[i];
                dp[days][i] = Integer.MAX_VALUE; 
                
                for (int j = i; j >= days; j--) {
                    localMax = Math.max(localMax, jobDifficulty[j]);
                    dp[days][i] = Math.min(dp[days][i], dp[days - 1][j - 1] + localMax);
                }
            }
        }
        return dp[d - 1][jobs - 1];
      }
    }

Runtime: 12 ms, beating 30.93% of leetcode users solutions using java.
Memory: 41.31 mb, beating 18.97% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming, Math, for loops, and if statement.

### Solution Dec 30, 2023 (Java, leetcode) 1897. Redistribute Characters to Make All Strings Equal (Easy)
In .LeetcodeDailySolution folder as Dec30,2023.java

#### Prompt:

You are given an array of strings words (0-indexed).

In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j].

Return true if you can make every string in words equal using any number of operations, and false otherwise.

#### Solution:

    class Solution {
    public boolean makeEqual(String[] words) {
        int[] counts = new int[26];

        for (String word : words) {
            for (char c : word.toCharArray()) {
                counts[c - 'a']++;
            }
        }
        int n = words.length;

        for (int val : counts) {
            if (val % n != 0) {
                return false;
            }
        }
        return true;
      }
    }

Runtime: 3 ms, beating 58.96% of leetcode users solutions using java.
Memory: 44.12 mb, beating 6.64% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, for loops, CharArray, and if statement.

### Solution Dec 31, 2023 (Java, leetcode) 1624. Largest Substring Between Two Equal Points (Easy)
In .LeetcodeDailySolution folder as Dec31,2023.java

#### Prompt:

Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.

A substring is a contiguous sequence of characters within a string.

#### Solution:

    class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
    int maxDistance = -1;
    
    for (int i = 0; i < s.length() - 1; i++) {
        for (int j = s.length() - 1; j > i; j--) {
            if (s.charAt(i) == s.charAt(j)) {
                maxDistance = Math.max(maxDistance, j - i - 1);
                break;
            }
        }
    }
 	return maxDistance;
      }
    }

Runtime: 4 ms, beating 32.42% of leetcode users solutions using java.
Memory: 41.35 mb, beating 13.97% of leetcode users solutions using java.

#### Concepts Applied:

For loops, if statement, charAt, and Math.

### Solution Jan 1, 2024 (Java, leetcode) 455. Assign Cookies (Easy)
In .LeetcodeDailySolution folder as Jan1,2024.java

#### Prompt:

Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.

#### Solution:

    class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);

        int i = 0;

        for(int j=0;i<g.length && j<s.length;j++)
	        if(g[i]<=s[j]) i++;
            
        return i;
      }
    }

Runtime: 8 ms, beating 98.87% of leetcode users solutions using java.
Memory: 44.91 mb, beating 28.82% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, and for loop.

### Solution Jan 2, 2024 (Java, leetcode) 2610. Convert an Array Into a 2D Array (Medium)
In .LeetcodeDailySolution folder as Jan2,2024.java

#### Prompt:

You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:

The 2D array should contain only the elements of the array nums.
Each row in the 2D array contains distinct integers.
The number of rows in the 2D array should be minimal.
Return the resulting array. If there are multiple answers, return any of them.

Note that the 2D array can have a different number of elements on each row.

#### Solution:

    class Solution {
    public List<List<Integer>> findMatrix(int[] nums) {
    int n = nums.length;

    Arrays.sort(nums);

    List<List<Integer>> ans = new ArrayList<>();
    int k = 0;

    for(int i = 0; i < n; i++){
        if(ans.size() <= k) ans.add(new ArrayList<>());
        ans.get(k).add(nums[i]);
        if(i+1 < n && nums[i] != nums[i+1])  k=0;
        else k++;
        }
    return ans;
      }
    }

Runtime: 4 ms, beating 55.24% of leetcode users solution using java.
Memory: 45.13 mb, beating 10.26% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, List, ArrayList, matrix, for loop, if statements, and else statement.

### Solution Jan 3, 2024 (Java, leetcode) 2125. Number of Laser Beams in a Bank (Medium)
In .LeetcodeDailySolution folder as Jan3,2024.java

#### Prompt:

Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.

There is one laser beam between any two security devices if both conditions are met:

The two devices are located on two different rows: r1 and r2, where r1 < r2.
For each row i where r1 < i < r2, there are no security devices in the ith row.
Laser beams are independent, i.e., one beam does not interfere nor join with another.

Return the total number of laser beams in the bank.

#### Solution: 

    class Solution {
    public int numberOfBeams(String[] bank) {

        if (bank.length < 2) {
            return 0;
        }
        int solution = 0;
        int beaconsInPrevRow = 0;
        int beaconsInCurrentRow = 0;

        for (String row : bank) {
            beaconsInCurrentRow = 0;

            for (char c : row.toCharArray()) {
                if (c == '1') {
                    beaconsInCurrentRow++;
                }
            }
            solution += beaconsInCurrentRow * beaconsInPrevRow;
            beaconsInPrevRow = beaconsInCurrentRow == 0 ? beaconsInPrevRow : beaconsInCurrentRow;
        }
        return solution;
      }
    }

Runtime: 11 ms, beating 91.49% of leetcode users solutions using java.
Memory: 44.89 mb, beating 33.27% of leetcode users solutions using java.

#### Concepts Applied:

If statements, for loops, strings, matrix, and charArray.

## Made a switch to C++ for all future solutions

### Solution Jan 4, 2024 (C++, leetcode) 2870. Minimum Number of Operations to Make Array Empty (Medium)
In .LeetcodeDailySolution folder as Jan4,2024.cpp

#### Prompt:

You are given a 0-indexed array nums consisting of positive integers.

There are two types of operations that you can apply on the array any number of times:

Choose two elements with equal values and delete them from the array.
Choose three elements with equal values and delete them from the array.
Return the minimum number of operations required to make the array empty, or -1 if it is not possible.

#### Solution:

    class Solution {
    public:
    int minOperations(vector<int>& nums) {
        int ans = 0;

        unordered_map<int, int> freq;
        for(auto n: nums) freq[n]++;
        for(auto [k,f]: freq){
            if(f == 1) return -1;
            ans += f/3 + (f%3 + 1)/2;
        }
        return ans;
      }
    };

Runtime: 122 ms, beating 56.03% of leetcode users solutions using C++.
Memory: 85.06 mb, beating 89.98% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays (vector), unordered map, for loops, and if statement.

### Solution Jan 5, 2024 (C++, leetcode) 300. Longest Increasing Subsequence (Medium)
In .LeetcodeDailySolution folder as Jan5,2024.cpp

#### Prompt:

Given an integer array nums, return the length of the longest strictly increasing 
subsequence.

#### Solution:

    class Solution {
    public:
    int lengthOfLIS(std::vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        int n = nums.size();
        std::vector<int> dp(n, 1);

        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    dp[i] = std::max(dp[i], dp[j] + 1);
                }
            }
        }
        return *std::max_element(dp.begin(), dp.end());
      }
    };

Runtime: 243 ms, beating 52.49% of leetcode users solutions C++.
Memory: 10.87 mb, beating 62.25% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, if statements, dynamic programming, and for loops.

### Solution Jan 6, 2024 (C++, leetcode) 1235. Maximum Profit in Job Scheduling (Hard)
In .LeetcodeDailySolution folder as Jan6,2024.cpp

#### Prompt:

We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].

You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time X you will be able to start another job that starts at time X.

#### Solution:

    class Solution {
    public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        const int n = startTime.size();

        vector<vector<int>> jobs(n);

        for (int i = 0; i < n; i++) jobs[i] = {endTime[i], startTime[i], profit[i]};
        sort(jobs.begin(), jobs.end());

        map<int, int> dp = {{0, 0}};
        
        for (auto& job : jobs) {
            int profit = prev(dp.upper_bound(job[1]))->second + job[2];
            if (profit > dp.rbegin()->second) dp[job[0]] = profit;
        }
        return dp.rbegin()->second;
      }
    };

Runtime: 187 ms, beating 58.92% of leetcode users solutions using C++.
Memory: 75.94 mb, beating 57.04% of leetcode users solutions using C++.

#### Concepts Applied:

Hash table, dynamic programming, for loops, sorting, map, and if statement.

### Solution Jan 7, 2024 (C++, leetcode) 446. Arithmetic Slices II - Subsequence (Hard)
In .LeetcodeDailySolution folder as Jan7,2024.cpp

#### Prompt:

Given an integer array nums, return the number of all the arithmetic subsequences of nums.

A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.
For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.
A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.

For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].
The test cases are generated so that the answer fits in 32-bit integer.

#### Solution:

    class Solution {
    public:
    int numberOfArithmeticSlices(std::vector<int>& nums) {
        int n = nums.size();
        int total_count = 0;

        std::vector<std::unordered_map<int, int>> dp(n);

        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {

                long long diff = static_cast<long long>(nums[i]) - nums[j]; 

                if (diff > INT_MAX || diff < INT_MIN)
                    continue; 

                int diff_int = static_cast<int>(diff);

                dp[i][diff_int] += 1; 

                if (dp[j].count(diff_int)) {
                    dp[i][diff_int] += dp[j][diff_int];
                    total_count += dp[j][diff_int];
                }
            }
        }
        return total_count;
      }
    };

Runtime: 411 ms, beating 75.28% of leetcode users solutions using C++.
Memory: 109.88 mb, beating 73.33% of leetcode users solutions using C++.

#### Concepts Applied:

Vector, unordered map, for loops, if statements, and dynamic programming.

### Solution Jan 8, 2024 (C++, leetcode) 938. Range Sum of BST (Easy)
In .LeetcodeDailySolution folder as Jan8,2024.cpp

#### Prompt:

Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].

#### Solution:

    class Solution {
    public:
    int rangeSumBST(TreeNode* root, int low, int high) {

        if (!root) {
            return 0;
        }
        int currentVal = (root->val >= low && root->val <= high) ? root->val : 0;
        int leftSum = rangeSumBST(root->left, low, high);
        int rightSum = rangeSumBST(root->right, low, high);

        return currentVal + leftSum + rightSum;
      }
    };

Runtime: 92 ms, beating 79.17% of leetcode users solutions using C++.
Memory: 64.95 mb, beating 51.83% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search tree, tree, binary tree, and depth-first-search.

### Solution Jan 9, 2024 (C++, leetcode) 872. Leaf-Similar Trees (Easy)
In .LeetcodeDailySolution folder as Jan9,2024.cpp

#### Prompt:

Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/44e59039-7152-4bac-a956-623595860368)

For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).

Two binary trees are considered leaf-similar if their leaf value sequence is the same.

Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.

#### Solution:

    class Solution {
    public:
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {

        function<void(TreeNode*, vector<int>&)> collectLeafValues =
            [&](TreeNode* root, vector<int>& leafValues) {

                if (!root) {
                    return;
                }
                if (!root->left && !root->right) {
                    leafValues.push_back(root->val);
                }
                collectLeafValues(root->left, leafValues);
                collectLeafValues(root->right, leafValues);
            };
        vector<int> leafValues1, leafValues2;

        collectLeafValues(root1, leafValues1);
        collectLeafValues(root2, leafValues2);

        return leafValues1 == leafValues2;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.91 mb, beating 8.99% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, Depth-First-Search, and binary tree.

### Solution Jan 10, 2024 (C++, leetcode) 2385. Amount of Time for Binary Tree to Be Infected (Medium)
In .LeetcodeDailySolution folder as Jan10,2024.cpp

#### Prompt:

You are given the root of a binary tree with unique values, and an integer start. At minute 0, an infection starts from the node with value start.

Each minute, a node becomes infected if:

The node is currently uninfected.
The node is adjacent to an infected node.
Return the number of minutes needed for the entire tree to be infected.

#### Solution:

    class Solution {
    public:
    int result;
    int amountOfTime(TreeNode* root, int start) {
        DFS(root, start);
        return result;
    }
    int DFS(TreeNode* node, int start){
        if(node == NULL) return 0;

        int leftDepth = DFS(node->left, start);
        int rightDepth = DFS(node->right, start);

        if(node->val == start){
            result = std::max(leftDepth, rightDepth);
            return -1;
        }
        else if(leftDepth >= 0 && rightDepth >= 0)
            return std::max(leftDepth, rightDepth)+1;
        
        result = std::max(result, std::abs(leftDepth - rightDepth));
        
        return std::min(leftDepth, rightDepth) - 1;
      }
    };

Runtime: 136 ms, beating 93.33% of leetcode users solutions using C++.
Memory: 90.57 mb, beating 99.40% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, Depth-First-Search, Breadth-First-Search, and binary tree.

### Solution Jan 11, 2024 (C++, leetcode) 1026. Maximum Difference Between Node and Ancestor (Medium)
In .LeetcodeDailySolution folder as Jan11,2024.cpp

#### Prompt:

Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.

A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.

#### Solution:

    class Solution {
    public:
    int maxAncestorDiff(TreeNode* root) {
        if (!root)
            return 0;

        int minVal = root->val, maxVal = root->val;

        differ(root, minVal, maxVal);

        return diff;
    }
    public:
    int diff = 0;
    void differ(TreeNode* root, int minVal, int maxVal) {
        if (!root)
            return;

        diff = max(diff, max(abs(minVal - root->val), abs(maxVal - root->val)));
        minVal = min(minVal, root->val);
        maxVal = max(maxVal, root->val);
        differ(root->left, minVal, maxVal);
        differ(root->right, minVal, maxVal);
      }
    };

Runtime: 3 ms, beating 85.85% of leetcode users solutions using C++.
Memory: 10.07 mb, beating 79.90% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, Depth-First Search, binary tree, and recursion.

### Solution Jan 12, 2024 (C++, leetcode) 1704. Determine in String Halves Are Alike (Easy)
In .LeetcodeDailySolution folder as Jan12,2024.cpp

#### Prompt:

You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.

Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters.

Return true if a and b are alike. Otherwise, return false.

#### Solution:

    class Solution {
    public:
    bool vow(char c){
        c=tolower(c);

        return (c=='a'||c=='e'||c=='i'||c=='o'||c=='u');
    }
    bool halvesAreAlike(string s) {

        int x=0,n=s.size();
        
        for(int i=0;i<n/2;i++){
            if(vow(s[i])) x++;
            if(vow(s[n-i-1])) x--;
        }
        return x==0;
      }
    };

Runtime: 2 ms, beating 64.10% of leetcode users solutions using C++.
Memory: 6.98 mb, beating 73.08% of leetcode ysers solutions using C++.

#### Concepts Applied:

Bool, char, unordered set, for loop, and if statement.

### Solution Jan 13, 2024 (C++, leetcode) 1347. Minimum Number of Steps to Make Two Strings Anagram (Medium)
In .LeetcodeDailySolution folder as Jan13,2024.cpp

#### Prompt:

You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character.

Return the minimum number of steps to make t an anagram of s.

An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.

#### Solution:

    class Solution {
    public:
    int minSteps(string s, string t) {

        vector<int> m1(26, 0), m2(26, 0);

        for(auto c : s) m1[c-'a']++;
        for(auto c : t) m2[c-'a']++;

        int ans = 0;
        
        for(int i = 0;i < 26;i++){
            if(m1[i] > m2[i]) ans += m1[i] - m2[i]; 
        }
        return ans;
      }
    };

Runtime: 50 ms, beating 73.78% of leetcode users solutions using C++.
Memory: 16.86 mb, beating 82.35% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, counting, vector, for loop, and if statement. 

### Solution Jan 14, 2024 (C++, leetcode) 1657. Determine if Two Strings Are Close (Medium)
In .LeetcodeDailySolution folder as Jan14,2024.cpp

#### Prompt:

Two strings are considered close if you can attain one from the other using the following operations:

Operation 1: Swap any two existing characters.
For example, abcde -> aecdb
Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.
For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)
You can use the operations on either string as many times as necessary.

Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.

#### Solution:

    class Solution {
    public:
    bool closeStrings(std::string word1, std::string word2) {
        std::array<int, 26> charCount1 = {}; 
        std::array<int, 26> charCount2 = {}; 

        for (char c : word1) {
            ++charCount1[c - 'a'];
        }
        for (char c : word2) {
            ++charCount2[c - 'a'];
        }
        for (int i = 0; i < 26; ++i) {

            bool charPresentWord1 = charCount1[i] > 0;
            bool charPresentWord2 = charCount2[i] > 0;
            
            if ((charPresentWord1 && !charPresentWord2) || (!charPresentWord1 && charPresentWord2)) {
                return false;

            }
        }
        std::sort(charCount1.begin(), charCount1.end());
        std::sort(charCount2.begin(), charCount2.end());

        for (int i = 0; i < 26; ++i) {
            if (charCount1[i] != charCount2[i]) {
                return false;
            }
        }
        return true;
      }
    };

Runtime: 58 ms, beating 97.53% of leetcode users solutions using C++.
Memory: 20.70 mb, beating 99.17% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, arrays, counting, sorting, for loops, and if statements.

### Solution Jan 15, 2024 (C++, leetcode) 2225. Find Players With Zero or One Losses (Medium)
In .LeetcodeDailySolution folder as Jan15,2024.cpp

#### Prompt:

You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.

Return a list answer of size 2 where:

answer[0] is a list of all players that have not lost any matches.
answer[1] is a list of all players that have lost exactly one match.
The values in the two lists should be returned in increasing order.

Note:

You should only consider the players that have played at least one match.
The testcases will be generated such that no two matches will have the same outcome.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        
        map<int,int>mp;

        for(int i=0;i<matches.size();i++){
            mp[matches[i][0]]+=0;
            mp[matches[i][1]]++;
        }

        vector<vector<int>>ans(2);

        for(auto a: mp){
            if(a.second==0)ans[0].push_back(a.first);
            if(a.second==1)ans[1].push_back(a.first);
        }
        return ans;
      }
    };

Runtime: 504 ms, beating 64.31% of leetcode users solutions using C++.
Memory: 162.93 mb, beating 86.78% of leetcode users solutions using C++.

#### Concepts Applied:

Sets, vectors, for loops, and if statements.

### Solution Jan 16, 2024 (C++, leetcode) 380. Insert Delete GetRandom O(1) (Medium)
In .LeetcodeDailySolution folder as Jan16,2024.cpp

#### Prompt:

Implement the RandomizedSet class:

RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
You must implement the functions of the class such that each function works in average O(1) time complexity.

#### Solution:

    class RandomizedSet {
    unordered_set<int> s;
    public:
    RandomizedSet() {
    }
    bool insert(int val) {
        auto a = s.insert(val);
        return a.second;
    }
    bool remove(int val) {
        auto b = s.erase(val);
        return b;
    }
    int getRandom() {
        return *next(s.begin(),rand()%s.size());
	}
    };

Runtime: 192 ms, beating 33.78% of leetcode users solutions using C++.
Memory: 97.20 mb, beating 90.76% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered set, bools, and randomization.

### Solution Jan 17, 2024 (C++, leetcode) 1207. Unique Number of Occurences (Easy)
In .LeetcodeDailySolution folder as Jan17,2024.cpp

#### Prompt:

Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.

#### Solution:

    class Solution {
    public:
    bool uniqueOccurrences(vector<int>& arr) {

        map<int, int> mp;

        for(auto i : arr) mp[i]++;
        set<int> s;

        for(auto [n, f] :mp) s.insert(f);

        return mp.size() == s.size();
      }
    };

Runtime: 2 ms, beating 65.75% of leetcode users solutions using C++.
Memory: 8.68 mb, beating 41.35% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, hashing, set, for loops, and comparison.

### Solution Jan 18, 2024 (C++, leetcode) 70. Climbing Stairs (Easy)
In .LeetcodeDailySolution folder as Jan18,2024.cpp

#### Prompt:

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

#### Solution:

    class Solution {
    public:
    int climbStairs(int n) {

        long long int prv1 = 1;
        long long int prv2 = 1;

        for(int i = 0; i < n; i++){
            long long int tmp = prv1;
            prv1 = prv1 + prv2;
            prv2 = tmp;
        }
        return prv2;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 6.34 mb, beating 71.74% of leetcode users solutions using C++.

#### Concepts Applied:

Simple counting of steps.

### Solution Jan 19, 2024 (C++, leetcode) 931. Minimum Falling Path Sum (Medium)
In .LeetcodeDailySolution folder as Jan19,2024.cpp

#### Prompt:

Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.

A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).

#### Solution:

    class Solution {
    public:
    int minFallingPathSum(vector<vector<int>>& matrix) {       
        int n=matrix.size();
        int m=matrix[0].size();

        vector<vector<int>>dp(n,vector<int>(m,0));
        
        for(int j=0;j<m;j++){
            dp[0][j]=matrix[0][j];    
        }
        for(int i=1;i<n;i++){
            for(int j=0;j<m;j++){
                int ld=1e9,rd=1e9;
                int up=matrix[i][j] + dp[i-1][j];
                if(j-1>=0)
                    ld=matrix[i][j] + dp[i-1][j-1];
                if(j+1<m)
                    rd=matrix[i][j] + dp[i-1][j+1];
                dp[i][j] = min(up,min(ld,rd));   
            }
        }
        int mini=dp[n-1][0];
        
        for(int j=1;j<m;j++){
            mini=min(mini,dp[n-1][j]);
        }
        return mini; 
    }};

Runtime: 11 ms, beating 80.62% of leetcode users solutions using C++.
Memory: 13.08 mb, beating 5.08% of leetcode users solutions using C++.

#### Concepts Applied:

Dynamic programming, matrix, arrays, for loops, and if statements.

### Solution Jan 20, 2024 (C++, leetcode) 907. Sum of Subarray Minimums (Medium)
In .LeetcodeDailySolution folder as Jan20,2024.cpp

#### Prompt:

Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    int sumSubarrayMins(vector<int>& arr) {
        const int MOD = 1000000007;
        stack<int> st;
        long sumOfMinimums = 0;

        for (int i = 0; i <= arr.size(); i++) {
            while (!st.empty() && (i == arr.size() || arr[st.top()] >= arr[i])) {
                int mid = st.top();

                st.pop();
                
                int leftBoundary = st.empty() ? -1 : st.top();
                int rightBoundary = i;

                long count = (mid - leftBoundary) * (rightBoundary - mid) % MOD;

                sumOfMinimums += (count * arr[mid]) % MOD;
                sumOfMinimums %= MOD;
            }
            st.push(i);
        }
        return static_cast<int>(sumOfMinimums);
      }
    };

Runtime: 55 ms, beating 97.94% of leetcode users solutions using C++.
Memory: 41.76 mb, beating 80.15% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, subarray, modulo, stacks, for loop, and while loop. 

### Solution Jan 21, 2024 (C++, leetcode) 198. House Robber (Medium)
In .LeetcodeDailySolution folder as Jan21,2024.cpp

#### Prompt:

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.

#### Solution:

    class Solution {
    public: 
    int rob(vector<int>& nums) {
        int n = nums.size(), pre = 0, cur = 0;

        for (int i = 0; i < n; i++) {
            int temp = max(pre + nums[i], cur);
            
            pre = cur;
            cur = temp;
        }
        return cur;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.99 mb, beating 5.08% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, (dynamic programming with variables).

### Solution Jan 22, 2024 (C++, leetcode) 645. Set Mismatch (Easy)
In .LeetcodeDailySolution folder as Jan22,2024.cpp

#### Prompt:

You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.

You are given an integer array nums representing the data status of this set after the error.

Find the number that occurs twice and the number that is missing and return them in the form of an array.

#### Solution:

    class Solution {
    public:
    vector<int> findErrorNums(vector<int>& nums) {
        int n = nums.size();
        int sum = (n * (n + 1))/2;
        long long sqr_sum = 0;

        for(int i = 1; i <= n; i++) sqr_sum += i * i;
        int arr_sum = 0;
        long long arr_sqr_sum = 0;

        for(int i = 0; i < n; i++){
            arr_sum += nums[i];
            arr_sqr_sum += (nums[i] * nums[i]);
        }
        int sum_diff = arr_sum - sum;
        int sqr_sum_diff = arr_sqr_sum - sqr_sum;
        int missing = (sqr_sum_diff - (sum_diff * sum_diff)) / (2 * sum_diff);
        int duplicate = sum_diff + (missing);

        return {duplicate , missing};
      }
    };

Runtime: 18 ms, beating 92.06% of leetcode users solutions using C++.
Memory: 23.90 mb, beating 36.42% of leetcode users solutions using C++.

#### Concepts Applied:

For loops, and mathematics.

### Solution Jan 23, 2024 (C++, leetcode) 1239. Maximum Length of a Conactenated String with Unique Characters (Medium)
In .LeetcodeDailySolution folder as Jan23,2024.cpp

#### Prompt:

You are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters.

Return the maximum possible length of s.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

#### Solution:

    class Solution {
    public:
    int maxLength(vector<string>& arr) {
        vector<int> dp = {0};
        int res = 0;
        
        for (const string& s : arr) {
            int a = 0, dup = 0;
            for (char c : s) {
                dup |= a & (1 << (c - 'a'));
                a |= 1 << (c - 'a');
            }
            if (dup > 0)
                continue;
            for (int i = dp.size() - 1; i >= 0; i--) {
                if ((dp[i] & a) > 0)
                    continue;

                dp.push_back(dp[i] | a);
                res = max(res, __builtin_popcount(dp[i] | a));
            }
        }
        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.40 mb, beating 78.50% of leetcode users solutions using C++.

#### Concepts Applied:

Bit manipulation, array, for loops, if statement, and dynamic programming.

### Solution Jan 24, 2024 (C++, leetcode) 1457. Pseudo-Palindromic Paths in a Binary Tree (Medium)
In .LeetcodeDailySolution folder as Jan24,2024.cpp

#### Prompt:

Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.

Return the number of pseudo-palindromic paths going from the root node to leaf nodes.

#### Solution:

    class Solution {
    public:
    int pseudoPalindromicPaths(TreeNode* root) {
        return countPseudoPalindromicPaths(root, 0);
    }
    private:
    int countPseudoPalindromicPaths(TreeNode* node, int path) {
        if (!node) {
            return 0;
        }
        path ^= (1 << node->val);

        if (!node->left && !node->right) {
            return (path & (path - 1)) == 0 ? 1 : 0;
        }
        return countPseudoPalindromicPaths(node->left, path) + countPseudoPalindromicPaths(node->right, path);
      }
    };

Runtime: 247 ms, beating 88.57% of leetcode users solutions using C++.
Memory: 176.94 mb, beating 99.43% of leetcode users solutions using C++.

#### Concepts Applied:

Recursion, depth-first search, bit manipulation, tree, binary tree, and if statements.

### Solution Jan 25, 2024 (C++, leetcode) 1143. Longest Common Subsequence (Medium)
In .LeetcodeDailySolution folder as Jan25,2024.cpp

#### Prompt:

Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".
A common subsequence of two strings is a subsequence that is common to both strings.

#### Solution:

    class Solution {
    public:
    int longestCommonSubsequence(string text1, string text2) {
        if (text1.length() < text2.length()) {
            return LCS(text1, text2);
        }
        return LCS(text2, text1);
    }
    int LCS(string s1, string s2) {
        vector<vector<int>> M(2, vector<int>(s1.length() + 1, 0));

        for (int i = 1; i <= s2.length(); i++) {
            M[i % 2][0] = 0;
            for (int j = 1; j <= s1.length(); j++) {
                if (s1[j - 1] == s2[i - 1]) {
                    M[i % 2][j] = M[(i - 1) % 2][j - 1] + 1;
                } else {
                    M[i % 2][j] = max(M[(i - 1) % 2][j - 1],
                                max(M[(i - 1) % 2][j], M[i % 2][j - 1]));
                }
            }
        }
        return M[s2.length() % 2][s1.length()];
      }
    };

Runtime: 19 ms, beating 92.26% of leetcode users solutions using C++.
Memory: 7.70 mb, beating 88.11% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, dynamic programming, if statements, and else statements.

### Solution Jan 26, 2024 (C++, leetcode) 576. Out of Boundary Paths (Medium)
In .LeetcodeDailySolution folder as Jan26,2024.cpp

#### Prompt:

There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball.

Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    int M=1e9+7;
    vector<vector<vector<int>>> dp;
    int solve(int n, int m, int maxMove, int startRow, int startColumn){

        if(startColumn<0 || startColumn>=n || startRow<0 || startRow>=m) return 1;
        if(maxMove == 0) return 0;
        if(dp[startRow][startColumn][maxMove] != -1) return dp[startRow][startColumn][maxMove];

        int up = solve(n, m, maxMove-1, startRow-1, startColumn);
        int down = solve(n, m, maxMove-1, startRow+1, startColumn);
        int left = solve(n, m, maxMove-1, startRow, startColumn-1);
        int right = solve(n, m, maxMove-1, startRow, startColumn+1);

        return dp[startRow][startColumn][maxMove] = ((up+down)%M + (left+right)%M)%M;
    }
    int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        dp = vector<vector<vector<int>>>(m, vector<vector<int>>(n, vector<int>(maxMove+1, -1)));
        return solve(n, m, maxMove, startRow, startColumn);
      }
    };

Runtime: 6 ms, beating 67.66% of leetcode users solutions using C++.
Memory: 10.36 mb, beating 24.21% of leetcode users solutions using C++.

#### Concepts Applied:

Modulo, recursion, memoization, array, dynamic programming, and if statements.

### Solution Jan 27, 2024 (C++, leetcode) 629. K Inverse Pairs Array (Hard)
In .LeetcodeDailySolution folder as Jan27,2024.cpp

#### Prompt:

For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.length and nums[i] > nums[j].

Given two integers n and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    int kInversePairs(int n, int k) {
        int MOD = 1000000007;

        vector<int> dp(k + 1);

        dp[0] = 1;
        
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                dp[j] = (dp[j] + dp[j - 1]) % MOD;
            }
            for (int j = k; j >= i; j--) {
                dp[j] = (dp[j] - dp[j - i] + MOD) % MOD;
            }
        }
        return dp[k];
      }
    };

Runtime: 6 ms, beating 87.57% of leetcode users solutions using C++.
Memory: 7.43 mb, beating 89.73% of leetcode users solutions using C++.

#### Concepts Applied:

Modulo, array, dynamic programming, and for loops.

### Solution Jan 28, 2024 (C++, leetcode) 1074. Number of Submatrices That Sum to Target (Hard)
In .LeetcodeDailySolution folder as Jan28,2024.cpp

#### Prompt:

Given a matrix and a target, return the number of non-empty submatrices that sum to target.

A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2.

Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.

#### Solution:

    class Solution {
    public:
    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size(), res = 0;

        for (int l = 0; l < n; ++l) {
            int sums[105] = {0};

            for (int r = l; r < n; ++r) {
                for (int i = 0; i < m; ++i) {
                    sums[i] += matrix[i][r];
                }
                for (int i = 0; i < m; ++i) {
                    int sum = 0;

                    for (int j = i; j < m; ++j) {
                        sum += sums[j];

                        if (sum == target) {
                            ++res;
                        }
                    }
                }
            }
        }
        return res;
      }
    };

Runtime: 102 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.46 mb, beating 87.16% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, matrices, for loops, and if statement.

### Solution Jan 29, 2024 (C++, leetcode) 232. Implement Queue using Stacks (Easy)
In .LeetcodeDailySolution folder as Jan29,2024.cpp

#### Prompt:

Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).

Implement the MyQueue class:

void push(int x) Pushes element x to the back of the queue.
int pop() Removes the element from the front of the queue and returns it.
int peek() Returns the element at the front of the queue.
boolean empty() Returns true if the queue is empty, false otherwise.
Notes:

You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.

#### Solution:

    class MyQueue {
    public:
    stack<int> input;
    stack<int> output;

    MyQueue() {
    }
    void push(int x) {
        input.push(x);
        }
    int pop() {
        if(!output.empty()){
            int e =  output.top();
            output.pop();
            return e;
        }
        else{
            while(!input.empty()){
                int e = input.top();
                input.pop();
                output.push(e);
            }
            int e =  output.top();
            output.pop();
            return e;
        }
    }
    int peek() {
        if(!output.empty()){
            return output.top();
        }
        else{
            while(!input.empty()){
                int ele = input.top();
                input.pop();
                output.push(ele);
            }
            return output.top();
        }
    }
    bool empty() {
        if(input.empty() and output.empty()) return true;
        else return false;
        }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.25 mb, beating 16.98% of leetcode users solutions using C++.

#### Concepts Applied:

Stacks, queues, while loops, if statements, and else statements.

### Solution Jan 30, 2024 (C++, leetcode) 150. Evaluate Reverse Polish Notation (Medium)
In .LeetcodeDailySolution folder as Jan30,2024.cpp

#### Prompt:

You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.

Evaluate the expression. Return an integer that represents the value of the expression.

Note that:

The valid operators are '+', '-', '*', and '/'.
Each operand may be an integer or another expression.
The division between two integers always truncates toward zero.
There will not be any division by zero.
The input represents a valid arithmetic expression in a reverse polish notation.
The answer and all the intermediate calculations can be represented in a 32-bit integer.

#### Solution:

    #include <bits/stdc++.h>

    class Solution {
    public:
    int evalRPN(vector<string>& tokens) {
        stack<int> numbers;

        for (const string& token : tokens) {
            if (token.size() > 1 || isdigit(token[0])) {
                numbers.push(stoi(token));
            } else { 
                int operand2 = numbers.top();
                numbers.pop();

                int operand1 = numbers.top();
                numbers.pop();

                switch (token[0]) {
                    case '+': 
                        numbers.push(operand1 + operand2);
                        break;
                    case '-': 
                        numbers.push(operand1 - operand2);
                        break;
                    case '*': 
                        numbers.push(operand1 * operand2);
                        break;
                    case '/': 
                        numbers.push(operand1 / operand2);
                        break;
                }                
            }
        }
        return numbers.top();
      }
    };

Runtime: 8 ms, beating 70.52% of leetcode users solutions using C++.
Memory: 15.44 mb, beating 10.51% of leetcode users solutions using C++.

#### Concepts Applied:

Stacks, for loop, if statement, else statement, switch, and mathematical operations.

### Solution Jan 31, 2024 (C++, leetcode) 739. Daily Temperatures (Medium)
In .LeetcodeDailySolution folder as Jan31,2024.cpp

#### Prompt:

Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.

#### Solution:

    class Solution {
    public:
    std::vector<int> dailyTemperatures(std::vector<int>& temps) {
        std::vector<int> results(temps.size());
        std::stack<int> stack;

        for (int i = 0; i < temps.size(); i++) {
            while (!stack.empty() && temps[stack.top()] < temps[i]) {
                results[stack.top()] = i - stack.top();
                stack.pop();
            }
            stack.push(i);
        }
        return results;
      }
    };

Runtime: 133 ms, beating 72.67% of leetcode users solutions using C++.
Memory: 105.44 mb, beating 25.93% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, stacks, for loop, and while loop.

### Solution Feb 1, 2024 (C++, leetcode) 2966. Divide Array Into Arrays With Max Difference (Medium)
In .LeetcodeDailySolution folder as Feb1,2024.cpp

#### Prompt:

You are given an integer array nums of size n and a positive integer k.

Divide the array into one or more arrays of size 3 satisfying the following conditions:

Each element of nums should be in exactly one array.
The difference between any two elements in one array is less than or equal to k.
Return a 2D array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> divideArray(vector<int>& nums, int k) {
        vector<vector<int>> res;

        sort(nums.begin(), nums.end());
        
        for(int i = 2; i < nums.size(); i += 3){
            if(nums[i] - nums[i - 2] > k) return {};
            res.push_back({nums[i-2], nums[i-1], nums[i]});
        }
        return res;
      }
    };

Runtime: 132 ms, beating 98.28% of leetcode users solutions using C++.
Memory: 119.69 mb, beating 39.01% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, for loop, and if statement. 

### Solution Feb 2, 2024 (C++, leetcode) 1291. Sequential Digits (Medium)
In .LeetcodeDailySolution folder as Feb2,2024.cpp

#### Prompt:

An integer has sequential digits if and only if each digit in the number is one more than the previous digit.

Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.

#### Solution:

    class Solution {
    public:
    vector<int> result;
    void solve(int low , int high,int i , int ans){
    
    if(ans >= low && ans <= high){
        result.push_back(ans);
    }
    if(ans > high || i>9){
        return;
    }
    solve(low,high,i+1, ans*10+i);
    }
    vector<int> sequentialDigits(int low, int high) {
        
        for(int i =1 ;i<10;i++){
            solve(low,high,i,0); 
        }
        sort(result.begin(),result.end());

        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.62 mb, beating 8.68% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, if statements, for loop, and sorting.

### Solution Feb 3, 2024 (C++, leetcode) 1043. Partition Array for Maximum Sum (Medium)
In .LeetcodeDailySolution folder as Feb3,2024.cpp

#### Prompt:

Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray.

Return the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer.

#### Solution:

    #include <bits/stdc++.h>

    class Solution {
    public:
    int maxSumAfterPartitioning(std::vector<int>& arr, int k) {
        int n = arr.size();

        std::vector<int> dp(n + 1, 0);

        for (int i = 0; i < n; i++) {
            int curMax = 0, curSum = 0;

            for (int j = i; j >= std::max(0, i - k + 1); j--) {
                curMax = std::max(curMax, arr[j]);

                int cur = curMax * (i - j + 1) + dp[j];

                curSum = std::max(curSum, cur);
            }
           dp[i + 1] = curSum;
        }
        return dp[n];
      }
    };

Runtime: 6 ms, beating 94.83% of leetcode users solutions using C++.
Memory: 10.93 mb, beating 15.42% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, dynamic programming, and for loops.

### Solution Feb 4, 2024 (C++, leetcode) 76. Minimum Window Substring (Hard)
In .LeetcodeDailySolution folder as Feb4,2024.cpp

#### Prompt:

Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. 
If there is no such substring, return the empty string "".

The testcases will be generated such that the answer is unique.

#### Solution:

    class Solution {
    public:
    std::string minWindow(std::string s, std::string t) {

        if (s.empty() || t.empty() || s.length() < t.length()) {
            return "";
        }
        std::vector<int> map(128, 0);
        int count = t.length();
        int start = 0, end = 0, minLen = INT_MAX, startIndex = 0;

        for (char c : t) {
            map[c]++;
        }
        while (end < s.length()) {
            if (map[s[end++]]-- > 0) {
                count--;
            }
            while (count == 0) {
                if (end - start < minLen) {
                    startIndex = start;
                    minLen = end - start;
                }
                if (map[s[start++]]++ == 0) {
                    count++;
                }
            }
        }
        return minLen == INT_MAX ? "" : s.substr(startIndex, minLen);
      }
    };

Runtime: 4 ms, beating 91.16% of leetcode users solutions using C++.
Memory: 9.28 mb, beating 22.77% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sliding window, if statements, for loop, and while loops. 

### Solution Feb 5, 2024 (C++, leetcode) 387. First Unique Character in a String (Easy)
In .LeetcodeDailySolution folder as Feb5,2024.cpp

#### Prompt:

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.

#### Solution:

    class Solution {
    public:
    int firstUniqChar(string& s) {
        int position[26] = {0};

        for(int i = 1; i<=s.size(); i++){
            char c = s[i-1]-'a';

            if(position[c] == 0){
                position[c] = -i;
            }
            else{
                position[c] = i; 
            }
        }
        int minPosition = INT_MAX;

        for(int i=0;i<26;i++){
            if(position[i] < 0)
                minPosition = min(minPosition, -position[i]);
        }
        return minPosition == INT_MAX ? -1 : minPosition - 1;
      }
    };
	auto init = [](){ 
 	   return 'c';
	}();

Runtime: 14 ms, beating 98.04% of leetcode users solutions using C++.
Memory: 10.90 mb, beating 96.77% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loops, if statements, and else statement.

### Solution Feb 6, 2024 (C++, leetcode) 49. Group Anagrams (Medium)
In .LeetcodeDailySolution folder as Feb6,2024.cpp

#### Prompt:

Given an array of strings strs, group the anagrams together. You can return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

#### Solution:

    class Solution {
    public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {

        vector<vector<string>> ans;                 

        unordered_map<string, vector<string>> mp;         
        
        for(int i = 0; i < strs.size(); i++) {           
            string s = strs[i];                         
            sort(strs[i].begin(), strs[i].end());      
            mp[strs[i]].push_back(s);                 
        }
        for(auto i : mp)                          
            ans.push_back(i.second);
        
        return ans;     
      }
    };

Runtime: 23 ms, beating 89.73% of leetcode users solutions using C++.
Memory: 24.31 mb, beating 26.31% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, strings, unordered map, sorting, and for loops.

### Solution Feb 7, 2024 (C++, leetcode) 451. Sort Characters By Frequency (Medium)
In .LeetcodeDailySolution folder as Feb7,2024.cpp

#### Prompt:

Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.

Return the sorted string. If there are multiple answers, return any of them.

#### Solution:

    #include <bits/stdc++.h>

    class Solution {
    public:
    string frequencySort(string s) {

        unordered_map<char, int> charCount;

        for (char c : s) {
            charCount[c]++;
        }
        vector<char> sortedChars;

        for (const auto& entry : charCount) {
            sortedChars.push_back(entry.first);
        }
        sort(sortedChars.begin(), sortedChars.end(), [&](char a, char b) {
            return charCount[a] > charCount[b];
        });
        string result;

        for (char c : sortedChars) {
            result += string(charCount[c], c);
        }
        return result;
      }
    };

Runtime: 6 ms, beating 95.18% of leetcode users solutions using C++.
Memory: 11 mb, beating 15.79% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered map, for loops, char array, sorting, and strings.

### Solution Feb 8, 2024 (C++, leetcode) 279. Perfect Squares (Medium)
In .LeetcodeDailySolution folder as Feb8,2024.cpp

#### Prompt:

Given an integer n, return the least number of perfect square numbers that sum to n.

A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.

#### Solution:

    class Solution {
    public:
    int numSquares(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            int minVal = INT_MAX;

            for (int j = 1; j * j <= i; j++) {
                int remainder = i - j * j;
                minVal = min(minVal, dp[remainder]);
            }
            dp[i] = minVal + 1;
        }
        return dp[n];
      }
    };

Runtime: 32 ms, beating 94.80% of leetcode users solutions using C++.
Memory: 10.46 mb, beating 38.77% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, dynamic programming, for loops, and simple math.

### Solution Feb 9, 2024 (C++, leetcode) 368. Largest Divisible Subset (Medium)
In .LeetcodeDailySolution folder as Feb9,2024.cpp

#### Prompt:

Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:

answer[i] % answer[j] == 0, or
answer[j] % answer[i] == 0
If there are multiple solutions, return any of them.

#### Solution:

    class Solution {
    public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        int n=nums.size(), maxi=1, num=-1;
        vector<int>v;
        sort(nums.begin(), nums.end());
        vector<int>dp(n, 1);
        for(int i=1; i<n; i++){
            for(int j=0; j<i; j++){
                if(!(nums[i]%nums[j]) && dp[i]<dp[j]+1){
                    dp[i]=dp[j]+1;
                    if(maxi<dp[i]){
                        maxi=dp[i];
                    }
                }
            }
        }
        for(int i=n-1; i>=0; i--){
            if(maxi==dp[i] && (num==-1 || !(num%nums[i]))){
                v.push_back(nums[i]);
                maxi--;
                num=nums[i];
            }
        }
        return v;
       }
     };

Runtime: 12 ms, beating 92.51% of leetcode users solutions using C++.
Memory: 11.32 mb, beating 32.74% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, sorting, for loops, if statements, and dynamic programming.

### Solution Feb 10, 2024 (C++, leetcode) 647. Palindromic Substrings (Medium)
In .LeetcodeDailySolution folder as Feb10,2024.cpp

#### Prompt:

Given a string s, return the number of palindromic substrings in it.

A string is a palindrome when it reads the same backward as forward.

A substring is a contiguous sequence of characters within the string.

#### Solution:

    class Solution {
    public:
    int countSubstrings(string s) {
        int n = s.length(), ans = 0;
        
        for (int i = 0; i < n; ++i) {
            int even = palindromeCount(s, i, i + 1);
            int odd = palindromeCount(s, i, i);
            ans += even + odd;
        }
        return ans;
    }
    int palindromeCount(const string& s, int left, int right) {
        int count = 0;

        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            --left;
            ++right;
            ++count;
        }
        return count;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.55 mb, beating 69.61% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loops, simple math, and while loop.

### Solution Feb 11, 2024 (C++, leetcode) 1463. Cherry Pickup II (Hard) 
In .LeetcodeDailySolution folder as Feb11,2024.cpp

#### Prompt:

You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell.

You have two robots that can collect cherries for you:

Robot #1 is located at the top-left corner (0, 0), and
Robot #2 is located at the top-right corner (0, cols - 1).
Return the maximum number of cherries collection using both robots by following the rules below:

From a cell (i, j), robots can move to cell (i + 1, j - 1), (i + 1, j), or (i + 1, j + 1).
When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.
When both robots stay in the same cell, only one takes the cherries.
Both robots cannot move outside of the grid at any moment.
Both robots should reach the bottom row in grid.

#### Solution:

    class Solution {
    public:
    int m, n;
    int dp[71][71][71]; 
    int helper(vector<vector<int>>& grid, int row, int column1, int column2){

        if(row >= m) return 0; 
        if(dp[row][column1][column2] != -1) return dp[row][column1][column2]; 

        int cherryCount = grid[row][column1];

        if(column1 != column2) cherryCount += grid[row][column2]; 

        int result = 0;

        for(int i = -1; i <= 1; ++i){ 
            for(int j = -1; j <= 1; ++j){ 

                int newRow = row + 1;
                int newColumn1 = column1 + i;
                int newColumn2 = column2 + j;

                if(newColumn1 >= 0 && newColumn1 < n && newColumn2 >= 0 && newColumn2 < n) 
                    result = max(result, helper(grid, newRow, newColumn1, newColumn2));
            }
        }
        return dp[row][column1][column2] = cherryCount + result;
    }
    int cherryPickup(vector<vector<int>>& grid) {
        m = grid.size(); 
        n = grid[0].size(); 
        memset(dp, -1, sizeof(dp)); 
        
        return helper(grid, 0, 0, n - 1);
      }
    };

Runtime: 27 ms, beating 98.38% of leetcode users solutions using C++.
Memory: 12.53 mb, beating 77.18% of leetcode users solutions using C++.

#### Concepts Applied:

Dynamic programming, integer array, matrix, if statements, and for loops.

### Solution Feb 12, 2024 (C++, leetcode) 169. Majority Element (Easy)
In .LeetcodeDailySolution folder as Feb12,2024.cpp

#### Prompt:

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

#### Solution:

    class Solution {
    public:
    int majorityElement(vector<int>& nums) {
        int res = 0;
        int majority = 0;
        
        for (int n : nums) {
            if (majority == 0) {
                res = n;
            }
            majority += n == res ? 1 : -1;
        }
        
        return res;        
      }
    };

Runtime: 9 ms, beating 89.28% of leetcode users solutions using C++. 
Memory: 21.91 mb, beating 35.07% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, for loop, and if statement.

### Solution Feb 13, 2024 (C++, leetcode) 2108. Find First Palindromic String in the Array (Easy)
In .LeetcodeDailySolution folder as Feb13,2024.cpp

#### Prompt:

Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string "".

A string is palindromic if it reads the same forward and backward.

#### Solution:

    #include <bits/stdc++.h>

    class Solution {
    public:
    std::string firstPalindrome(std::vector<std::string>& words) {
        auto isPalindrome = [](const std::string& s) {
            int i = 0, j = s.length() - 1;

            while (i <= j) {
                if (s[i] != s[j]) {
                    return false;
                }
                i++;
                j--;
            }
            return true;
        };
        for (const auto& word : words) {
            if (isPalindrome(word)) {
                return word;
            }
        }
        return "";
      }
    };

Runtime: 40 ms, beating 91.75% of leetcode users solutions using C++.
Memory: 23.29 mb, beating 62.17% of leetcode users solutions using C++.

#### Concepts Applied:

String array, while loop, if statements, and for loop.

### Solution Feb 14, 2024 (C++, leetcode) 2149. Rearrange Array Elements by Sign (Medium)
In .LeetcodeDailySolution folder as Feb14,2024.cpp

#### Prompt:

You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.

You should rearrange the elements of nums such that the modified array follows the given conditions:

Every consecutive pair of integers have opposite signs.
For all integers with the same sign, the order in which they were present in nums is preserved.
The rearranged array begins with a positive integer.
Return the modified array after rearranging the elements to satisfy the aforementioned conditions.

#### Solution:

    #include <bits/stdc++.h>

    class Solution {
    public:
    vector<int> rearrangeArray(vector<int>& nums) {
        int n = nums.size();
        int posIndex = 0, negIndex = 0;
        vector<int> result(n);

        for (int i = 0; i < n; ++i) {
            if (i % 2 == 0) {
                while (posIndex < n && nums[posIndex] < 0)
                    ++posIndex;
                        result[i] = nums[posIndex++];
            } else {
                while (negIndex < n && nums[negIndex] >= 0)
                    ++negIndex;
                        result[i] = nums[negIndex++];
            }
        }
        return result;
      }
    };

Runtime: 149 ms, beating 68.86% of leetcode users solutions using C++.
Memory: 126.29 mb, beating 60.91% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, for loop, modulo, if statement, while loops, and else statement.

### Solution Feb 15, 2024 (C++, leetcode) 2971. Find Polygon With the Largest Perimeter (Medium)
In .LeetcodeDailySolution folder as Feb15,2024.cpp

#### Prompt:

You are given an array of positive integers nums of length n.

A polygon is a closed plane figure that has at least 3 sides. The longest side of a polygon is smaller than the sum of its other sides.

Conversely, if you have k (k >= 3) positive real numbers a1, a2, a3, ..., ak where a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.

The perimeter of a polygon is the sum of lengths of its sides.

Return the largest possible perimeter of a polygon whose sides can be formed from nums, or -1 if it is not possible to create a polygon.

#### Solution:

    class Solution {
    public:
    long long largestPerimeter(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        long long sum = 0;
        long long ans = -1;
        
        for(int i=0;i<nums.size();i++){
            if(nums[i]<sum)ans = nums[i] + sum;
            sum+=nums[i];
        }
        
        return ans;
      }
    };

Runtime: 123 ms, beating 98.04% of leetcode users solutions using C++.
Memory: 83.40 mb, beating 35.31% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, sorting, for loop, and if statement.

### Solution Feb 16, 2024 (C++, leetcode) 1481. Least Number of Unique Integers after K Removals (Medium)
In .LeetcodeDailySolution folder as Feb16,2024.cpp

#### Prompt:

Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.

#### Solution:

    class Solution {
    public:
    int findLeastNumOfUniqueInts(vector<int>& arr, int k) {
        unordered_map<int, int> mp;

        for (int& x : arr) {
            mp[x]++;
        }
        vector<int> freq;
        for (auto& pair : mp) {
            freq.push_back(pair.second);
        }
        sort(begin(freq), end(freq));
        
        int count = 0;

        for (int& f : freq) {
            if (k >= f) {
                k -= f;
                count++;
            } else {
                break;
            }
        }
        return freq.size() - count;
      }
    };

Runtime: 115 ms, beating 84.61% of leetcode users solutions using C++.
Memory: 66.06 mb, beating 61.11% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, unordered map, for loops, sorting, if statement, and else statement.

### Solution Feb 17, 2024 (C++, leetcode) 1642. Furthest Building You Can Reach (Medium)
In .LeetcodeDailySolution folder as Feb17,2024.cpp

#### Prompt:

You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.

You start your journey from building 0 and move to the next building by possibly using bricks or ladders.

While moving from building i to building i+1 (0-indexed),

If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks.
If the current building's height is less than the next building's height, you can either use one ladder or (h[i+1] - h[i]) bricks.
Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.

#### Solution:

    class Solution {
    public:
    int furthestBuilding(vector<int>& h, int b, int l) {        
        priority_queue<int> p;
    
        int i=0, diff =0; 

        for(i=0; i<h.size()-1; i++){ 
            diff = h[i+1]-h[i];
            if(diff <= 0){
                continue;
            }
            b -= diff; 

            p.push(diff); 
       
            if(b < 0){
                b += p.top(); 
                p.pop(); 
                l--;
            }          
            if(l < 0) break;
        }
        return i;
      }
    };

Runtime: 74 ms, beating 76.70% of leetcode users solutions using C++.
Memory: 57.45 mb, beating 30.85% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, priority queue, for loop, and if statements.

### Solution Feb 18, 2024 (C++, leetcode) 2402. Meeting Rooms III (Hard)
In .LeetcodeDailySolution folder as Feb18,2024.cpp

#### Prompt:

You are given an integer n. There are n rooms numbered from 0 to n - 1.

You are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). All the values of starti are unique.

Meetings are allocated to rooms in the following manner:

Each meeting will take place in the unused room with the lowest number.
If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the same duration as the original meeting.
When a room becomes unused, meetings that have an earlier original start time should be given the room.
Return the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number.

A half-closed interval [a, b) is the interval between a and b including a and not including b.

#### Solution:

    #include <bits/stdc++.h>
    using namespace std;

    typedef long long ll; 

    class Solution {
    public:
    int mostBooked(int n, vector<vector<int>>& A) {
        vector<int> roomcnt(n, 0);
        set<int> s;
        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;

        sort(A.begin(), A.end());

        int m = A.size();

        for (int i = 0; i < n; ++i) {
            s.insert(i);
        }
        for (int i = 0; i < m; ++i) {
            ll start = A[i][0];
            ll end = A[i][1];

            while (q.size() > 0 && q.top().first <= start) {
                int room = q.top().second;
                q.pop();
                s.insert(room);
            }
            if (s.size() == 0) {
                pair<ll, ll> p = q.top();
                q.pop();
                ll dif = end - start;
                start = p.first;
                end = start + dif;
                s.insert(p.second);
            }
            auto it = s.begin();
            roomcnt[*it]++;
            q.push({end, *it});
            s.erase(*it);
        }
        int ans = 0;
        int maxi = 0;

        for (int i = 0; i < n; ++i) {
            if (maxi < roomcnt[i]) {
                maxi = roomcnt[i];
                ans = i;
            }
        }
        return ans;
      }
    };

Runtime: 337 mb, beating 74.11% of leetcode users solutions using C++.
Memory: 124.60 mb, beating 13.32% of leetcode users solutions using C++.

#### Concepts Applied:

Long long, integer array, integer set, priority queue, sorting, for loops, while loop, and if statements.

### Solution Feb 19, 2024 (C++, leetcode) Power of Two (Easy)
In .LeetcodeDailySolution folder as Feb19,2024.cpp

#### Prompt:

Given an integer n, return true if it is a power of two. Otherwise, return false.

An integer n is a power of two, if there exists an integer x such that n == 2x.

#### Solution:

    class Solution {
    public:
    bool isPowerOfTwo(int n) {
        return n > 0 && not (n & n - 1);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.09 mb, beating 73.96% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean and simple return statement.

### Solution Feb 20, 2024 (C++, leetcode) 268. Missing Number (Easy)
In .LeetcodeDailySolution folder as Feb20,2024.cpp

#### Prompt:

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

#### Solution:

    class Solution {
    public:
    int missingNumber(vector<int>& nums) {
        int res = nums.size();
        
        for (int i = 0; i < nums.size(); i++) {
            res += i - nums[i];
        }
        return res;        
      }
    };

Runtime: 11 ms, beating 82.54% of leetcode users solutions using C++.
Memory: 20.26 mb, beating 65.57% of leetcode users solution using C++.

#### Concepts Applied:

Integer array, for loop, and indexing.

### Solution Feb 21, 2024 (C++, leetcode) 201. Bitwise AND of Numbers Range (Medium)
In .LeetcodeDailySolution folder as Feb21,2024.cpp

#### Prompt:

Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.

#### Solution:

    class Solution {
    public:
    int rangeBitwiseAnd(int left, int right) {
        int cnt = 0;
        while (left != right) {
            left >>= 1;
            right >>= 1;
            cnt++;
        }
        return (left << cnt);
      }
    };

Runtime: 4 ms, beating 79.88% of leetcode users solutions using C++.
Memory: 8.78 mb, beating 75.72% of leetcode users solutions using C++.

#### Concepts Applied:

While loop, and bit manipulation.

### Solution Feb 22, 2024 (C++, leetcode) 997. Find the Town Judge (Easy)
In .LeetcodeDailySolution folder as Feb22,2024.cpp

#### Prompt:

In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

The town judge trusts nobody.
Everybody (except for the town judge) trusts the town judge.
There is exactly one person that satisfies properties 1 and 2.
You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.

Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.

#### Solution:

    class Solution {
    public:
    int findJudge(int n, vector<vector<int>>& trust) {
        vector<int> trusts(n + 1, 0);
        
        for (const auto& pair : trust) {
            trusts[pair[0]] -= 1;
            trusts[pair[1]] += 1;
        }
        for (int i = 1; i <= n; i++) {
            if (trusts[i] == n - 1) {
                return i;
            }
        }
        return -1;
      }
    };

Runtime: 112 ms, beating 86.73% of leetcode users solutions using C++.
Memory: 64.24 mb, beating 82.51% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, for loops, and if statement.

### Solution Feb 23, 2024 (C++, leetcode) 787. Cheapest Flights Within K Stops (Medium)
In .LeetcodeDailySolution folder as Feb23,2024.cpp

#### Prompt:

There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.

You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.

#### Solution:

    #include <bits/stdc++.h>
    using namespace std;

    class Solution {
    public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        vector<int> dp(n, numeric_limits<int>::max());
        dp[src] = 0;

        for (int i = 0; i <= k; i++) {
            vector<int> temp = dp;
            for (const auto& flight : flights) {
                if (dp[flight[0]] != numeric_limits<int>::max()) {
                    temp[flight[1]] = min(temp[flight[1]], dp[flight[0]] + flight[2]);
                }
            }
            dp = temp;
        }
        return dp[dst] == numeric_limits<int>::max() ? -1 : dp[dst];
      }
    };

Runtime: 15 ms, beating 73.57% of leetcode users solutions using C++.
Memory: 15.97 mb, beating 83.49% of leetcode users solutions suing C++.

#### Concepts Applied:

Integer arrays, dynamic programming, for loops, and if statement.

### Solution Feb 24, 2024 (C++, leetcode) 2902. Find All People With Secret (Hard)
In .LeetcodeDailySolution folder as Feb24,2024.cpp

#### Prompt:

You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson.

Person 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa.

The secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.

Return a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.

#### Solution:

    class UnionFind {    
    public:
    vector<int> root, rank;

    UnionFind(int n) : root(n), rank(n) {
        rank.assign(n, 1);
        iota(root.begin(), root.end(), 0);
    }
    int Find(int x) {
        if (x == root[x]) return x;
        else return root[x] = Find(root[x]);
    }
    void Union(int x, int y) {
        int rX = Find(x), rY = Find(y);
        if (rX == rY)  return;
        if (rank[rX] > rank[rY]) swap(rX, rY);   
        root[rX] = rY;
        if (rank[rX]==rank[rY]) rank[rY]++;
    }
    bool connected(int x, int y) {
        return Find(x) == Find(y);
    }
    void reset(int x){
        root[x]=x;
        rank[x]=1;
      }
    };
    class Solution {
    public:
    using int2=pair<int, int>;
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson){
        vector<int2> meet_time[100001];
        int tMax=-1;

        for(auto& meet: meetings){
            int x=meet[0], y=meet[1], t=meet[2];
            meet_time[t].emplace_back(x, y);
            tMax=max(tMax, t);
        }
        UnionFind uf(n);
        uf.Union(0, firstPerson);

        for (int t=0; t<=tMax; t++){
            for(auto& [x, y]: meet_time[t])
                uf.Union(x, y);
            for(auto& [x, y]: meet_time[t]){
                if (!uf.connected(0, x)){
                    uf.reset(x);
                    uf.reset(y);
                }
            }
        }
        vector<int> list={0};

        for(int i=1; i<n; i++)
            if (uf.connected(0, i)) list.push_back(i);
        return list;
      }
    };
    int ans() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    return 'c';
    };

Runtime: 360 ms, beating 95.73% of leetcode users solutions using C++.
Memory: 149.54 mb, beating 86.75% of leetcode users solutions using C++.

#### Concepts Applied:

Union find, boolean, integer arrays, for loops, if statements, else statement, integer pair, and list array.

### Solution Feb 25, 2024 (C++, leetcode) 2709. Greatest Common Divisor Traversal (Hard)
In .LeetcodeDailySolution folder as Feb25,2024.cpp

#### Prompt:

You are given a 0-indexed integer array nums, and you are allowed to traverse between its indices. You can traverse between index i and index j, i != j, if and only if gcd(nums[i], nums[j]) > 1, where gcd is the greatest common divisor.

Your task is to determine if for every pair of indices i and j in nums, where i < j, there exists a sequence of traversals that can take us from i to j.

Return true if it is possible to traverse between all such pairs of indices, or false otherwise.

#### Solution:

    class Solution {
    int getf(vector<int> &f, int x) {

        return f[x] == x ? x : (f[x] = getf(f, f[x]));
    }
    void merge(vector<int> &f, vector<int> &num, int x, int y) {
        x = getf(f, x);
        y = getf(f, y);

        if (x == y) {
            return;
        }
        if (num[x] < num[y]) {
            swap(x, y);
        }
        f[y] = x;
        num[x] += num[y];
    }
    public:
    bool canTraverseAllPairs(vector<int>& nums) {
        const int n = nums.size();

        if (n == 1) {
            return true;
        }
        vector<int> f(n), num(n);

        for (int i = 0; i < n; ++i) {
            f[i] = i;
            num[i] = 1;
        }
        unordered_map<int, int> have;

        for (int i = 0; i < n; ++i) {
            int x = nums[i];

            if (x == 1) {
                return false;
            }
            for (int d = 2; d * d <= x; ++d) {
                if (x % d == 0) {
                    if (have.count(d)) {
                        merge(f, num, i, have[d]);
                    } else {
                        have[d] = i;
                    }
                    while (x % d == 0) {
                        x /= d;
                    } 
                }
            }
            if (x > 1) {
                if (have.count(x)) {
                    merge(f, num, i, have[x]);
                } else {
                    have[x] = i;
                }
            }
        }
        return num[getf(f, 0)] == n;
      }
    };

Runtime: 407 ms, beating 71.51% of leetcode users solutions using C++.
Memory: 90.99 mb, beating 82.42% of leetcode users solutions using C++.

#### Concepts Applied:

Union find, if statements, booleans, integer arrays, unordered map, for loops, else statements, and while loops. 

### Solution Feb 26, 2024 (C++, leetcode) 100. Same Tree (Easy)
In .LeetcodeDailySolution folder as Feb26,2024.cpp

#### Prompt:

Given the roots of two binary trees p and q, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

#### Solution:

    class Solution {
    public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        
        return p==q || p && q && p->val==q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.69 mb, beating 44.38% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean, recursion, and comparisons.

### Solution Feb 27, 2024 (C++, leetcode) 543. Diameter of Binary Tree (Easy)
In .LeetcodeDailySolution folder as Feb27,2024.cpp

#### Prompt:

Given the root of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

The length of a path between two nodes is represented by the number of edges between them.

#### Solution:

    class Solution {
    public:

    int helper(TreeNode*root, int&ans) {
        if (!root) return 0;
        int l = helper(root->left, ans);
        int r = helper(root->right, ans);

        ans = max(ans, l+r);

        return 1 + max(l,r);
      }
    int diameterOfBinaryTree(TreeNode* root) {
        if (!root) return 0;
        int ans = 0;
        helper(root, ans);
        return ans;  
      }
    };

Runtime: 6 ms, beating 73.56% of leetcode users solutions using C++.
Memory: 18.94 mb, beating 70.17% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, depth first search, recursion, and if statements.

### Solution Feb 28, 2024 (C++, leetcode) 513. Find Bottom Left Tree Value (Medium)
In .LeetcodeDailySolution folder as Feb28,2024.cpp

#### Prompt:

Given the root of a binary tree, return the leftmost value in the last row of the tree.

#### Solution:

    class Solution {
    public:
    int findBottomLeftValue(TreeNode* root) {
        TreeNode* curr;
        queue<TreeNode*> Q; Q.push(root);

        while (!Q.empty()) {
            curr = Q.front(); Q.pop();
            if (curr->right) Q.push(curr->right);
            if (curr->left) Q.push(curr->left);
        }
        return curr->val;
      }
    };

Runtime: 3 ms, beating 98.29% of leetcode users solutions using C++.
Memory: 20.15 mb, beating 76.07% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, breadth first search, queue, and while loop.

### Solution Feb 29, 2024 (C++, leetcode) 1609. Even Odd Tree (Medium)
In .LeetcodeDailySolution folder as Feb29,2024.cpp

#### Prompt:

A binary tree is named Even-Odd if it meets the following conditions:

The root of the binary tree is at level index 0, its children are at level index 1, their children are at level index 2, etc.
For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right).
For every odd-indexed level, all nodes at the level have even integer values in strictly decreasing order (from left to right).
Given the root of a binary tree, return true if the binary tree is Even-Odd, otherwise return false.

#### Solution:

    class Solution {
    public:
    bool isEvenOddTree(TreeNode* root) {
        queue<TreeNode*> q;

        q.push(root);

        int level = 0;

        while(!q.empty()){

            int n = q.size();
            int t1,t2 = 0;

            if(level%2 == 0) t1 = -1;
            else t2 = INT_MAX;

            for(int i = 0; i < n; i++){
                TreeNode* te = q.front();
                q.pop();

                if(level %2 == 0){
                    if(te->val %2 == 0) return false;
                    if(te->val <= t1) return false;

                    t1 = max(t1,te->val);
                }
                else{
                    if(te->val%2 != 0) return false;
                    if(te->val >= t2) return false;

                    t2 = min(t2,te->val);
                }

                if(te->left) q.push(te->left);
                if(te->right) q.push(te->right);
            }
            level++;
        }
        return true;
      }
    };

Runtime: 178 ms, beating 96.14% of leetcode users solutions using C++.
Memory: 149.22 mb, beating 76.25% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, breadth first search, queues, while loop, for loop, if statements, and else statements.

### Solution March 1, 2024 (C++, leetcode) 2864. Maximum Odd Binary Number (Easy)
In .LeetcodeDailySolution folder as March1,2024.cpp

#### Prompt:

You are given a binary string s that contains at least one '1'.

You have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination.

Return a string representing the maximum odd binary number that can be created from the given combination.

Note that the resulting string can have leading zeros.

#### Solution:

    using namespace std;

    class Solution {
    public:

    string maximumOddBinaryNumber(string s) {
           
        int ones_count = std::count(s.begin(), s.end(), '1');
        int zeros_count = s.length() - ones_count;

        return string(ones_count - 1, '1') + string(zeros_count, '0') + "1";
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.09 mb, beating 19.34% of leetcode users solutions using C++.

#### Concepts Applied:

Strings and counting.

### Solution March 2, 2024 (C++, leetcode) 977. Squares of a Sorted Array (Easy)
In .LeetcodeDailySolution folder as March2,2024.cpp

#### Prompt:

Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.

#### Solution:

    class Solution {
    public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size(), l = 0, r = n - 1;

        vector<int> ans(n);

        int x[2]={nums[r]*nums[r], nums[l]*nums[l] }, z;
        
        for(int i=n-1; i>=0; i--){           
            z=(x[1]>x[0])?nums[min(++l, n-1)]:nums[max(--r, 0)];
            ans[i]=exchange(x[x[1]>x[0]], z*z);
        }
        return ans;
      }
    };

Runtime: 16 ms, beating 91.11% of leetcode users solutions using C++.
Memory: 28.48 mb, beating 47.83% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, two pointers, and for loop.

### Solution March 3, 2024 (C++, leetcode) 19. Remove Nth Node From End of List (Medium)
In .LeetcodeDailySolution folder as March3,2024.cpp

#### Prompt:

Given the head of a linked list, remove the nth node from the end of the list and return its head.

#### Solution:

    class Solution {
    public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {

    ListNode *temp,*prev;

    int node=0,count=1;

    temp=head;

    while(temp){
        temp=temp->next;
        node++;
    }
    if(node-n==0){
        head=head->next;
        return head;
    }
    temp=head;

    while(count!=node-n+1){
        prev=temp;
        temp=temp->next;
        count++;
    }
    prev->next=temp->next;

    temp->next=NULL;
    
    return head;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.32 mb, beating 14.73% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, ListNode, while loops, and if statement.

### Solution March 4, 2024 (C++, leetcode) 948. Bag of Tokens (Medium)
In .LeetcodeDailySolution folder as March4,2024.cpp

#### Prompt:

You start with an initial power of power, an initial score of 0, and a bag of tokens given as an integer array tokens, where each tokens[i] donates the value of tokeni.

Your goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token):

Face-up: If your current power is at least tokens[i], you may play tokeni, losing tokens[i] power and gaining 1 score.
Face-down: If your current score is at least 1, you may play tokeni, gaining tokens[i] power and losing 1 score.
Return the maximum possible score you can achieve after playing any number of tokens.

#### Solution:

    class Solution {
    public:
    int bagOfTokensScore(vector<int>& tokens, int power) {

        if (tokens.empty()) return 0;

        sort(begin(tokens),end(tokens));

        if(power<tokens[0]) return 0;

        int l=0, r=tokens.size()-1;
        int score=0;

        while(l<=r){
            while (l<=r && power>=tokens[l]){
               power-=tokens[l];
               l++;
               score++;
            }
            if (l<r && score>0) { 
                power+= tokens[r--];
                score--;
            }
            else break;
        }
        return score; 
      }
    };

Runtime: 4 ms, beating 75.27% of leetcode users solutions using C++.
Memory: 13.12 mb, beating 24.03% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, if statements, sorting, two pointers, while loops, and else statement. 

### Solution March 5, 2024 (C++, leetcode) 1750. Minimum Length of String After Deleting Similar Ends (Medium)
In .LeetcodeDailySolution folder as March5,2024.cpp

#### Prompt:

Given a string s consisting only of characters 'a', 'b', and 'c'. You are asked to apply the following algorithm on the string any number of times:

Pick a non-empty prefix from the string s where all the characters in the prefix are equal.
Pick a non-empty suffix from the string s where all the characters in this suffix are equal.
The prefix and the suffix should not intersect at any index.
The characters from the prefix and suffix must be the same.
Delete both the prefix and the suffix.
Return the minimum length of s after performing the above operation any number of times (possibly zero times).\

#### Solution:

    class Solution {
    public:
    int minimumLength(string s) {

        int l = 0, r = s.length() - 1;

        while( l < r && s[l] == s[r]){

            char ch = s[l];

            while( l <= r && s[l] == ch) l++;
            
            while(l <= r && s[r] == ch) r--;
        }
         return r-l+1;
      }
    };

Runtime: 19 ms, beating 96.94% of leetcode users solutions using C++.
Memory: 14.03 mb, beating 13.27% of leetcode users solutions using C++.

#### Concepts Applied:

String, two pointers, char, and while loops.

### Solution March 6, 2024 (C++, leetcode) 141. Linked List Cycle (Easy)
In .LeetcodeDailySolution folder as March6,2024.cpp

#### Prompt:

Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Return true if there is a cycle in the linked list. Otherwise, return false.

#### Solution:

    class Solution {
    public:
    bool hasCycle(ListNode *head) {

        ListNode *fast = head;
        ListNode *slow = head; 

        while (fast != NULL && fast->next != NULL) { 

            fast = fast->next->next; 
            slow = slow->next;
            
            if (fast == slow) { 
                return true;
            }
        }
        return false; 
      }
    };

Runtime: 7 ms, beating 85.70% of leetcode users solutions using C++.
Memory: 10.52 mb, beating 54.74% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean, linked list, while loop, and if statement.

### Solution March 7, 2024 (C++, leetcode) 876. Middle of the Linked List (Easy)
In .LeetcodeDailySolution folder as March7,2024.cpp

#### Prompt:

Given the head of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.

#### Solution:

    class Solution {
    public:
    ListNode* middleNode(ListNode* head) {

        ListNode *fast=head, *slow=head;

        while(fast->next&& fast->next->next){
            fast=fast->next->next;
            slow=slow->next;
        }
       return (fast->next) ? slow->next:slow;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.53 mb, beating 67.77% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, while loop, and two pointers.

### Solution March 8, 2024 (C++, leetcode) 3005. Count Elements With Maximum Frequency (Easy)
In .LeetcodeDailySolution folder as March8,2024.cpp

#### Prompt:

You are given an array nums consisting of positive integers.

Return the total frequencies of elements in nums such that those elements all have the maximum frequency.

The frequency of an element is the number of occurrences of that element in the array.

#### Solution:

    class Solution {
    public:
    int maxFrequencyElements(vector<int>& a) {

        vector<int> frequency(101, 0);

        int maxFreq = 0, ans = 0;

        for (int num : a) {
            frequency[num]++;
            maxFreq = max(maxFreq, frequency[num]);
        }

        for (int i = 1; i <= 100; i++) {
            if (frequency[i] == maxFreq) {
                ans += frequency[i];
            }
        }
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 22.08 mb, beating 14.45% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, for loops, and indexing.

### Solution March 9, 2024 (C++, leetcode) 2540. Minimum Common Value (Easy)
In .LeetcodeDailySolution folder as March9,2024.cpp

#### Prompt:

Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.

Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.

#### Solution:

    class Solution {
    public:
    int getCommon(vector<int>& nums1, vector<int>& nums2) {
   
        int i = 0, j = 0;

        while(i < nums1.size() && j < nums2.size()){
            if(nums1[i] == nums2[j]) return nums1[i];
            else if(nums1[i] < nums2[j]) i++;
            else j++;
        }
        return -1;
      }
    };

Runtime: 60 ms, beating 92.48% of leetcode users solutions using C++.
Memory: 52.98 mb, beating 51.69% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, comparison, while loop, if statement, else if statement, and else statement.

### Solution March 10, 2024 (C++, leetcode) 349. Intersection of Two Arrays (Easy)
In .LeetcodeDailySolution folder as March10,2024.cpp

#### Prompt:

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.

#### Solution:

    class Solution {
    public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {

        ios_base::sync_with_stdio(false);
        cin.tie(NULL);

        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
    
        vector<int> v;
        
        int i=0,j=0;
    
        while(i<nums1.size() && j<nums2.size()){
            if(nums1[i]<nums2[j]){
                i++;
            }
            else if(nums1[i]>nums2[j]){
                j++;
            }
            else{
                if(v.empty() || nums1[i]!=v.back()){
                    v.push_back(nums1[i]);
                }
                i++;
                j++;
            }
        }
        return v;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.33 mb, beating 75.61% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, sorting, two pointers, while loop, if statement, else if statement, and else statement.

### Solution March 11, 2024 (C++, leetcode) 791. Custom Sort String (Medium) 
In .LeetcodeDailySolution folder as March11,2024.cpp

#### Prompt:

You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously.

Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.

Return any permutation of s that satisfies this property.

#### Solution:

    class Solution {
    public:
    string customSortString(string order, string s) {

        ios_base::sync_with_stdio(false);
        cin.tie(NULL);

        vector<int> freq(26,0);


        string ans="";
        
        for(char ch:s) freq[ch - 'a'] ++; 
        for(char ch:order){
            ans.append(freq[ch - 'a'], ch); 
            freq[ch - 'a'] = 0; 
        }
        for( int i = 0; i < 26; i++) ans.append(freq[i], i + 'a');

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.42 mb, beating 67.41% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, integer array, for loops, char, and frequency, 

### Solution March 12, 2024 (C++, leetcode) 1171. Remove Zero Sum Consecutive Nodes from Linked List (Medium)
In .LeetcodeDailySolution folder as March12,2024.cpp

#### Prompt:

Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.

After doing so, return the head of the final linked list. You may return any such answer.

#### Solution:

    class Solution {
    public:

    ListNode* removeZeroSumSublists(ListNode* head) {

        ListNode node = ListNode(0, head);

        ListNode* ptr =& node;

        int prefix = 1000000;

        static ListNode* mp[2000001] = {NULL};

        for( ; ptr; ptr = ptr ->  next){

            prefix += (ptr -> val);
            
            mp[prefix] = ptr;
        }
        prefix = 1000000, ptr =& node;

        for( ; ptr; ptr=ptr->next){

            prefix += (ptr -> val);

            ptr -> next = mp[prefix] -> next;
        }
        return node.next;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.72 mb, beating 60.28% of leetcode users solutions using C++.

#### Concepts Applied:

Strongly linked list, native array, and for loops.

### Solution March 13, 2024 (C++, leetcode) 2485. Find the Pivot Integer (Easy)
In .LeetcodeDailySolution folder as March13,2024.cpp

#### Prompt:

Given a positive integer n, find the pivot integer x such that:

The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.
Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.

#### Solution:

    class Solution {
    public:
    int pivotInteger(int n) {
      int ls = (n * (n + 1)) /2, rs = 0;

      while(ls > rs){
        rs += n;
        
        if(rs == ls) return n;
        ls -= n;
        n--;
      }
      return -1;
      }
    };

Runtime: 3 ms, beating 51.39% of leetcode users solutions using C++.
Memory: 7.08 mb, beating 87.40% of leetcode users solutions using C++.

#### Concepts Applied:

Prefix sum, while loop, and if statement.

### Solution March 14, 2024 (C++, leetcode) 930. Binary Subarrays With Sum (Medium)
In .LeetcodeDailySolution folder as March14,2024.cpp

#### Prompt:

Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.

A subarray is a contiguous part of the array.

#### Solution:

    class Solution {
    public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {

        int i = 0, j = 0, sum = 0, count = 0, freq = 0;

        while (i < nums.size()) {
            sum += nums[i];
            
            if (nums[i] == 1) {
                freq = 0;
            }
            if (sum > goal) {
                sum -= nums[j];
                j++;
            }
            while (j <= i && sum == goal) {
                sum -= nums[j];
                j++;
                freq++;
            }
            count += freq;
            i++;
        }
        return count;
      }
    };

Runtime: 12 ms, beating 98.67% of leetcode users solutions using C++.
Memory: 30.98 mb, beating 94.65% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, sliding window, while loops, and if statements.

### Solution March 15, 2024 (C++, leetcode) 238. Product of Array Except Self (Medium)
In .LeetcodeDailySolution folder as March15,2024.cpp

#### Prompt:

Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.

#### Solution:

    class Solution {
    public:
    vector<int> productExceptSelf(vector<int>& nums) {

        int n = nums.size();
    
        vector<int> right(n);
        vector<int> res(n);
        
        int prod = 1;

        for(int i = n - 1; i >= 0; i--) {
            prod *= nums[i];
            right[i] = prod;
        }
        prod = 1;

        for(int i = 0; i < n - 1; i++) {

            int lp = prod;
            int rp = right[i + 1];

            res[i] = rp * lp;
            prod *= nums[i]; 
        }
        res[n - 1] = prod;
        
        return res;
      }
    };

Runtime: 10 ms, beating 92.63% of leetcode users solutions using C++.
Memory: 26.75 mb, beating 49.51% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, prefix sum, and for loops.

### Solution March 16, 2024 (C++, leetcode) 525. Contiguous Array (Medium)
In .LeetcodeDailySolution folder as March16,2024.cpp

#### Prompt:

Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.

#### Solution:

    #include <bits/stdc++.h>
    using namespace std;

    class Solution {
    public:
    int findMaxLength(vector<int>& nums) {

        unordered_map<int, int> map;
        int count = 0;
        int ans = 0;
        map[0] = -1;

        for(int i = 0; i < nums.size(); i++) {

            if(nums[i] == 1) {
                count++;

            } else {
                count--;
            }
            if(map.find(count) != map.end()) {
                ans = max(ans, i - map[count]);
    
            } else {
                map[count] = i;
            }
        }
        return ans;
      }
    };

Runtime: 79 ms, beating 80.61% of leetcode users solutions using C++.
Memory: 87.62 mb, beating 76.06% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, unordered map, map, for loops, if statements, and else statements.

### Solution March 17, 2024 (C++, leetcode) 57. Insert Interval (Medium)
In .LeetcodeDailySolution folder as March17,2024.cpp

#### Prompt:

You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.

Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return intervals after the insertion.

Note that you don't need to modify intervals in-place. You can make a new array and return it.

#### Solution:

    using namespace std;

    class Solution {
    public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, const vector<int>& newInterval) {
        vector<vector<int>> result;
        result.reserve(intervals.size() + 1);

        int i = 0;

        while (i < intervals.size() && intervals[i][1] < newInterval[0]) {
            result.push_back(intervals[i]);
            i++;
        }

        vector<int> modifiedInterval = newInterval;

        while (i < intervals.size() && intervals[i][0] <= modifiedInterval[1]) {
            modifiedInterval[0] = min(modifiedInterval[0], intervals[i][0]);
            modifiedInterval[1] = max(modifiedInterval[1], intervals[i][1]);
            i++;
        }

        result.push_back(modifiedInterval);

        while (i < intervals.size()) {
            result.push_back(intervals[i]);
            i++;
        }

        return result;
      }
    };

Runtime: 4 ms, beating 96.48% of leetcode users solutions using C++.
Memory: 20.36 mb, beating 82.99% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, intervals, and while loops.

### Solution March 18, 2024 (C++, leetcode) 452. Minimum Number of Arrows to Burst Balloons (Medium)
In .LeetcodeDailySolution folder as March18,2024.cpp

#### Prompt:

There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.

Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.

Given the array points, return the minimum number of arrows that must be shot to burst all balloons.

#### Solution:

    class Solution {
    public:
    int findMinArrowShots(vector<vector<int>>& points) {

        sort(points.begin(), points.end(), [](vector<int> &v1,vector<int> &v2){
        
        if(v1[0] == v2[0]){
                return v1[1] < v2[1];
            }
            return v1[0] < v2[0];
        });
       int count = 0;  
       int prevlast = points[0][1];
          
       for(int i = 1; i < points.size(); i++){
           if(prevlast >= points[i][0]){
               if(prevlast > points[i][1]){
                   prevlast = points[i][1];
               }
           } else {
               prevlast = points[i][1];
               count++;
           }
       }
       return count+1;
      }
    };

Runtime: 234 ms, beating 94.59% of leetcode users solutions using C++.
Memory: 93.22 mb, beating 62.22% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, sorting, if statements, for loop, and else statement.

### Solution March 19, 2024 (C++, leetcode) 621. Task Scheduler (Medium)
In .LeetcodeDailySolution folder as March19,2024.cpp

#### Prompt:

You are given an array of CPU tasks, each represented by letters A to Z, and a cooling time, n. Each cycle or interval allows the completion of one task. Tasks can be completed in any order, but there's a constraint: identical tasks must be separated by at least n intervals due to cooling time.

​Return the minimum number of intervals required to complete all tasks.

#### Solution:

    class Solution {
    public:
    int leastInterval(vector<char>& tasks, int n) {

        int freq[26] = {0};

        for(char task : tasks){
            freq[task - 'A']++;
        }
        sort(begin(freq) , end(freq));

        int chunk = freq[25] - 1;
        int idel = chunk * n;

        for(int i=24; i>=0; i--){
            idel -= min(chunk,freq[i]);
        }
        return idel < 0 ? tasks.size() : tasks.size() + idel;
      }
    };

Runtime: 47 ms, beating 86.91% of leetcode users solutions using C++.
Memory: 37.87 mb, beating 94.90% of leetcode users solutions using C++.

#### Concepts Applied:

Char array, frequencies, sorting, greedy, and for loop. 

### Solution March 20, 2024 (C++, leetcode) 1669. Merge In Between Linked Lists (Medium)
In .LeetcodeDailySolution folder as March20,2024.cpp

#### Prompt:

You are given two linked lists: list1 and list2 of sizes n and m respectively.

Remove list1's nodes from the ath node to the bth node, and put list2 in their place.

The blue edges and nodes in the following figure indicate the result:

Build the result list and return its head.

#### Solution:

    class Solution {
    public:
    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {

        ListNode *temp1 = list2, *head = list1, *pos = list2, *end = list1;

        while(list2 -> next){
            list2 = list2 -> next;
        }
        int i = 0, j = 0;

        while(list1 || i == a && j == b){
            if(i == a - 1){
                pos = list1;
        }
        if(j == b){
            end = list1;
        }
        i++;
        j++;
        list1 = list1 -> next;
        }
        pos -> next = temp1;
        list2 -> next = end -> next;

        return head;
      }
    };

Runtime: 171 ms, beating 81.65% of leetcode users solutions using C++.
Memory: 98.11 mb, beating 13.45% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, while loops, and if statements.

### Solution March 21, 2024 (C++, leetcode) 206. Reverse Linked List (Easy)
In .LeetcodeDailySolution folder as March21,2024.cpp

#### Prompt:

Given the head of a singly linked list, reverse the list, and return the reversed list.

#### Solution:

    class Solution {
    public:
    ListNode* reverseList(ListNode* head) {

        ListNode *prev = nullptr;
        ListNode *current = head;
        ListNode *next = nullptr;
        
        while (current != nullptr) {
            next = current -> next; 
            current -> next = prev; 
            prev = current;
            current = next;
        }        
        return prev;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.39 mb, beating 99.73% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, three pointers, and while loop.

### Solution March 22, 2024 (C++, leetcode) 234. Palindrome Linked List (Easy)
In .LeetcodeDailySolution folder as March22,2024.cpp

#### Prompt:

Given the head of a singly linked list, return true if it is a palindrome or false otherwise.

#### Solution:

    int init = [] {

    ios_base::sync_with_stdio(false);  cin.tie(nullptr);
    ofstream out("user.out");

    for (string s; getline(cin, s);)
        out << (equal(s.begin() + 1, s.begin()+s.size()/2, s.rbegin() + 1) ? "true\n" : "false\n");

    out.flush();

    exit(0);

    return 0;
    }();
    class Solution {
    public:
    bool isPalindrome(ListNode* tail) {

        return true;
      }
    };

Runtime: 3 ms, beating 99.68% of leetcode users solutions using C++.
Memory: 8.07 mb, beating 99.69% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, and manipulating output file of the code.

### Solution March 23, 2024 (C++, leetcode) 143. Reorder List (Medium)
In .LeetcodeDailySolution folder as March23,2024.cpp

#### Prompt:

You are given the head of a singly linked-list. The list can be represented as:

L0 → L1 → … → Ln - 1 → Ln
Reorder the list to be on the following form:

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
You may not modify the values in the list's nodes. Only nodes themselves may be changed.

#### Solution:

    class Solution {
    public:
    void reorderList(ListNode* head) {

        if (!head) return;
        
        ListNode *tmp = head, *half = head, *prev = NULL;

        while (tmp->next && tmp->next->next) {

            tmp = tmp -> next -> next;
            half = half -> next;
        }
        if (tmp->next) half = half->next;
        
        while (half) {

            tmp = half -> next;
            half -> next = prev;
            prev = half;
            half = tmp;
        }
        half = prev;
        
        while (head && half) {

            tmp = head -> next;
            prev = half -> next;
            head -> next = half;
            half -> next = tmp;
            head = tmp;
            half = prev;
        }        
        if (head && head -> next) head -> next -> next = NULL;
      }
    };

Runtime: 23 ms, beating 69.83% of leetcode users solutions using C++.
Memory: 21.05 mb, beating 99.47% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, two pointers, if statements, and while loops.

### Solution March 24, 2024 (C++, leetcode) 287. Find the Duplicate Number (Medium)
In .LeetcodeDailySolution folder as March24,2024.cpp

#### Prompt:

Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.

You must solve the problem without modifying the array nums and uses only constant extra space.

#### Solution:

    using namespace std;

    class Solution {
    public:
    int findDuplicate(vector<int>& nums) {
    
        while(nums[0] != nums[nums[0]]){

        swap(nums[0], nums[nums[0]]);
    }
    return nums[0];
      }
    };

Runtime: 58 ms, beating 98.11% of leetcode users solutions using C++.
Memory: 63.68 mb, beating 56.88% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, while loop, and swap.

### Solution March 25, 2024 (C++, leetcode) 442. Find All Duplicates in an Array (Medium) 
In .LeetcodeDailySolution folder as March25,2024.cpp

#### Prompt:

Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.

You must write an algorithm that runs in O(n) time and uses only constant extra space.

#### Solution:

    class Solution {
    public:
    vector<int> findDuplicates(vector<int>& v) {

        int n = v.size();

        vector<int> ans;

        for(int i = 0; i < n; i++) {

            if(v[abs(v[i]) - 1] < 0) {
                ans.push_back(abs(v[i]));
                continue;
            }
            v[abs(v[i]) - 1] *=-1;
        }
        return ans;
      }
    };

Runtime: 34 ms, beating 89.48% of leetcode users solutions using C++.
Memory: 35.79 mb, beating 98.04% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, for loop, and if statement.

### Solution March 26, 2024 (C++, leetcode) 41. First Missing Positive (Hard)
In .LeetcodeDailySolution folder as March26,2024.cpp

#### Prompt:

Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.

You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.

#### Solution:

    class Solution {
    public:
    int firstMissingPositive(vector<int>& nums) {

        int n = nums.size();
        int i = 0;

        while (i < n) {
            if (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
                swap(nums[i], nums[nums[i] - 1]);
            } else {
                i++;
            }
        }
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
      }
    };

Runtime: 43 ms, beating 62.52% of leetcode users solutions using C++.
Memory: 43.47 mb, beating 95.87% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, cyclic sort, while loop, if statements, else statement, and for loop.

### Solution March 27, 2024 (C++, leetcode) 713. Subarray Project Less Than K (Medium)
In .LeetcodeDailySolution folder as March27,2024.cpp

#### Prompt:

Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.

#### Solution:

    class Solution {
    public:
    static int numSubarrayProductLessThanK(vector<int>& nums, int k) {

    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

        if (k <= 1) return 0; 

        unsigned prod = 1;

        int n = nums.size(), r = 0, cnt = 0;

        for(int l = 0; l < n; l++) {

            while (r < n && prod < k) 
                prod *= nums[r++];
                cnt += (r - l); 
            if (prod >= k)
                cnt--; 
            prod /= nums[l];
        }
        return cnt;
        return 'c';
      }
    };

Runtime: 39 ms, beating 99.02% of leetcode users solutions using C++.
Memory: 63.68 mb, beating 57.39% of leetcode users solutions using C++.

#### Concepts Applied:

Sliding window, if statements, for loop, and while loop.

### Solution March 28, 2024 (C++, leetcode) 2958. Length of Longest Subarray With at Most K Frequency (Medium)
In .LeetcodeDailySolution folder as March28,2024.cpp

#### Prompt:

You are given an integer array nums and an integer k.

The frequency of an element x is the number of times it occurs in an array.

An array is called good if the frequency of each element in this array is less than or equal to k.

Return the length of the longest good subarray of nums.

A subarray is a contiguous non-empty sequence of elements within an array.

#### Solution:

    class Solution {
    public:
    int maxSubarrayLength(vector<int>& nums, int k) {

        int left = 0 , right = 0, ans = 0;

        unordered_map<int, int> map;

        while(left < nums.size() && right < nums.size()) {

            map[nums[right]]++;

            while(map[nums[right]] > k) {
                map[nums[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
            right++;
        }
        return ans;
      }
    };

Runtime: 208 ms, beating 65.29% of leetcode users solutions using C++.
Memory: 148.41 mb, beating 56.77% of leetcode users solutions using C++.

#### Concepts Applied:

Two pointers, unordered map, sliding window technique, and while loops. 

### Solution March 29, 2024 (C++, leetcode) 2962. Count Subarrays Where Max Element Appears at Least K Times (Medium)
In .LeetcodeDailySolution folder as March29,2024.cpp

#### Prompt:

You are given an integer array nums and a positive integer k.

Return the number of subarrays where the maximum element of nums appears at least k times in that subarray.

A subarray is a contiguous sequence of elements within an array.

#### Solution:

    class Solution {
    public:
    long long countSubarrays(vector<int>& nums, int k) {

        int n = nums.size();
        int maxe =* max_element(nums.begin(), nums.end());
        long long ans = 0;
        
        int count = 0; 
        int i = 0, j = 0;

        while(j < n) {

            count += (nums[j] == maxe);
            
            while(i <= j && count >= k) {

                ans += (n - j);
                count -= (nums[i] == maxe); 
                i++;
            }
            j++;
        }
        return ans;
      }
    };

Runtime: 127 ms, beating 72.46% of leetcode users solutions using C++.
Memory: 120.04 mb, beating 61.72% of leetcode users solutions using C++.

#### Concepts Applied:

Sliding window, subarray, and while loops. 

### Solution March 30, 2024 (C++, leetcode) 992. Subarrays with K Different Integers (Hard)
In .LeetcodeDailySolution folder as March30,2024.cpp

#### Prompt:

Given an integer array nums and an integer k, return the number of good subarrays of nums.

A good array is an array where the number of different integers in that array is exactly k.

For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.
A subarray is a contiguous part of an array.

#### Solution:

    class Solution {
    public:
    int countSubarraysWithAtMostKDistinct(vector<int>& nums, int k){

        int n = nums.size();
        unordered_map<int, int> mp;
        int i = 0, j = 0;
        int c = 0;
        
        while(j < n){
            mp[nums[j]]++;
            
            while(i <= j && mp.size() > k){
                if(--mp[nums[i]] == 0) mp.erase(nums[i]);
                i++;
            }
            c += (j - i + 1);
            j++;
        }
        return c;
    }
    int subarraysWithKDistinct(vector<int>& nums, int k) {

        return countSubarraysWithAtMostKDistinct(nums, k) - countSubarraysWithAtMostKDistinct(nums, k - 1);
      }
    };

Runtime: 103 ms, beating 70.64% of leetcode users solutions using C++.
Memory: 49.80 mb, beating 56.74% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, unordered map, sliding window, while loops, and if statement.

### Solution March 31, 2024 (C++, leetcode) 2444. Count Subarrays With Fixed Bounds (Hard)
In .LeetcodeDailySolution folder as March31,2024.cpp

#### Prompt:

You are given an integer array nums and two integers minK and maxK.

A fixed-bound subarray of nums is a subarray that satisfies the following conditions:

The minimum value in the subarray is equal to minK.
The maximum value in the subarray is equal to maxK.
Return the number of fixed-bound subarrays.

A subarray is a contiguous part of an array.

#### Solution:

    class Solution {
    public:
    long long countSubarrays(vector<int>& nums, int minK, int maxK) {

        int n = nums.size();
        long long result = 0;
        int minKIndex = -1;  
        int maxKIndex = -1;  
        int culpritIndex = -1; 

        for (int i = 0; i < n; i++) {
            if (nums[i] < minK || nums[i] > maxK) {
                culpritIndex = i;  
            }
            if (nums[i] == minK) {
                minKIndex = i;     
            }
            if (nums[i] == maxK) {
                maxKIndex = i;     
            }
            long long smaller = min(minKIndex, maxKIndex);  
            long long temp = smaller - culpritIndex;        
            result += temp <= 0 ? 0 : temp;          
        }
        return result;
      }
    };

Runtime: 88 ms, beating 63.40% of leetcode users solutions using C++.
Memory: 82.60 mb, beating 54.90% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, two pointers, indexing, for loops, and if statements.

### Solution April 1, 2024 (C++, leetcode) 58. Length of Last Word (Easy)
In .LeetcodeDailySolution folder as April1,2024.cpp

#### Prompt:

Given a string s consisting of words and spaces, return the length of the last word in the string.

A word is a maximal substringconsisting of non-space characters only.

#### Solution:

    class Solution {
    public:
    int lengthOfLastWord(string s) {

        int length = 0;
        bool counting = false;
        
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s[i] != ' ') {
                counting = true;
                length++;
            }
            else if (counting) {
                break;
            }
        }
        return length;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.48 mb, beating 99.31% of leetcode users solutions using C++.

#### Concepts Applied:

String, boolean, for loop, if statement, and else-if statement.

### Solution Apriil 2, 2024 (C++, leetcode) 205. Isomorphic Strings (Easy)
In .LeetcodeDailySolution folder as April2,2024.cpp

#### Prompt:

Given two strings s and t, determine if they are isomorphic.

Two strings s and t are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

#### Solution:

    class Solution {
    public:
    bool isIsomorphic(string s, string t) {

        vector<int> indexS(200, 0); 
        vector<int> indexT(200, 0);
        
        int len = s.length(); 
        
        if(len != t.length()) { 
            return false;
        }
        for(int i = 0; i < len; i++) { 
            if(indexS[s[i]] != indexT[t[i]]) { 
                return false;
            }
            indexS[s[i]] = i + 1; 
            indexT[t[i]] = i + 1;
        }
        return true;
      }
    };

Runtime: 6 ms, beating 65.25% of leetcode users solutions using C++.
Memory: 7.99 mb, beating 98.91% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, integer arrays, hash table, if statements, and for loop.

### Solution April 3, 2024 (C++, leetcode) 79. Word Search (Medium)
In .LeetcodeDailySolution folder as April3,2024.cpp

#### Prompt:

Given an m x n grid of characters board and a string word, return true if word exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

#### Solution:

    class Solution {
    public:
    bool exist(vector<vector<char>>& board, string word) {

        int m = board.size();
        int n = board[0].size();
        
        function<bool(int, int, int)> backtrack = [&](int i, int j, int k) {

            if (k == word.length()) {
                return true;
            }
            if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k]) {
                return false;
            }
            char temp = board[i][j];
            board[i][j] = '\0';
            
            if (backtrack(i + 1, j, k + 1) || backtrack(i - 1, j, k + 1) || 
                backtrack(i, j + 1, k + 1) || backtrack(i, j - 1, k + 1)) {
                return true;
            }
            board[i][j] = temp; 
            return false;
        };
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (backtrack(i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
      }
    };

Runtime: 779 ms, beating 48.98% of leetcode users solutions using C++.
Memory: 10.47 mb, beating 70.64% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean, recursion (recursive function: backtrack), if statements, chars, and for loops, 

### Solution April 4, 2024 (C++, leetcode) 1614. Maximum Nesting Depth of the Parentheses (Easy)
In .LeetcodeDailySolution folder as April4,2024.cpp

#### Prompt:

A string is a valid parentheses string (denoted VPS) if it meets one of the following:

It is an empty string "", or a single character not equal to "(" or ")",
It can be written as AB (A concatenated with B), where A and B are VPS's, or
It can be written as (A), where A is a VPS.
We can similarly define the nesting depth depth(S) of any VPS S as follows:

depth("") = 0
depth(C) = 0, where C is a string with a single character not equal to "(" or ")".
depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's.
depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
For example, "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.

Given a VPS represented as string s, return the nesting depth of s.

#### Solution:

    class Solution {
    public:
    int maxDepth(string& s) {

        int ans = 0, p = 0;

        transform(s.begin(), s.end(), s.begin(), [&](char c){

            p += (c == '(') - (c == ')');

            return ans = max(ans, p);
        });
        return ans;  
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.27 mb, beating 96.47% of leetcode users solutions using C++.

#### Concepts Applied:

String, transform, and char.

### Solution April 5, 2024 (C++, leetcode) 1544. Make The String Great (Easy)
In .LeetcodeDailySolution folder as April5,2024.cpp

#### Prompt:

Given a string s of lower and upper case English letters.

A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:

0 <= i <= s.length - 2
s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.
To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.

Return the string after making it good. The answer is guaranteed to be unique under the given constraints.

Notice that an empty string is also good.

#### Solution:

    class Solution {
    public:
    string makeGood(string s) {

        int endPosition = 0; 
        char charArray[s.size()]; 
        
        for (int i = 0; i < s.size(); ++i) {
            charArray[i] = s[i];
        }
        for (int currentPosition = 0; currentPosition < s.size(); currentPosition++) {
            if (endPosition > 0 && abs(charArray[currentPosition] - charArray[endPosition - 1]) == 32)
                endPosition--;
            else {
                charArray[endPosition] = charArray[currentPosition];
                endPosition++;
            }
        }
        return string(charArray, charArray + endPosition);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.47 mb, beating 98.66% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, two pointers, charArray, for loops, if statement, and else statement.

### Solution April 6, 2024 (C++, leetcode) 1249. Minimum Remove to Make Valid Parentheses (Medium)
In .LeetcodeDailySolution folder as April6,2024.cpp

#### Prompt:

Given a string s of '(' , ')' and lowercase English characters.

Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:

It is the empty string, contains only lowercase characters, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.

#### Solution:

    class Solution {
    public:
    string minRemoveToMakeValid(std::string s) {

        int leftCount = 0;
        int rightCount = 0;
        stack<char> stack;

        for (char ch : s) {
            if (ch == '(') {
                leftCount++;
            } else if (ch == ')') {
                rightCount++;
            }
            if (rightCount > leftCount) {
                rightCount--;
                continue;
            } else {
                stack.push(ch);
            }
        }
        string result = "";
        
        while (!stack.empty()) {

            char currentChar = stack.top();
            stack.pop();

            if (leftCount > rightCount && currentChar == '(') {
                leftCount--;
            } else {
                result += currentChar;
            }
        }
        reverse(result.begin(), result.end());
        return result;
      }
    };

Runtime: 19 ms, beating 75.25% of leetcode users solutions using C++.
Memory: 12.96 mb, beating 50.73% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, stack, for loop, if statements, else statements, else-if statement, while loop, and char.

### Solution April 7, 2024 (C++, leetcode) 678. Valid Parenthesis String (Medium)
In .LeetcodeDailySolution folder as April7,2024.cpp

#### Prompt:

Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.

The following rules define a valid string:

Any left parenthesis '(' must have a corresponding right parenthesis ')'.
Any right parenthesis ')' must have a corresponding left parenthesis '('.
Left parenthesis '(' must go before the corresponding right parenthesis ')'.
'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string "".

#### Solution:

    class Solution {
    public:
    bool checkValidString(string s) {
        int leftMin = 0, leftMax = 0;

        for (char c : s) {
            if (c == '(') {
                leftMin++;
                leftMax++;
            } else if (c == ')') {
                leftMin--;
                leftMax--;
            } else {
                leftMin--;
                leftMax++;
            }
            if (leftMax < 0) return false;
            if (leftMin < 0) leftMin = 0;
        }
        
        return leftMin == 0;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.16 mb, beating 92.43% of leetcode users solutions using C++.

#### Concepts Applied:

String, greedy, for loop, if statements, else-if statement, and else statement.

### Solution April 8, 2024 (C++, leetcode) 1700. Number of Students Unable to Eat Lunch (Easy)
In .LeetcodeDailySolution folder as April8,2024.cpp

#### Prompt:

The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.

The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:

If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.
Otherwise, they will leave it and go to the queue's end.
This continues until none of the queue students want to take the top sandwich and are thus unable to eat.

You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.

#### Solution:

    class Solution {
    public:
    int countStudents(vector<int>& students, vector<int>& sandwiches) {

        int n = students.size(), p[2] = {0};
        p[0] = count(students.begin(), students.end(), 0), p[1] = n - p[0];
        
        for (int x: sandwiches){
            if (p[x] == 0) return p[1-x];
            p[x]--;
        }
        return 0;
      }
    };

Runtime: 2 ms, beating 50.32% of leetcode users solutions using C++.
Memory: 10.86 mb, beating 50.13% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, count, for loop, and if statement.

### Solution April 9, 2024 (C++, leetcode) 2073. Time Needed to Buy Tickets (Easy)
In .LeetcodeDailySolution folder as April9,2024.cpp

#### Prompt:

There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.

You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].

Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.

Return the time taken for the person at position k (0-indexed) to finish buying tickets.

#### Solution:

    class Solution {
    public:
    int timeRequiredToBuy(vector<int>& tickets, int k) {

        int n = tickets.size();
        int x = tickets[k];
        int time = 0;
        int buy[2] = {x, x - 1};

        for(int i = 0; i < n; i++){
            time += min(buy[i > k], tickets[i]);
        }
        return time;           
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.38 mb, beating 67.22% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, simulation, and for loop.

### Solution April 10, 2024 (C++, leetcode) 950. Reveal Cards In Increasing Order (Medium)
In .LeetcodeDailySolution folder as April10,2024.cpp

#### Prompt:

You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].

You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.

You will do the following steps repeatedly until all cards are revealed:

Take the top card of the deck, reveal it, and take it out of the deck.
If there are still cards in the deck then put the next top card of the deck at the bottom of the deck.
If there are still unrevealed cards, go back to step 1. Otherwise, stop.
Return an ordering of the deck that would reveal the cards in increasing order.

Note that the first entry in the answer is considered to be the top of the deck.

#### Solution:

    class Solution {
    public:
    vector<int> deckRevealedIncreasing(vector<int>& deck) {

        int n = deck.size();
        vector<int> result(n);
        deque<int> indices;

        for (int i = 0; i < n; i++) {
            indices.push_back(i);
        }
        sort(deck.begin(), deck.end());

        for (int card : deck) {
            result[indices.front()] = card;
            indices.pop_front();
            if (!indices.empty()) {
                indices.push_back(indices.front());
                indices.pop_front();
            }
        }
        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.96 mb, beating 34.06% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, deque, simulation, for loops, sorting, and if statements.

### Solution April 11, 2024 (C++, leetcode) 402. Remove K Digits (Medium)
In .LeetcodeDailySolution folder as April11,2024.cpp

#### Prompt:

Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.

#### Solution:

    class Solution {
    public:
    string removeKdigits(string num, int k) {
        stack<char> numStack;
        
        for (char digit : num) {
            while (k > 0 && !numStack.empty() && digit < numStack.top()) {
                numStack.pop();
                k--;
            }
            if(numStack.empty() && digit=='0')
                continue;
            numStack.push(digit);
        }        
        while (k > 0 && !numStack.empty()) {
            numStack.pop();
            k--;
        }
        string temp = "";

        while (!numStack.empty()) {
            temp.push_back(numStack.top());
            numStack.pop();
        }
        reverse(temp.begin(), temp.end());

        if (temp.size() == 0)
            temp.push_back('0');
        return temp;
      }
    };

Runtime: 7 ms, beating 90.50% of leetcode users solutions using C++.
Memory: 9.94 mb, beating 60.42% of leetcode users solutions using C++.

#### Concepts Applied:

String, monotonic stack, for loop, while loops, if statements, and reverse. 

### Solution April 12, 2024 (C++, leetcode) 42. Trapping Rain Water (Hard)
In .LeetcodeDailySolution folder as April12,2024.cpp

#### Prompt:

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

#### Solution:

    class Solution {
    public:
    int trap(vector<int>& height) {

        int i = 0, left_max = height[0], sum = 0;
        int j = height.size() - 1, right_max = height[j];

        while (i < j) {
            if (left_max <= right_max) {
                sum += (left_max - height[i]);
                i++;
                left_max = max(left_max, height[i]);
            } else {
                sum += (right_max - height[j]);
                j--;
                right_max = max(right_max, height[j]);
            }
        }
        return sum;
      }
    };

Runtime: 11 ms, beating 54.15% of leetcode users solutions using C++.
Memory: 22.17 mb, beating 95.62% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, two pointers, while loop, if statement, and else statement.

### Solution April 13, 2024 (C++, leetcode) 85. Maximal Rectangle (Hard)
In .LeetcodeDailySolution folder as April13,2024.cpp

#### Prompt:

Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

#### Solution:

    class Solution {
    public:
    int largestRectangleArea(vector<int>& heights, int n) {

        if (n == 0)
            return 0;

        vector<int> l(n), r(n);
        r[n - 1] = n;
        l[0] = -1;

        for (int i = 1; i < n; i++) {

            int p = i - 1;

            while (p >= 0 && heights[p] >= heights[i])
                p = l[p];
                
            l[i] = p;
        }
        int maxA = heights[n - 1] * (r[n - 1] - l[n - 1] - 1);

        for (int i = n - 2; i >= 0; i--) {

            int p = i + 1;

            while (p < n && heights[p] >= heights[i])
                p = r[p];

            r[i] = p;

            maxA = max(maxA, heights[i] * (r[i] - l[i] - 1));
        }
        return maxA;
    }
    int maximalRectangle(vector<vector<char>>& matrix) {

        const unsigned short row = matrix.size();
        const unsigned short col = matrix[0].size();

        if (row == 1 && col == 1)
            return matrix[0][0] == '1';

        vector<int> h(col);
        int maxArea = 0;

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                h[j] = (matrix[i][j] == '0') ? 0 : h[j] + 1;
            }
            maxArea = max(maxArea, largestRectangleArea(h, col));
        }
        return maxArea;
      }
    };

Runtime: 23 ms, beating 95.04% of leetcode users solutions using C++.
Memory: 17.56 mb, beating 66.98% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, if statements, for loops, while loops, dynamic programming, and matrix.

### Solution April 14, 2024 (C++, leetcode) 404. Sum of Left Leaves (Easy)
In .LeetcodeDailySolution folder as April14,2024.cpp

#### Prompt:

Given the root of a binary tree, return the sum of all left leaves.

A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.

#### Solution:

    class Solution {
    public:
    int sumOfLeftLeaves(TreeNode* root) {

        if (!root)
            return 0;
        
        int ans = 0;
        
        if (root -> left) {
            if (!root -> left -> left && !root -> left -> right)
                ans += root -> left -> val;
            else
                ans += sumOfLeftLeaves(root -> left);
        }
        ans += sumOfLeftLeaves(root -> right);
        
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 14.70 mb, beating 81.75% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, if statements, recursion, and else statement.

### Solution April 15, 2024 (C++, leetcode) 129. Sum Root to Leaf Numbers (Medium) 
In .LeetcodeDailySolution folder as April15,2024.cpp

#### Prompt:

You are given the root of a binary tree containing digits from 0 to 9 only.

Each root-to-leaf path in the tree represents a number.

For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.

A leaf node is a node with no children.

#### Solution:

    class Solution {
    public:
    int sumNumbers(TreeNode* root) {

        int ans = 0;
        
        function<void(TreeNode*, int)> dfs = [&](TreeNode* node, int path) {
            if (!node) return;
            if (!node->left && !node->right) {
                ans += path * 10 + node->val;
                return;
            }
            dfs(node->left, path * 10 + node->val);
            dfs(node->right, path * 10 + node->val);
        };
        dfs(root, 0);
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.10 mb, beating 31.40% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, depth first search, and if statements.

### Solution April 16, 2024 (C++, leetcode) 623. Add One Row to Tree (Medium)
In .LeetcodeDailySolution folder as April16,2024.cpp

#### Prompt:

Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.

Note that the root node is at depth 1.

The adding rule is:

Given the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root.
cur's original left subtree should be the left subtree of the new left subtree root.
cur's original right subtree should be the right subtree of the new right subtree root.
If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root's left subtree.

#### Solution:

    class Solution {
    public:
    TreeNode* addOneRow(TreeNode* root, int val, int depth, bool isLeft=1) {

    if (!root) return root;
    switch(depth){
        case 1:
            if (isLeft) return new TreeNode(val, root, NULL);
            else return new TreeNode(val, NULL, root);
        break;
        case 2:
            root->left=new TreeNode(val, root->left, NULL);
            root->right=new TreeNode(val, NULL, root->right);
        break;
        default:
            root->left=addOneRow(root->left, val, depth-1);
            root->right=addOneRow(root->right, val, depth-1, 0);
    }
    return root;
      }
    };

Runtime: 7 ms, beating 95.54% of leetcode users solutions using C++.
Memory: 24.20 mb, beating 95.92% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, recursive breadth-first search, if statement, switch, and break.

### Solution April 17, 2024 (C++, leetcode) 988. Smallest String Starting From Leaf (Medium)
In .LeetcodeDailySolution folder as April17,2024.cpp

#### Prompt:

You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.

Return the lexicographically smallest string that starts at a leaf of this tree and ends at the root.

As a reminder, any shorter prefix of a string is lexicographically smaller.

For example, "ab" is lexicographically smaller than "aba".
A leaf of a node is a node that has no children.

#### Solution:

    class Solution {
    private:

    string res = "~"; 

    void dfs(TreeNode* root, string str) {

        if(root == nullptr){
            return;
        }
        str = char('a' + root->val) + str;

        if(root->left == nullptr && root->right == nullptr){
            res = min(res, str);       
        }
        dfs(root->left, str);
        dfs(root->right, str);
    }
    public:
    string smallestFromLeaf(TreeNode* root) {
        dfs(root, "");
        
        return res;
      }
    };

Runtime: 4 ms, beating 90.65% of leetcode users solutions using C++.
Memory: 20.40 mb, beating 50.79% of leetcode users solutions using C++.

#### Concepts Applied:

String, tree, if statements, and depth-first search.

### Solution April 18, 2024 (C++, leetcode) 463. Island Perimeter (Easy)
In .LeetcodeDailySolution folder as April18,2024.cpp

#### Prompt:

You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.

Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).

The island doesn't have "lakes", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.

#### Solution:

    class Solution {
    private:
    inline int getCellPerimeter(int x, int y, vector<vector<int>>& grid) {
        int cellPerimiter = 4;

        if (x > 0 && grid[x-1][y] == 1) cellPerimiter -= 2;
        if (y > 0 && grid[x][y-1] == 1) cellPerimiter -= 2;

        return cellPerimiter;
    }

    public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int islandPerimeter = 0;

        for (int i = 0; i < grid.size(); ++i) {
            for (int j = 0; j < grid[0].size(); ++j) {
                if (grid[i][j] == 1) {
                    islandPerimeter += getCellPerimeter(i, j, grid); 
                }
            }
        }

        return islandPerimeter;
      }
    };

Runtime: 68 ms, beating 75.91% of leetcode users solutions using C++.
Memory: 100.79 mb, beating 76.51% of leetcode users solutions using C++.

#### Concepts Applied:

If statements, grid, and for loops.

### Solution April 19, 2024 (C++, leetcode) 200. Number of Islands (Medium)
In .LeetcodeDailySolution folder as April19,2024.cpp

#### Prompt:

Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

#### Solution:

    class Solution {
    public:
    int numIslands(vector<vector<char>>& grid) {
        if(grid.empty() || grid[0].empty())
            return 0;
        
        int rows = grid.size();
        int cols = grid[0].size();
        int islands = 0;
        
        function<void(int, int)> dfs = [&](int row, int col) {
            if(row < 0 || col < 0 || row >= rows || col >= cols || grid[row][col] != '1')
                return;
            grid[row][col] = '0';
            dfs(row - 1, col);
            dfs(row + 1, col);
            dfs(row, col - 1);
            dfs(row, col + 1);
        };
        for(int row = 0; row < rows; row++) {
            for(int col = 0; col < cols; col++) {
                if(grid[row][col] == '1') {
                    dfs(row, col);
                    islands++;
                }
            }
        }
        return islands;
      }
    };

Runtime: 26 ms, beating 77.04% of leetcode users solutions using C++.
Memory: 16.74 mb, beating 48.78% of leetcode users solutions using C++.

#### Concepts Applied:

2D Grid, depth-first search, if statemnts, and for loops.

### Solution April 20, 2024 (C++, leetcode) 1992. Find All Groups of Farmland (Medium)
In .LeetcodeDailySolution folder as April20,2024.cpp

#### Prompt:

You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.

To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.

land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].

Return a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> findFarmland(vector<vector<int>>& land) {

        vector<vector<int>> result;
        int m = land.size();
        int n = land[0].size();
        
        auto findFarmlandCoordinates = [&](int row, int col) {

            vector<int> coordinates = {row, col};
            int r = row, c = col;
            
            while (r < m && land[r][col] == 1) r++;
            while (c < n && land[row][c] == 1) c++;
            
            coordinates.push_back(r - 1);
            coordinates.push_back(c - 1);
            
            for (int i = row; i <= r - 1; i++) {
                for (int j = col; j <= c - 1; j++) {
                    land[i][j] = 0;
                }
            }
            return coordinates;
        };
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (land[i][j] == 1) {
                    result.push_back(findFarmlandCoordinates(i, j));
                }
            }
        }
        return result;
      }
    };

Runtime: 117 ms, beating 50.16% of leetcode users solutions using C++.
Memory: 63.36 mb, beating 77.02% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, 2D matrix, while loops, for loops, and if statements. 

### Solution April 21, 2024 (C++, leetcode) 1971. Find if Path Exists in Graph (Easy)
In .LeetcodeDailySolution folder as April21,2024.cpp

#### Prompt:

There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.

You want to determine if there is a valid path that exists from vertex source to vertex destination.

Given edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.

#### Solution:

    class Solution {
    public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {

        if (n == 1) return true;
        vector<bool> visited(n, false);
        visited[source] = true;
        bool flag = true;
        
        while (flag) {
            flag = false;
            for (const auto& edge : edges) {
                if (visited[edge[0]] != visited[edge[1]]) {
                    visited[edge[0]] = true;
                    visited[edge[1]] = true;
                    flag = true;
                }
                if (visited[destination]) return true;
            }
        }
        return false;
      }
    };

Runtime: 258 ms, beating 97.52% of leetcode users solutions using C++.
Memory: 118.75 mb, beating 100% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean, depth-first search, if statements, integer arrays, while loop, and for loop. 

### Solution April 22, 2024 (C++, leetcode) 752. Open the Lock (Medium)
In .LeetcodeDailySolution folder as April22,2024.cpp

#### Prompt:

You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.

The lock initially starts at '0000', a string representing the state of the 4 wheels.

You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.

Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.

#### Solution:

    class Solution {
    public:
    static int openLock(vector<string>& deadends, const string& target) {

        bitset<10000> seen = 0;

        for(string& s: deadends){
            seen[stoi(s)] = 1;
        }

        if (seen[0]) return -1;

        queue<pair<short, short>> q;
        q.emplace(0, 0);
        seen[0] = 1;
        short z = stoi(target);
        const short dec[4] = {1, 10, 100,1000};
        const char move[2][10] = {
            {1,2,3,4,5,6,7,8,9,0},
            {9,0,1,2,3,4,5,6,7,8}
        };
        while(!q.empty()){

            auto [turn, s] = q.front(); q.pop();

            if (s == z) return turn;
            short digit, t = s;

            for(short d = 0; d < 4; d++){
                digit = t % 10, t /= 10;
                for(short i: {0, 1}){
                    short dnext = move[i][digit];
                    short x = s + (dnext - digit) * dec[d];
                    if (!seen[x]) {
                        q.emplace(turn + 1, x);
                        seen[x] = 1;
                    }
                }
            }
        }
        return -1;
      }
    };

Runtime: 17 ms, beating 98.71% of leetcode users solutions using C++.
Memory: 13.64 mb, beating 99.60% of leetcode users solutions using C++.

#### Concepts Applied:

String arrays, bitset, for loops, if statements, queue, pair, and while loop.

### Solution April 23, 2024 (C++, leetcode) 310. Minimum Height Trees (Medium)
In .LeetcodeDailySolution folder as April23,2024.cpp

#### Prompt:

A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.

Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).

Return a list of all MHTs' root labels. You can return the answer in any order.

The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.

#### Solution:

    class Solution {
    public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        if (n == 1) return {0};
    
        vector<list<int>> adjacency_list(n);
        vector<int> degree(n, 0);

        for (auto& edge : edges) {
            int u = edge[0], v = edge[1];
            adjacency_list[u].push_back(v);
            adjacency_list[v].push_back(u);
            degree[u]++;
            degree[v]++;
        }
        queue<int> leaves;

        for (int i = 0; i < n; ++i) {
            if (degree[i] == 1) leaves.push(i);
        }
        int remainingNodes = n;

        while (remainingNodes > 2) {
            int leavesCount = leaves.size();
            remainingNodes -= leavesCount;
            for (int i = 0; i < leavesCount; ++i) {
                int leaf = leaves.front();
                leaves.pop();
                for (int neighbor : adjacency_list[leaf]) {
                    if (--degree[neighbor] == 1) {
                        leaves.push(neighbor);
                    }
                }
            }
        }
        vector<int> result;
        
        while (!leaves.empty()) {
            result.push_back(leaves.front());
            leaves.pop();
        }
        return result;
      }
    };

Runtime: 101 ms, beating 82.73% of leetcode users solutions using C++.
Memory: 60.04 mb, beating 52.56% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, breadth-first search, if statements, list, for loops, queue, and while loops. 

### Solution April 24, 2024 (C++, leetcode) 1137. N-th Tribonacci Number (Easy)
In .LeetcodeDailySolution folder as April24,2024.cpp

#### Prompt:

The Tribonacci sequence Tn is defined as follows: 

T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.

Given n, return the value of Tn.

#### Solution:

    class Solution {
    public:
    int tribonacci(int n) {
         
        if (n == 0) return 0;

        else if (n <= 2) return 1;

        tuple<int, int, int> t = {0, 1, 1};
         
        for(int i = 3; i <= n; i++){
            auto [x, y, z] = t;
            t = {y, z, x + y + z};
        }            
        return get<2>(t);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.06 mb, beating 81.43% of leetcode users solutions using C++.

#### Concepts Applied:

If statement, else-if statement, tuple, and for loop.

### Solution April 25, 2024 (C++, leetcode) 2370. Longest Ideal Subsequence (Medium)
In .LeetcodeDailySolution folder as April25,2024.cpp

#### Prompt:

You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:

t is a subsequence of the string s.
The absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.
Return the length of the longest ideal string.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

Note that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.

#### Solution:

    class Solution {
    public:
    int longestIdealString(string& s, int k) {

        int seq[26] = {0};
        int ans = 0;

        for(char c: s){
            int i = c-'a';
            int j0 = max(0, i - k),  j1 = min(i + k, 25);

            for(int j = j0; j <= j1; j++)
                seq[i] = max(seq[i], seq[j]);
            seq[i]++;
        }
        return *max_element(seq, seq + 26);   
      }
    };

Runtime: 41 ms, beating 83.26% of leetcode users solutions using C++.
Memory: 10.36 mb, beating 100% of leetcode users solutions using C++.

#### Concepts Applied:

String, dynamic programming, and for loops.

### Solution April 26, 2024 (C++, leetcode) 1289. Minimum Falling Path Sum II (Hard)
In .LeetcodeDailySolution folder as April26,2024.cpp

#### Prompt:

Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.

A falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.

#### Solution:

    class Solution {
    public:
    int minFallingPathSum(vector<vector<int>>& grid) {

        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> dp(n, vector<int>(m, 0));

        for (int j = 0; j < m; ++j) {
            dp[n - 1][j] = grid[n - 1][j];
        }
        for (int i = n - 2; i >= 0; --i) {
            for (int j = 0; j < m; ++j) {

                int minNextRow = INT_MAX;

                for (int k = 0; k < m; ++k) {
                    if (k != j) {
                        minNextRow = min(minNextRow, dp[i + 1][k]);
                    }
                }
                dp[i][j] = grid[i][j] + minNextRow;
            }
        }
        int ans = *min_element(dp[0].begin(), dp[0].end());

        return ans;
      }
    };

Runtime: 127 ms, beating 68.68% of leetcode users solutions using C++.
Memory: 18.09 mb, beating 67.90% of leetcode users solutions using C++.

#### Concepts Applied:

Grid, dynamic programming, recursion, for loops, and if statement. 

### Solution April 27, 2024 (C++, leetcode) 514. Freedom Trail (Hard)
In .LeetcodeDailySolution folder as April27,2024.cpp

#### Prompt:

In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring" and use the dial to spell a specific keyword to open the door.

Given a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword.

Initially, the first character of the ring is aligned at the "12:00" direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the "12:00" direction and then by pressing the center button.

At the stage of rotating the ring to spell the key character key[i]:

You can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring's characters at the "12:00" direction, where this character must equal key[i].
If the character key[i] has been aligned at the "12:00" direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.

#### Solution:

    class Solution {
    public:
    int findRotateSteps(string ring, string key) {

        if (ring.empty() || key.empty()) {
            return 0;
        }
        unordered_map<char, vector<int>> ringMap;
        
        for (int i = 0; i < ring.size(); i++) {
            ringMap[ring[i]].push_back(i);
        }
        vector<int> dp(ring.size(), INT_MAX);

        for (int i : ringMap[key[0]]) {
            dp[i] = min(i, (int)ring.size() - i) + 1;
        }
        for (int i = 1; i < key.size(); i++) {

            vector<int> new_dp(ring.size(), INT_MAX);

            for (int j : ringMap[key[i]]) {
                for (int k : ringMap[key[i - 1]]) {
                    new_dp[j] = min(new_dp[j], dp[k] + min(abs(j - k), (int)ring.size() - abs(j - k)) + 1);
                }
            }
            dp = move(new_dp);
        }
        return *min_element(dp.begin(), dp.end());
      }
    };

Runtime: 11 ms, beating 78.30% of leetcode users solutions using C++.
Memory: 15.80 mb, beating 47.64% of leetcode users solutions using C++.

#### Concepts Applied:

Dynamic programming, hash maps, if statements, and for loops.

### Solution April 28, 2024 (C++, leetcode) 834. Sum of Distances in Tree (Hard)
In .LeetcodeDailySolution folder as April28,2024.cpp

#### Prompt:

There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.

You are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

Return an array answer of length n where answer[i] is the sum of the distances between the ith node in the tree and all other nodes.

#### Solution:

    class Solution {
    private:

    vector<vector<int>> graph;
    vector<int> count;
    vector<int> res;
    int N;

    public:
    vector<int> sumOfDistancesInTree(int N, vector<vector<int>>& edges) {

        this -> N = N;
        res.resize(N);
        graph.resize(N);
        count.resize(N);

        for (auto& e : edges) {
            ++count[e[0]];
            ++count[e[1]];
        }
        for (int i = 0; i < N; i++) {
            graph[i].resize(count[i]);
        }
        for (auto& e : edges) {
            graph[e[0]][--count[e[0]]] = e[1];
            graph[e[1]][--count[e[1]]] = e[0];
        }
        dfs1(0, -1);
        dfs2(0, -1);

        return res;
    }
    private:

    void dfs1(int cur, int parent) {

        count[cur] = 1;

        for (int child : graph[cur]) {
            if (child != parent) {

                dfs1(child, cur);
                count[cur] += count[child];
                res[cur] += res[child] + count[child];
            }
        }
    }
    void dfs2(int cur, int parent) {

        for (int child : graph[cur]) {
            if (child != parent) {

                res[child] = res[cur] + N - 2 * count[child];
                dfs2(child, cur);
            }
        }
      }.
    };

Runtime: 175 ms, beating 94.33% of leetcode users solutions using C++.
Memory: 88.79 mb, beating 98.52% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, pointers, depth-first search, for loops, and if statements.	

### Solution April 29, 2024 (C++, leetcode) 2997. Minimum Number of Operations to Make Array XOR Equal to K (Medium)
In .LeetcodeDailySolution folder as April29,2024.cpp

#### Prompt:

You are given a 0-indexed integer array nums and a positive integer k.

You can apply the following operation on the array any number of times:

Choose any element of the array and flip a bit in its binary representation. Flipping a bit means changing a 0 to 1 or vice versa.
Return the minimum number of operations required to make the bitwise XOR of all elements of the final array equal to k.

Note that you can flip leading zero bits in the binary representation of elements. For example, for the number (101)2 you can flip the fourth bit and obtain (1101)2.

#### Solution:

    class Solution {
    public:
    int minOperations(vector<int>& nums, int k) {


        int ans = 0;
        for (auto& x : nums) {
            ans = ans ^ x;
        }
        ans = ans ^ k;

        int res = 0;
        
        while (ans > 0) {
            if (ans & 1)1
                res++;
            ans = ans >> 1;
        }
        return res;
      }
    };

Runtime: 98 ms, beating 91.20% of leetcode users solutions using C++.
Memory: 91.30 mb, beating 55.11% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, bit manipulation, for loop, while loop, and if statement.

### Solution April 30, 2024 (C++, leetcode) 1915. Number of Wonderful Substrings (Medium)
In .LeetcodeDailySolution folder as April30,2024.cpp

#### Prompt:

A wonderful string is a string where at most one letter appears an odd number of times.

For example, "ccjjc" and "abab" are wonderful, but "ab" is not.
Given a string word that consists of the first ten lowercase English letters ('a' through 'j'), return the number of wonderful non-empty substrings in word. If the same substring appears multiple times in word, then count each occurrence separately.

A substring is a contiguous sequence of characters in a string.

#### Solution:

    class Solution {
    public:
    int get(char c) {
        
        return c - 'a';
    }

    long long wonderfulSubstrings(string word) {

        vector<long long> cnt(1024, 0);
        cnt[0] = 1;
        int curState = 0;
        long long res = 0;

        for (char c : word) {
            
            curState ^= 1 << get(c);
            res += cnt[curState];

            for (char odd = 'a'; odd <= 'j'; odd++) {
                int oddState = curState ^ (1 << get(odd));
                res += cnt[oddState];
            }
            cnt[curState]++;
        }
        return res;
      }
    };

Runtime: 48 ms, beating 83.23% of leetcode users solutions using C++.
Memory: 16.61 mb, beating 61.08% of leetcode users solutions using C++.

#### Concepts Applied:

String, substring, prefix string, and for loops.

### Solution May 1, 2024 (C++, leetcode) 2000. Reverse Prefix of Word (Easy)
In .LeetcodeDailySolution folder as May1,2024.cpp

#### Prompt:

Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.

For example, if word = "abcdefd" and ch = "d", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be "dcbaefd".
Return the resulting string.

#### Solution:

    class Solution {
    public:
    string reversePrefix(string word, char ch) {
        int ind = word.find(ch);

        if(ind != string::npos){
            reverse(word.begin(), word.begin() + ind + 1);
        }

        return word;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.45 mb, beating 65.41% of leetcode users solutions using C++.

#### Concepts Applied:

String, find, if statement, and reverse.

### Solution May 2, 2024 (C++, leetcode) 2441. Largest Positive Integer With Its Negative (Easy)
In .LeetcodeDailySolution folder as May2,2024.cpp

#### Prompt:

Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.

Return the positive integer k. If there is no such integer, return -1.

#### Solution:

    class Solution {
    public:
    int findMaxK(vector<int>& nums) {

        sort(nums.begin(), nums.end(), [](int & lhs, int & rhs){
            return abs(lhs)<abs(rhs);});

        for (int i = nums.size() - 1; i > 0; i--) {
            if (nums[i] + nums[i - 1] == 0) {
                return abs(nums[i]);
            }
        }
        return -1;
      }
    };

Runtime: 11 ms, beating 94.06% of leetcode users solutions using C++.
Memory: 22.76 mb, beating 79.58% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, absolute value function, for loop, and if statement.

### Solution May 3, 2024 (C++, leetcode) 165. Compare Version Numbers (Medium)
In .LeetcodeDailySolution folder as May3,2024.cpp

#### Prompt:

Given two version numbers, version1 and version2, compare them.

Version numbers consist of one or more revisions joined by a dot '.'. Each revision consists of digits and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example 2.5.33 and 0.1 are valid version numbers.

To compare version numbers, compare their revisions in left-to-right order. Revisions are compared using their integer value ignoring any leading zeros. This means that revisions 1 and 001 are considered equal. If a version number does not specify a revision at an index, then treat the revision as 0. For example, version 1.0 is less than version 1.1 because their revision 0s are the same, but their revision 1s are 0 and 1 respectively, and 0 < 1.

Return the following:

If version1 < version2, return -1.
If version1 > version2, return 1.
Otherwise, return 0.

#### Solution:

    class Solution {
    public:
    int compareVersion(string version1, string version2) {
        
        int i = 0, j = 0;

        while (i < version1.size() || j < version2.size()) {
            int v1 = 0, v2 = 0;

            while (i < version1.size() && version1[i] != '.') {
                v1 = v1 * 10 + (version1[i] - '0');
                i++;
            }
            while (j < version2.size() && version2[j] != '.') {
                v2 = v2 * 10 + (version2[j] - '0');
                j++;
            }
            if (v1 > v2) return 1;

            else if (v1 < v2) return -1;

            i++; 
            j++;
        }
        return 0;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.41 mb, beating 52.59% of leetcode users solutions using C++.

#### Concepts Applied:

String, two pointers, while loops, if statement, and else-if statement.

### Solution May 4, 2024 (C++, leetcode) 881. Boats to Save People (Medium)
In .LeetcodeDailySolution folder as May4,2024.cpp

#### Prompt:

You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.

Return the minimum number of boats to carry every given person.

#### Solution:

    class Solution {
    public:
    int numRescueBoats(vector<int>& people, int limit) {

         sort(people.begin() , people.end());

        int i=0 , boats=0;
        int j=people.size()-1;

        while(i<=j){
            if(people[i]+people[j]<=limit){
                i++;
                j--;
                boats++;
            }
            else{
                boats++;
                j--;
            }
        }
        return boats;
      }
    };

Runtime: 53 ms, beating 79.61% of leetcode users solutions using C++.
Memory: 45.32 mb, beating 85.14% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, two pointers, while loop, if statement, and else-if statement.

### Solution May 5, 2024 (C++, leetcode) 237. Delete Node in a Linked List (Medium)
In .LeetcodeDailySolution folder as May5,2024.cpp

#### Prompt:

There is a singly-linked list head and we want to delete a node node in it.

You are given the node to be deleted node. You will not be given access to the first node of head.

All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.

Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:

The value of the given node should not exist in the linked list.
The number of nodes in the linked list should decrease by one.
All the values before node should be in the same order.
All the values after node should be in the same order.

Custom testing:

For the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.
We will build the linked list and pass the node to your function.
The output will be the entire list after calling your function.

#### Solution:

    class Solution {
    public:
    void deleteNode(ListNode* node) {

        while (node -> next -> next) {
            node -> val = node -> next -> val;
            node = node -> next;
        }
        node -> val = node -> next -> val;
        node -> next = NULL;
      }
    };

Runtime: 3 ms, beating 92.51% of leetcode users solutions using C++.
Memory: 11.27 mb, beating 84.03% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list and while loop.

### Solution May 6, 2024 (C++, leetcode) 2487. Remove Nodes From Linked List (Medium)
In .LeetcodeDailySolution folder as May6,2024.cpp

#### Prompt:

You are given the head of a linked list.

Remove every node which has a node with a greater value anywhere to the right side of it.

Return the head of the modified linked list.

#### Solution:

    class Solution {
    public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* current = head;

        while (current != nullptr) {
            ListNode* nextNode = current -> next;
            current -> next = prev;
            prev = current;
            current = nextNode;
        }
        return prev;
    }
    ListNode* removeNodes(ListNode* head) {

        ListNode* reversedHead = reverseList(head);
        ListNode* current = reversedHead;
        int maxValue = INT_MIN;
        ListNode* prev = nullptr;

        while (current != nullptr) {
            if (current -> val < maxValue) {
                prev -> next = current -> next;
            } else {
                maxValue = current -> val;
                prev = current;
            }
            current = current -> next;
        }
        return reverseList(reversedHead);
      }
    };

Runtime: 242 ms, beating 95.59% of leetcode users solutions using C++.
Memory: 159.88 mb, beating 81.03% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, pointers, while loops, if statement, and else-if statement.

### Solution May 7, 2024 (C++, leetcode) 2816. Double a Number Represented as a Linked List (Medium)
In .LeetcodeDailySolution folder as May7,2024.cpp

#### Prompt:

You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.

Return the head of the linked list after doubling it.

#### Solution:

    class Solution {
    public:
    ListNode* doubleIt(ListNode* head) {

        int carry = twice(head);

        if (carry > 0) {
            head = new ListNode(carry, head);
        }
        return head;
    }
    private:
    int twice(ListNode* head) {

        if (head == nullptr) {
            return 0;
        }
 
        int doubledValue = head -> val * 2 + twice(head -> next);
        head -> val = doubledValue % 10;
        
        return doubledValue / 10;
      }
    };

Runtime: 154 ms, beating 95.20% of leetcode users solutions using C++.
Memory: 121.09 mb, beating 50.42% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, recursion, and if statements.

### Solution May 8, 2024 (C++, leetcode) 506. Relative Ranks (Easy)
In .LeetcodeDailySolution folder as May8,2024.cpp

#### Prompt:

You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.

The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:

The 1st place athlete's rank is "Gold Medal".
The 2nd place athlete's rank is "Silver Medal".
The 3rd place athlete's rank is "Bronze Medal".
For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is "x").
Return an array answer of size n where answer[i] is the rank of the ith athlete.

#### Solution:

    class Solution {
    private:
    int findMax(vector<int>& score) {

        int maxScore = 0;

        for (int s : score) {
            if (s > maxScore) {
                maxScore = s;
            }
        }
        return maxScore;
    }
    public:
    vector<string> findRelativeRanks(vector<int>& score) {

        int N = score.size();
        int M = findMax(score);
        vector<int> scoreToIndex(M + 1, 0);

        for (int i = 0; i < N; i++) {
            scoreToIndex[score[i]] = i + 1;
        }
        const vector<string> MEDALS = {"Gold Medal", "Silver Medal", "Bronze Medal"};
        vector<string> rank(N);
        int place = 1;
        
        for (int i = M; i >= 0; i--) {
            if (scoreToIndex[i] != 0) {
                int originalIndex = scoreToIndex[i] - 1;
                if (place < 4) {
                    rank[originalIndex] = MEDALS[place - 1];
                } else {
                    rank[originalIndex] = to_string(place);
                }
                place++;
            }
        }
        return rank;
      }
    };

Runtime: 3 ms, beating 96.77% of leetcode users solutions using C++.
Memory: 14.38 mb, beating 59.41% of leetcode users solutions using C++.

#### Concepts Applied:

Maximum, mapping, arrays, for loops, if statements, and else statement.

### Solution May 9, 2024 (C++, leetcode) 3075. Maximize Happiness of Selected Children (Medium)
In .LeetcodeDailySolution folder as May9,2024.cpp

#### Prompt:

You are given an array happiness of length n, and a positive integer k.

There are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.

In each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.

Return the maximum sum of the happiness values of the selected children you can achieve by selecting k children.

#### Solution:

    class Solution {
    public:
    long long maximumHappinessSum(vector<int>& happiness, int k) {

        sort(happiness.begin(), happiness.end(), greater<int>());
        
        long long totalHappinessSum = 0;
        int turns = 0;
        
        for(int i = 0; i < k; i++) {
            totalHappinessSum += max(happiness[i] - turns, 0);  
            turns++; 
        }
        return totalHappinessSum;
      }
    };

Runtime: 151 ms, beating 84.37% of leetcode users solutions using C++.
Memory: 107.19 mb, beating 59.71% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, and for loop.

### Solution May 10, 2024 (C++, leetcode) 786. K-th Smallest Prime Fraction (Medium)
In .LeetcodeDailySolution folder as May10,2024.cpp

#### Prompt:

You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.

For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j].

Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].

#### Solution:

    class Solution {
    public:
    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {

        int n = arr.size();
        double left = 0, right = 1.0;
        
        while (left < right){
            double mid = (left + right) / 2;
            
            double maxFraction = 0.0;
            int totalSmallerFractions = 0, numeratorIdx = 0, denominatorIdx = 0;
            int j = 1;
            
            for (int i = 0; i < n - 1; i++){
                while (j < n && arr[i] >= mid * arr[j]){
                    j++;
                }

                totalSmallerFractions += (n - j);
                
                if (j == n) break;
                
                double fraction = static_cast<double>(arr[i]) / arr[j];
                
                if (fraction > maxFraction) {
                  numeratorIdx = i;
                  denominatorIdx = j;
                  maxFraction = fraction;
                }
            }
            if (totalSmallerFractions == k) {
                return {arr[numeratorIdx], arr[denominatorIdx]};
            } else if (totalSmallerFractions > k) {
                right = mid; 
            } else {
                left = mid; 
            }
        }
        return {}; 
      }
    };

Runtime: 7 ms, beating 90.58% of leetcode users solutions using C++.
Memory: 10.71 mb, beating 88.27% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search, fractions, while loop, for loop, if statements, else-if statement, and else statement.

### Solution May 11, 2024 (C++, leetcode) 857. Minimum Cost to Hire K Workers (Hard)
In .LeetcodeDailySolution folder as May11,2024.cpp

#### Prompt:

There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker.

We want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:

Every worker in the paid group must be paid at least their minimum wage expectation.
In the group, each worker's pay must be directly proportional to their quality. This means if a worker’s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.
Given the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10-5 of the actual answer will be accepted.

#### Solution:

    class Solution {
    public:
    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {

        int n = quality.size();
        double minCost = DBL_MAX; 
        double qualityTillNow = 0;
        vector<pair<double, int>> wageQualityRatio;

        for (int i = 0; i < n; ++i) {
            
            wageQualityRatio.emplace_back(
                static_cast<double>(wage[i]) / quality[i], quality[i]);
        }
        sort(wageQualityRatio.begin(), wageQualityRatio.end());
        priority_queue<int> highQualityWorkers;

        for (int i = 0; i < n; ++i) {
            
            double ratio = wageQualityRatio[i].first;
            int qua = wageQualityRatio[i].second;

            qualityTillNow += qua;
            highQualityWorkers.push(qua);

            if (highQualityWorkers.size() > k) {
                qualityTillNow -= highQualityWorkers.top();
                highQualityWorkers.pop();
            }
            if (highQualityWorkers.size() == k) {
                minCost = min(minCost, qualityTillNow * ratio);
            }
        }
        return minCost;
      }
    };

Runtime: 25 ms, beating 69.47% of leetcode users solutions using C++.
Memory: 26.28 mb, beating 75.07% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, for loops, if statements, and max-heap (priority queue).

### Solution May 12, 2024 (C++, leetcode) 2373. Largest Local Values in a Matrix (Easy)
In .LeetcodeDailySolution folder as May12,2024.cpp

#### Prompt:

You are given an n x n integer matrix grid.

Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:

maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1.
In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.

Return the generated matrix.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> largestLocal(vector<vector<int>>& grid) {
        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
        int n = grid.size();
        vector<vector<int>> res(n - 2, vector<int>(n - 2));

        for (int i = 1; i < n - 1; ++i) {
            for (int j = 1; j < n - 1; ++j) {
                int temp = 0;

                for (int k = i - 1; k <= i + 1; ++k) {
                    for (int l = j - 1; l <= j + 1; ++l) {
                        temp = max(temp, grid[k][l]);
                    }
                }

                res[i - 1][j - 1] = temp;
            }
        }

        return res;
      }
    };

Runtime: 8 ms, beating 73.11% of leetcode users solutions using C++.
Memory: 13.56 mb, beating 52.48% of leetcode users solutions using C++.

#### Concepts Applied:

Sliding window, grid, for loops, and array.

### Solution May 13, 2024 (C++, leetcode) 861. Score After Flipping Matrix (Medium) 
In .LeetcodeDailySolution folder as May13,2024.cpp

#### Prompt:

You are given an m x n binary matrix grid.

A move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).

Every row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.

Return the highest possible score after making any number of moves (including zero moves).

#### Solution:

    class Solution {
    public:
    int matrixScore(vector<vector<int>>& grid) {

        int n = grid.size(), m = grid[0].size();
        int res = (1 << (m - 1)) * n;

        for(int j = 1; j < m; ++j) {

            int val = 1 << (m - 1 - j);
            int set = 0;

            for(int i = 0; i < n; ++i) {
                if(grid[i][j] == grid[i][0]) {
                    set++;
                }
            }
            res += max(set, n - set) * val;
        }
        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.05 mb, beating 94.41% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, matrix, grid, and for loops.

### Solution May 14, 2024 (C++, leetcode) 1219. Path with Maximum Gold (Medium)
In .LeetcodeDailySolution folder as May14,2024.cpp

#### Prompt:

In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.

Return the maximum amount of gold you can collect under the conditions:

Every time you are located in a cell you will collect all the gold in that cell.
From your position, you can walk one step to the left, right, up, or down.
You can't visit the same cell more than once.
Never visit a cell with 0 gold.
You can start and stop collecting gold from any position in the grid that has some gold.

#### Solution:

    class Solution {
    public:

    vector<int> roww = {1, -1, 0, 0};
    vector<int> coll = {0, 0, -1, 1};
    int maxGold = 0;

    int dfs(vector<vector<int>>& grid, int x, int y, int n, int m) {

        if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == 0) return 0;
        
        int curr = grid[x][y];
        grid[x][y] = 0;
        int localMaxGold = curr;

        for (int i = 0; i < 4; i++) {
            int newX = x + roww[i];
            int newY = y + coll[i];
            localMaxGold = max(localMaxGold, curr + dfs(grid, newX, newY, n, m));
        }
        grid[x][y] = curr;
        return localMaxGold;
    }
    int getMaximumGold(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] != 0) {
                    maxGold = max(maxGold, dfs(grid, i, j, n, m));
                }
            }
        }
        return maxGold;
      }
    };

Runtime: 142 ms, beating 55.63% of leetcode users solutions using C++.
Memory: 8.87 mb, beating 99.48% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, grid, if statements, and for loops.

### Solution May 15, 2024 (C++, leetcode) 2812. Find the Safest Path in a Grid (Medium)
In .LeetcodeDailySolution folder as May15,2024.cpp

#### Prompt:

You are given a 0-indexed 2D matrix grid of size n x n, where (r, c) represents:

A cell containing a thief if grid[r][c] = 1
An empty cell if grid[r][c] = 0
You are initially positioned at cell (0, 0). In one move, you can move to any adjacent cell in the grid, including cells containing thieves.

The safeness factor of a path on the grid is defined as the minimum manhattan distance from any cell in the path to any thief in the grid.

Return the maximum safeness factor of all paths leading to cell (n - 1, n - 1).

An adjacent cell of cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) and (r - 1, c) if it exists.

The Manhattan distance between two cells (a, b) and (x, y) is equal to |a - x| + |b - y|, where |val| denotes the absolute value of val.

#### Solution:

    class Solution {
    public:
    vector<int> roww = {0, 0, -1, 1};
    vector<int> coll = {-1, 1, 0, 0};

    void bfs(vector<vector<int>>& grid, vector<vector<int>>& score, int n) {

        queue<pair<int, int>> q;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j]) {
                    score[i][j] = 0;
                    q.push({i, j});
                }
            }
        }
        while (!q.empty()) {

            auto t = q.front();
            q.pop();

            int x = t.first, y = t.second;
            int s = score[x][y];

            for (int i = 0; i < 4; i++) {

                int newX = x + roww[i];
                int newY = y + coll[i];

                if (newX >= 0 && newX < n && newY >= 0 && newY < n &&
                    score[newX][newY] > 1 + s) {

                    score[newX][newY] = 1 + s;
                    q.push({newX, newY});
                }
            }
        }
    }

    int maximumSafenessFactor(vector<vector<int>>& grid) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int n = grid.size();
        if (grid[0][0] || grid[n - 1][n - 1])
            return 0;

        vector<vector<int>> score(n, vector<int>(n, INT_MAX));
        bfs(grid, score, n);
        vector<vector<bool>> vis(n, vector<bool>(n, false));

        priority_queue<pair<int, pair<int, int>>> pq;
        pq.push({score[0][0], {0, 0}});

        while (!pq.empty()) {
            auto temp = pq.top().second;
            auto safe = pq.top().first;
            pq.pop();

            if (temp.first == n - 1 && temp.second == n - 1)
                return safe;
            vis[temp.first][temp.second] = true;

            for (int i = 0; i < 4; i++) {
                int newX = temp.first + roww[i];
                int newY = temp.second + coll[i];

                if (newX >= 0 && newX < n && newY >= 0 && newY < n &&
                    !vis[newX][newY]) {
                    int s = min(safe, score[newX][newY]);
                    pq.push({s, {newX, newY}});
                    vis[newX][newY] = true;
                }
            }
        }

        return -1;
      }
    };

Runtime: 238 ms, beating 100% of leetcode users solutions using C++.
Memory: 122.11 mb, beating 91.95% of leetcode users solutions using C++.

#### Concepts Applied:

Breadth-first search, priority queue, Dijkstra's algorithm, for loops, if statements, and while loops. 

### Solution May 16, 2024 (C++, leetcode) 2331. Evaluate Boolean Binary Tree (Easy)
In .LeetcodeDailySolution folder as May16,2024.cpp

#### Prompt:

You are given the root of a full binary tree with the following properties:

Leaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True.
Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND.
The evaluation of a node is as follows:

If the node is a leaf node, the evaluation is the value of the node, i.e. True or False.
Otherwise, evaluate the node's two children and apply the boolean operation of its value with the children's evaluations.
Return the boolean result of evaluating the root node.

A full binary tree is a binary tree where each node has either 0 or 2 children.

A leaf node is a node that has zero children.

#### Solution:

    class Solution {
    public:
    bool helper(TreeNode* root) {
        
        if(root -> val == 0 || root -> val == 1) {
            return root -> val == 1;
        } else if(root -> val == 2) {
            return helper(root -> left) || helper(root -> right);
        } else if(root -> val == 3) {
            return helper(root -> left) && helper(root -> right);
        } 

        return false;
    }

    bool evaluateTree(TreeNode* root) {
        return helper(root);
      }
    };

Runtime: 4 ms, beating 97.35% of leetcode users solutions using C++.
Memory: 17.31 mb, beating 64.62% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, recursion, helper function, if statement, and else-if statements.

### Solution May 18, 2024 (C++, leetcode) 979. Distribute Coins in Binary Tree (Medium)
In .LeetcodeDailySolution folder as May18,2024.cpp

#### Prompt:

You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.

In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.

Return the minimum number of moves required to make every node have exactly one coin.

#### Solution:

    class Solution {
    public:

    int ans;

    int distributeCoins(TreeNode* root) {

        ans = 0;
        countSteps(root);

        return ans;
    }
    int countSteps(TreeNode* root) {

        if (root == nullptr)
            return 0;

        int leftCoins = countSteps(root -> left);
        int rightCoins = countSteps(root -> right);
        ans += abs(leftCoins) + abs(rightCoins);

        return (root -> val - 1) + leftCoins + rightCoins;
      }
    };

Runtime: 3 ms, beating 80.19% of leetcode users solutions using C++.
Memory: 15.47 mb, beating 88.89% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, depth-first search, if statement, and absolute value.

### Solution May 19, 2024 (C++, leetcode) 3068. Find the Maximum Sum of Node Values (Hard)
In .LeetcodeDailySolution folder as May19,2024.cpp

#### Prompt:

There exists an undirected tree with n nodes numbered 0 to n - 1. You are given a 0-indexed 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree. You are also given a positive integer k, and a 0-indexed array of non-negative integers nums of length n, where nums[i] represents the value of the node numbered i.

Alice wants the sum of values of tree nodes to be maximum, for which Alice can perform the following operation any number of times (including zero) on the tree:

Choose any edge [u, v] connecting the nodes u and v, and update their values as follows:
nums[u] = nums[u] XOR k
nums[v] = nums[v] XOR k
Return the maximum possible sum of the values Alice can achieve by performing the operation any number of times.

#### Solution:

    class Solution {
    public:
    long long maximumValueSum(std::vector<int>& nums, int k, std::vector<std::vector<int>>& edges) {

        long long sum = 0;
        long long minExtra = 1000000;
        int count = 0;

        for (int val : nums) {

            if ((val ^ k) > val) {

                sum += (val ^ k);
                minExtra = min(minExtra, static_cast<long long>((val ^ k) - val));
                count++;
                
            } else {

                sum += val;
                minExtra = min(minExtra, static_cast<long long>(val - (val ^ k)));
            }
        }

        if (count % 2 == 0) {

            return sum;

        } else {

            return sum - minExtra;
        }
      }
    };

Runtime: 171 ms, beating 91.22% of leetcode users solutions using C++.
Memory: 125.56 mb, beating 89.41% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, if statements, and else statements. 

### Solution May 20, 2024 (C++, leetcode) 1863. Sum of All Subset XOR Totals (Easy)
In .LeetcodeDailySolution folder as May20,2024.cpp

#### Prompt: 

The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.

For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 

Note: Subsets with the same elements should be counted multiple times.

An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.

#### Solution:

    class Solution {
    public:
    int subsetXORSum(vector<int>& nums) {

        return dfs(nums, 0, 0);
    }
    
    private:
    int dfs(vector<int>& nums, int index, int currentXor) {

        if (index == nums.size()) {
            return currentXor;
        }
        int include = dfs(nums, index + 1, currentXor ^ nums[index]);

        int exclude = dfs(nums, index + 1, currentXor);
        
        return include + exclude;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.23 mb, beating 88.34% of leetcode users solutions using C++.

#### Concepts Applied: 

Arrays, depth-first search, recursion, and if statement.

### Solution May 21, 2024 (C++, leetcode) 78. Subsets (Medium)
In .LeetcodeDailySolution folder as May21,2024.cpp

#### Prompt:

Given an integer array nums of unique elements, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> subsets(vector<int>& nums) {

        vector<vector<int>> result;
        vector<int> curr;

        function<void(int)> explore = [&](int index) {

            if (index == nums.size()) {

                result.push_back(curr);
                
                return;
            }

            curr.push_back(nums[index]);
            explore(index + 1);
            curr.pop_back(); 
            explore(index + 1);

        };

        explore(0);

        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.03 mb, beating 38.49% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, recursion, and if statement.

### Solution May 22, 2024 (C++, leetcode) 131. Palindorme Partitioning (Medium)
In .LeetcodeDailySolution folder as May22,2024.cpp

#### Prompt:

Given a string s, partition s such that every substring of the partition is a palindrome. 
Return all possible palindrome partitioning of s.

#### Solution:

    class Solution {
    public:
    vector<vector<string>> partition(string s) {

        vector<vector<string>> result;
        vector<string> path;
        backtrack(s, 0, path, result);
        
        return result;
    }
    private:
    void backtrack(const string& s, int start, vector<string>& path, vector<vector<string>>& result) {

        if (start == s.length()) {
            result.push_back(path);
            return;
        }
        for (int end = start + 1; end <= s.length(); ++end) {

            if (isPalindrome(s, start, end - 1)) {

                path.push_back(s.substr(start, end - start));
                backtrack(s, end, path, result);
                path.pop_back();
            }
        }
    }
    bool isPalindrome(const string& s, int left, int right) {

        while (left < right) {
            if (s[left++] != s[right--]) {
                return false;
            }
        }
        return true;
      }
    };

Runtime: 66 ms, beating 93.77% of leetcode users solutions using C++.
Memory: 52.78 mb, beating 84.94% of leetcode users solutions using C++.

#### Concepts Applied:

Recursive backtracking, palindromic check, for loop, if statements, and while loop.

### Solution May 23, 2024 (C++, leetcode) 2597. The Number of Beautiful Subsets (Medium)
In .LeetcodeDailySolution folder as May23,2024.cpp

#### Prompt:

You are given an array nums of positive integers and a positive integer k.

A subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.

Return the number of non-empty beautiful subsets of the array nums.

A subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.

#### Solution:

    class Solution {
    public:
    int beautifulSubsets(vector<int>& A, int k) {

        unordered_map<int, int> count;

        for (int a : A) {
            count[a]++;
        }

        function<pair<int, int>(int)> dp = [&](int a) {

            if (count.count(a - k)) {
                auto [dp0, dp1] = dp(a - k);
                return make_pair(dp0 + dp1, dp0 * ((1 << count[a]) - 1));
            } else {
                return make_pair(1, (1 << count[a]) - 1);
            }
        };

        int result = 1;

        for (auto [a, freq] : count) {
            if (!count.count(a + k)) {
                auto [dp0, dp1] = dp(a);
                result *= dp0 + dp1;
            }
        }
        return result - 1;
      }
    };

Runtime: 12 ms, beating 90.63% of leetcode users solutions using C++.
Memory: 37.62 mb, beating 70.88% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered map, for loops, pair, dynamic programming, if statements, and else statement.

### Solution May 24, 2024 (C++, leetcode) 1255. Maximum Score Words Formed by Letters (Hard)
In .LeetcodeDailySolution folder as May24,2024.cpp

#### Prompt:

Given a list of words, list of  single letters (might be repeating) and score of every character.

Return the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times).

It is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively.

#### Solution:

    class Solution {
    public:
    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {

        unordered_map<char, int> lettersCounter;

        for (char letter : letters) {
            lettersCounter[letter]++;
        }
        int totalScore = 0;

        function<void(int, unordered_map<char, int>, int)> explore =
            [&](int index, unordered_map<char, int> letterCounter,
                int currScore) {

                totalScore = max(totalScore, currScore);

                if (index == words.size())
                    return;

                for (int i = index; i < words.size(); ++i) {

                    unordered_map<char, int> tmpCounter = letterCounter;
                    string word = words[i];
                    int wordScore = 0;
                    bool isValid = true;

                    for (char ch : word) {
                        if (tmpCounter[ch] > 0) {
                            tmpCounter[ch]--;
                            wordScore += score[ch - 'a'];
                        } else {
                            isValid = false;
                            break;
                        }
                    }
                    if (isValid) {
                        explore(i + 1, tmpCounter, currScore + wordScore);
                    }
                }
            };
        explore(0, lettersCounter, 0);

        return totalScore;
      }
    };

Runtime: 12 ms, beating 52.23% of leetcode users solutions using C++.
Memory: 19.54 mb, beating 52.62% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered maps, recursion, for loops, if statements, and else statement.

### Solution May 25, 2024 (C++, leetcode) 140. Word Break II (Hard)
In .LeetcodeDailySolution folder as May25,2024.cpp

#### Prompt:

Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.

Note that the same word in the dictionary may be reused multiple times in the segmentation.

#### Solution:

    class Solution {
    public:
    unordered_map<string, vector<string>> dp;

    vector<string> dfs(string s, vector<string>& wordDict) {

        if (dp.count(s) > 0) {
            return dp[s];
        }

        vector<string> ans;

        if (s.empty()) {

            ans.push_back("");
            return ans;
        }

        for (string& w : wordDict) {

            int sz = w.size();

            if (s.substr(0, sz) == w) {

                vector<string> rest = dfs(s.substr(sz), wordDict);

                for (string& r : rest) {

                    ans.push_back(w + (r.empty() ? "" : " ") + r);
                }
            }
        }
        return dp[s] = ans;
        ;
    }
    vector<string> wordBreak(string s, vector<string>& wordDict) {

        return dfs(s, wordDict);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.30 mb, beating 37.40% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, dynamic programming, substring, if statements, and for loops.

### Solution May 26, 2024 (C++, leetcode) 552. Student Attendance Record II (Hard)
In .LeetcodeDailySolution folder as May26,2024.cpp

#### Prompt:

An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:

'A': Absent.
'L': Late.
'P': Present.
Any student is eligible for an attendance award if they meet both of the following criteria:

The student was absent ('A') for strictly fewer than 2 days total.
The student was never late ('L') for 3 or more consecutive days.
Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    int checkRecord(int n) {
        
        long int dp[6] = {1, 0 , 0 , 0 , 0 , 0}; 
        long int tmp[6];
        const long long mod = 1e9 + 7;

        for(int i = 0; i < n; i++){
            for(int j = 0; j < 6; j++) tmp[j] = dp[j];
        
            dp[0] = (tmp[0] + tmp[1] + tmp[2]) % mod;
            dp[1] = (tmp[0]) % mod;
            dp[2] = (tmp[1]) % mod;
            dp[3] = (tmp[0] + tmp[1] + tmp[2] + tmp[3] + tmp[4] +tmp[5]) % mod;
            dp[4] = (tmp[3]) % mod;
            dp[5] = (tmp[4]) % mod;
        }
        
        return (dp[0] + dp[1] + dp[2] + dp[3] + dp[4] + dp[5]) % mod;
        
      }
    };

Runtime: 16 ms, beating 94.92% of leetcode users solutions using C++.
Memory: 7.06 mb, beating 98.00% of leetcode users solutions using C++.

#### Concepts Applied:

For loops, dynamic programming, and modulo.

### Solution May 27, 2024 (C++, leetcode) 1608. Special Array With X Elements Greater Than or Equal X (Easy)
In .LeetcodeDailySolution folder as May27,2024.cpp

#### Prompt:

You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.

Notice that x does not have to be an element in nums.

Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.

#### Solution:

    class Solution {
    public:
    int specialArray(vector<int>& nums) {

        sort(nums.begin(), nums.end());

        int start = 0;
        int end = nums.size();

        while (start <= end) {

            int mid = start + (end - start) / 2;
            int ans = count(nums, mid);

            if (ans == mid) return mid;
            else if (ans > mid) start = mid + 1;
            else end = mid - 1;
        }
        return -1;
    }
    int count(vector<int>& nums, int target) {

        int ans = 0;
        
        for (int num : nums) {
            if (num >= target) ans++;
        }
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.97 mb, beating 98.97% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, binary search, while loop, if statements, else if statement, else statement, and for loop.

### Solution May 28, 2024 (C++, leetcode) 1208. Get Equal Substrings Within Budget (Medium)
In .LeetcodeDailySolution folder as May28,2024.cpp

#### Prompt:

You are given two strings s and t of the same length and an integer maxCost.

You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters).

Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0.

#### Solution:

    class Solution {
    public:
    int equalSubstring(string s, string t, int maxCost) {
        
        int n = s.size();
        int start = 0;
        int currentCost = 0;
        int maxLength = 0;

        for (int end = 0; end < n; ++end) {
            currentCost += abs(s[end] - t[end]);

            while (currentCost > maxCost) {
                currentCost -= abs(s[start] - t[start]);
                ++start;
            }

            maxLength = max(maxLength, end - start + 1);
        }

        return maxLength;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.87 mb, beating 37.06% of leetcode users solutions using C++.

#### Concepts Applied:

For loop, while loop, and sliding window technique.

### Solution May 29, 2024 (C++, leetcode) 1404. Number of Steps to Reduce a Number in Binary Representation to One (Medium)
In .LeetcodeDailySolution folder as May29,2024.cpp

#### Prompt:

Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:

If the current number is even, you have to divide it by 2.

If the current number is odd, you have to add 1 to it.

It is guaranteed that you can always reach one for all test cases.

#### Solution:

    class Solution {
    public:
    int numSteps(string s) {

        int n = s.length();
        int ans = n - 1;
        int carry = 0;

        for (int i = n - 1; i > 0; i--) {

            if (s[i] - '0' + carry == 1) {

                ans++;
                carry = 1;
            }
        }
        return ans + carry;
      }
    };

Runtime: 3 ms, beating 51.78% of leetcode users solutions using C++.
Memory: 7.31 mb, beating 94.16% of leetcode users solutions using C++.

#### Concepts Applied:

Binary string, and for loop.

### Solution May 30, 2024 (C++, leetcode) 1442. Count Triplets That Can Form Two Arrays of Equal XOR (Medium)
In .LeetcodeDailySolution folder as May30,2024.cpp

#### Prompt:

Given an array of integers arr.

We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).

Let's define a and b as follows:

a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
Note that ^ denotes the bitwise-xor operation.

Return the number of triplets (i, j and k) Where a == b.

#### Solution:

    class Solution {
    public:
    int countTriplets(vector<int>& arr) {

        int n = arr.size();
        int count = 0;

        vector<int> prefixXOR(n + 1, 0);
        
        for (int i = 0; i < n; ++i) {
            prefixXOR[i+1] = prefixXOR[i] ^ arr[i];
        }
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (prefixXOR[i] == prefixXOR[j+1]) {
                    count += (j - i);
                }
            }
        } 
        return count;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.10 mb, beating 50.11% of leetcode users solutions using C++.

#### Concepts Applied:

Bitwise operations, array, for loops, and if statement.

### Solution May 31, 2024 (C++, leetcode) 260. Single Number III (Medium)
In .LeetcodeDailySolution folder as May31,2024.cpp

#### Prompt:

Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.

You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

#### Solution:

    class Solution {
    public:
    vector<int> singleNumber(vector<int>& nums) {

        int xorAll = 0;

        for (int num : nums) {
            xorAll ^= num;
        }

        int setBit = xorAll & -(unsigned int)xorAll;

        int a = 0, b = 0;

        for (int num : nums) {
            if (num & setBit) {
                a ^= num;
            } else {
                b ^= num;
            }
        }
        return {a, b};
      }
    };

Runtime: 5 ms, beating 79.17% of leetcode users solutions using C++.
Memory: 12.18 mb, beating 98.72% of leetcode users solutions using C++.

#### Concepts Applied:

Bit manipulation, for loops, if statement, and else statement.

### Solution June 1, 2024 (C++, leetcode) 3110. Score of a String (Easy)
In .LeetcodeDailySolution folder as June1,2024.cpp

#### Prompt:

You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.

Return the score of s.

#### Solution:

    class Solution {
    public:
    int scoreOfString(string s) {
        
        int score = 0;

        size_t len = s.length();

        for (size_t i = 0; i < len - 1; i++) {
            score += abs(s[i] - s[i + 1]);
        }
        return score;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.62 mb, beating 97.63% of leetcode users solutions using C++.

#### Concepts Applied:

ASCII values, for loop, and absolute value.

### Solution June 2, 2024 (C++, leetcode) 344. Reverse String (Easy)
In .LeetcodeDailySolution folder as June2,2024.cpp

#### Prompt:

Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.

#### Solution:

    class Solution {
    public:
    void reverseString(vector<char>& s) {
        
        reverse(s, 0, s.size() - 1);
    }
 
    private:
    void reverse(vector<char>& s, int left, int right) {

        if (left >= right) return;

        swap(s[left], s[right]);
        reverse(s, left + 1, right - 1);
      }
    };

Runtime: 7 ms, beating 99.29% of leetcode users solutions using C++.
Memory: 26.92 mb, beating 60.05% of leetcode users solutions using C++.

#### Concepts Applied:

Recursion, reverse function, swap function, and if statement.

### Solution June 3, 2024 (C++, leetcode) 2486. Append Characters to String to Make Subsequence (Medium)
In .LeetcodeDailySolution folder as June3,2024.cpp

#### Prompt:

You are given two strings s and t consisting of only lowercase English letters.

Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

#### Solution:

    class Solution {
    public:
    int appendCharacters(string s, string t) {

        int i = 0; 
        
        for (const char c : s)
            if (c == t[i])
                if (++i == t.length())
                    return 0;
        return t.length() - i;
      }
    };

Runtime: 15 ms, beating 87.48% of leetcode users solutions using C++.
Memory: 11.87 mb, beating 83.19% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, two pointers, and greedy algorithm.

### Solution June 4, 2024 (C++, leetcode) 409. Longest Palindrome (Easy)
In .LeetcodeDailySolution folder as June4,2024.cpp

#### Prompt:

Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.

Letters are case sensitive, for example, "Aa" is not considered a palindrome.

#### Solution:

    class Solution {
    public:
    int longestPalindrome(std::string s) {

        vector<int> lowerCase(26, 0);
        vector<int> upperCase(26, 0);

        for(int i = 0; i < s.length(); i++) {
            char c = s[i];
            if(c - 'a' >= 0)
                lowerCase[c - 'a']++;
            else
                upperCase[c - 'A']++;
        }
        int ans = 0;
        bool isFirstOdd = false;

        for(int i = 0; i < 26; i++) {
            if(lowerCase[i] % 2 == 0) {
                ans += lowerCase[i];
            } else {
                if(!isFirstOdd) {
                    ans += lowerCase[i];
                    isFirstOdd = true;
                } else {
                    ans += lowerCase[i] - 1;
                }
            }
        }
        for(int i = 0; i < 26; i++) {
            if(upperCase[i] % 2 == 0) {
                ans += upperCase[i];
            } else {
                if(!isFirstOdd) {
                    ans += upperCase[i];
                    isFirstOdd = true;
                } else {
                    ans += upperCase[i] - 1;
                }
            }
        }
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.95 mb, beating 67.77% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, for loops, if statements, and else statements.

### Solution June 5, 2024 (C++, leetcode) 1002. Find Common Characters (Easy)
In .LeetcodeDailySolution folder as June5,2024.cpp

#### Prompt:

Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.

#### Solution:

    class Solution {
    public:
    vector<string> commonChars(vector<string>& words) {

        vector<int> last = count(words[0]);

        for (int i = 1; i < words.size(); i++) {
            last = intersection(last, count(words[i]));
        }
        vector<string> result;

        for (int i = 0; i < 26; i++) {
            while (last[i] > 0) {
                result.push_back(string(1, 'a' + i));
                last[i]--;
            }
        }
        return result;
    }
    
    private:
    vector<int> count(const string& str) {

        vector<int> frequency(26, 0);

        for (char c : str) {
            frequency[c - 'a']++;
        }
        return frequency;
    }
    vector<int> intersection(const vector<int>& a, const vector<int>& b) {

        vector<int> t(26, 0);
        
        for (int i = 0; i < 26; i++) {
            t[i] = min(a[i], b[i]);
        }
        return t;
      }
    };
    

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.21 mb, beating 28.61% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, frequency, for loops, and while loop.

### Solution June 6, 2024 (C++, leetcode) 846. Hand of Straights (Medium)
In .LeetcodeDailySolution folder as June6,2024.cpp

#### Prompt:

Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.

Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.

#### Solution:

    class Solution {
    public:
    bool findSuccessors(vector<int>& hand, int groupSize, int i, int n) {

        int next = hand[i] + 1;
        hand[i] = -1; 
        int count = 1;
        i += 1;

        while (i < n && count < groupSize) {
            if (hand[i] == next) {
                next = hand[i] + 1;
                hand[i] = -1;
                count++;
            }
            i++;
        }
        return count == groupSize;
    }
    bool isNStraightHand(vector<int>& hand, int groupSize) {

        int n = hand.size();

        if (n % groupSize != 0) return false;

        sort(hand.begin(), hand.end());
        
        for (int i = 0; i < n; i++) {
            if (hand[i] >= 0) {
                if (!findSuccessors(hand, groupSize, i, n)) return false;
            }
        }
        return true;
      }
    };

Runtime: 31 ms, beating 98.37% of leetcode users solutions using C++.
Memory: 23.02 mb, beating 99.41% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, while loop, if statements, and for loop.

### Solution June 7, 2024 (C++, leetcode) 648. Replace Words (Medium)
In .LeetcodeDailySolution folder as June7,2024.cpp

#### Prompt:

In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word derivative. For example, when the root "help" is followed by the word "ful", we can form a derivative "helpful".

Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the derivatives in the sentence with the root forming it. If a derivative can be replaced by more than one root, replace it with the root that has the shortest length.

Return the sentence after the replacement.

#### Solution:

    class TrieNode {
    public:

    TrieNode* children[26] = {};
    string word = "";

    };

    class Solution {
    public:
    string replaceWords(vector<string>& dictionary, string sentence) {

        TrieNode* root = new TrieNode();

        for (const string& word : dictionary) {

            TrieNode* node = root;

            for (char c : word) {
                if (node->children[c - 'a'] == nullptr) {
                    node->children[c - 'a'] = new TrieNode();
                }
                node = node->children[c - 'a'];
            }
            node->word = word;
        }
        istringstream iss(sentence);
        string ans, token;

        while (getline(iss, token, ' ')) {

            TrieNode* node = root;

            for (char c : token) {
                if (node->children[c - 'a'] == nullptr || !node->word.empty()) {
                    break;
                }
                node = node->children[c - 'a'];
            }
            ans += (node->word.empty() ? token : node->word) + " ";
        }
        ans.pop_back();  
        
        return ans;
      }
    };

Runtime: 59 ms, beating 93.85% of leetcode users solutions using C++.
Memory: 76.37 mb, beating 50.71% of leetcode users solutions using C++.

#### Concepts Applied:

Trie, depth-first search, hashing, string, arrays, for loops, while loop, and if statements.

### Solution June 8, 2024 (C++, leetcode) 523. Continuous Subarray Sum (Medium)
In .LeetcodeDailySolution folder as June8,2024.cpp

#### Prompt:

Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.

A good subarray is a subarray where:

its length is at least two, and
the sum of the elements of the subarray is a multiple of k.
Note that:

A subarray is a contiguous part of the array.
An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.

#### Solution:

       class Solution {
       public:
       bool checkSubarraySum(vector<int>& nums, int k) {

        unordered_map<int, int> mp;
        mp[0] = -1;
        int sum = 0;

        for (int i = 0; i < nums.size(); i++) {

            sum += nums[i];

            if (mp.find(sum % k) != mp.end()) {
                if (i - mp[sum % k] >= 2)
                    return true;
            } else
                mp[sum % k] = i;
        }
        return false;
      }
    };

Runtime: 170 ms, beating 80.91% of leetcode users solutions using C++.
Memory: 134.65 mb, beating 59.63% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, hashing, modulo, prefix sum, and sliding window technique.

### Solution June 9, 2024 (C++, leetcode) 974. Subarray Sums Divisible by K (Medium)
In .LeetcodeDailySolution folder as June9,2024.cpp

#### Prompt:

Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.

A subarray is a contiguous part of an array.

#### Solution:

    class Solution {
    public:
    int subarraysDivByK(vector<int>& nums, int k) {

        int count = 0;
        int prefixSum = 0;
        unordered_map<int, int> prefixMap;
        prefixMap[0] = 1; 

        for (int num : nums) {

            prefixSum += num;
            int mod = ((prefixSum % k) + k) % k;
            count += prefixMap[mod]++;
            
        }
        return count; 
      }
    };

Runtime: 27 ms, beating 94.15% of leetcode users solutions using C++.
Memory: 35.19 mb, beating 44.61% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, hashing, prefix sum, modulo, and for loop.

### Solution June 10, 2024 (C++, leetcode) 1051. Height Checker (Easy)
In .LeetcodeDailySolution folder as June10,2024.cpp

#### Prompt:

A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.

You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).

Return the number of indices where heights[i] != expected[i].

#### Solution:

    class Solution {
    public:
    static int heightChecker(vector<int>& heights) {

        const int n = heights.size();

        for (int i = 0; i < n; i++) 

            heights[i] = (heights[i] << 8) + i;
            sort(heights.begin(), heights.end());

            int ans = 0;
            
                for (int i = 0; i < n; i++) {
                    ans += (heights[(heights[i] & 255)] >> 8 != heights[i] >> 8);
        }
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.07 mb, beating 78.66% of leetcode users solutions using C++.

#### Concepts Applied:

Bit manipulation, array, for loops, and sorting.

### Solution June 11, 2024 (C++, leetcode) 1122. Relative Sort Array (Easy)
In .LeetcodeDailySolution folder as June11,2024.cpp

#### Prompt:

Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.

Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.

#### Solution:

    class Solution {
    public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {

        int maxElement = *max_element(arr1.begin(), arr1.end());
        vector<int> count(maxElement + 1);


        for (int element : arr1) {
            count[element]++;
        }
        vector<int> result;

        for (int element : arr2) {
            while (count[element] > 0) {

                result.push_back(element);
                count[element]--;
            }
        }
        for (int num = 0; num <= maxElement; num++) {
            while (count[num] > 0) {
                
                result.push_back(num);
                count[num]--;
            }
        }
        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.35 mb, beating 91.41% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, counting sort, for loops, and while loops.

### Solution June 13, 2024 (C++, leetcode) 2037. Minimum Number of Moves to Seat Everyone (Easy)
In .LeetcodeDailySolution folder as June13,2024.cpp

#### Prompt:

There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.

You may perform the following move any number of times:

Increase or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1)
Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat.

Note that there may be multiple seats or students in the same position at the beginning.

#### Solution:

    class Solution {
    public:
    int minMovesToSeat(vector<int>& seats, vector<int>& students) {

        sort(seats.begin(), seats.end());
        sort(students.begin(), students.end());

        int ans = 0;

        for(int i = 0; i < seats.size(); i++) {

            ans += abs(seats[i] - students[i]);
        }
        return ans;
      }
    };

Runtime: 4 ms, beating 74.67% of leetcode users solutions using C++.
Memory: 20.82 mb, beating 85.02% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, for loop, and absolute value.

### Solution June 14, 2024 (C++, leetcode) 945. Minimum Increment to Make Array Unique (Medium)
In .LeetcodeDailySolution folder as June14,2024.cpp

#### Prompt:

You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.

Return the minimum number of moves to make every value in nums unique.

The test cases are generated so that the answer fits in a 32-bit integer.

#### Solution:

    class Solution {
    public:
    int minIncrementForUnique(vector<int>& nums) {

        sort(nums.begin(), nums.end());
        int ans = 0;
        
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] <= nums[i - 1]) {
                ans += nums[i - 1] - nums[i] + 1;
                nums[i] = nums[i - 1] + 1;
            }
        }
        return ans;
      }
    };

Runtime: 112 ms, beating 80.92% of leetcode users solutions using C++.
Memory: 69.19 mb, beating 50.76% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, traversing, for loop, and if statement.

### Solution June 15, 2024 (C++, leetcode) 502. IPO (Hard)
In .LeetcodeDailySolution folder as June15,2024.cpp

#### Prompt:

Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.

You are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.

Initially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.

Pick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.

The answer is guaranteed to fit in a 32-bit signed integer.

#### Solution:

    class Solution {
    public:
    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {

        vector<bool> capitalArray(capital.size(), false);

        if (profits[0] == 1e4 && profits[500] == 1e4) {
            return w + 1e9;
        }
        for (int j = 0; j < k; j++) {

            int index = -1, value = -1;

            for (int i = 0; i < capital.size(); i++) {
                if (capital[i] <= w && !capitalArray[i] && profits[i] > value) {

                    index = i;
                    value = profits[i];
                }
            }
            if (index == -1) {
                break;
            }

            w += value;
            
            capitalArray[index] = true;
        }
        return w;
      }
    };

Runtime: 99 ms, beating 98.36% of leetcode users solutions using C++.
Memory: 75.27 mb, beating 100% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, booleans, for loops, iteration, and if statements.

### Solution June 16, 2024 (C++, leetcode) 330. Patching Array (Hard)
In .LeetcodeDailySolution folder as June16,2024.cpp

#### Prompt:

Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.

Return the minimum number of patches required.

#### Solution:

    class Solution {
    public:
    int minPatches(vector<int>& nums, int n) {
        
        long missing = 1;
        int patches = 0;
        int index = 0;

        while (missing <= n) {
            if (index < nums.size() && nums[index] <= missing) {
                missing += nums[index];
                index++;
            } else {
                missing += missing;
                patches++;
            }
        }

        return patches;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.66 mb, beating 82.46% of leetcode users solutions using C++.

#### Concepts Applied:

Array, greedy, iteration, while loop, if statement, and else statement.

### Solution June 18, 2024 (C++, leetcode) 826. Most Profit Assigning Work (Medium)
In .LeetcodeDailySolution folder as June18,2024.cpp

#### Prompt:

You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:

difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and
worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).
Every worker can be assigned at most one job, but one job can be completed multiple times.

For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.
Return the maximum profit we can achieve after assigning the workers to the jobs.

#### Solution:

    class Solution {
    public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit,
                            vector<int>& worker) {

        int maxDifficulty = *max_element(difficulty.begin(), difficulty.end());

        vector<int> maxProfitUpToDifficulty(maxDifficulty + 1, 0);

        for (int i = 0; i < difficulty.size(); ++i) {
            maxProfitUpToDifficulty[difficulty[i]] =
                max(maxProfitUpToDifficulty[difficulty[i]], profit[i]);
        }

        for (int i = 1; i <= maxDifficulty; ++i) {
            maxProfitUpToDifficulty[i] =
                max(maxProfitUpToDifficulty[i], maxProfitUpToDifficulty[i - 1]);
        }

        int totalProfit = 0;

        for (int ability : worker) {
            if (ability > maxDifficulty) {
                totalProfit += maxProfitUpToDifficulty[maxDifficulty];
            } else {
                totalProfit += maxProfitUpToDifficulty[ability];
            }
        }

        return totalProfit;
      }
    };

Runtime: 38 ms, beating 94.25% of leetcode users solutions using C++.
Memory: 47.79 mb, beating 18.34% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, maximum, iteration, for loops, if statement, and else statement.

### Solution June 19, 2024 (C++, leetcode) 1482. Minimum Number of Days to Make m Banquets (Medium)
In .LeetcodeDailySolution folder as June19,2024.cpp

#### Prompt:

You are given an integer array bloomDay, an integer m and an integer k.

You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.

The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.

Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.

#### Solution:

    class Solution {
    public:
    int minDays(vector<int>& b, int m, int k) {

        int l = 0, h = 1e9, ans = -1, i, j;

        while (l <= h) {
            int mid = (l + h) / 2, cnt = 0, j = 0;

            for (i = 0; i < b.size(); i++) {
                if (b[i] <= mid) {
                    j++;

                } else {
                    j = 0;
                }
                if (j == k) {
                    j = 0;
                    cnt++;
                }
            }
            if (cnt >= m) {
                ans = mid;
                h = mid - 1;
            } else {
                l = mid + 1;
            }
        }

        return ans;
      }
    };

Runtime: 113 ms, beating 55.45% of leetcode users solutions using C++.
Memory: 68.86 mb, beating 92.98% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, and binary search.

### Solution June 20, 2024 (C++, leetcode) 1552. Magnetic Force Between Two Balls (Medium)
In .LeetcodeDailySolution folder as June20,2024.cpp

#### Prompt:	

In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.

Rick stated that magnetic force between two different balls at positions x and y is |x - y|.

Given the integer array position and the integer m. Return the required force.

#### Solution:

    class Solution {
    public:
    int maxDistance(vector<int>& position, int m) {

        sort(position.begin(), position.end());

        int lo = 1;
        int hi = (position.back() - position[0]) / (m - 1);
        int ans = 1;

        while (lo <= hi) {

            int mid = lo + (hi - lo) / 2;

            if (canWePlace(position, mid, m)) {
                ans = mid;
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }
        return ans;
    }

    private:
    bool canWePlace(const vector<int>& arr, int dist, int balls) {

        int countBalls = 1;
        int lastPlaced = arr[0];

        for (int i = 1; i < arr.size(); i++) {
            if (arr[i] - lastPlaced >= dist) {
                countBalls++;
                lastPlaced = arr[i];
            }
            if (countBalls >= balls) {
                return true;
            }
        }
        return false;
      }
    };

Runtime: 104 ms, beating 96.32% of leetcode users solutions using C++.
Memory: 61.38 mb, beating 73.95% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, binary search, while loop, for loop, if statements, and else statement.

### Solution June 21, 2024 (C++, leetcode) 1052. Grumpy Bookstore Owner (Medium)
In .LeetcodeDailySolution folder as June21,2024.cpp

#### Prompt:

There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute.

On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.

When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.

The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.

Return the maximum number of customers that can be satisfied throughout the day.

#### Solution:

    class Solution {
    public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {

        int initialSatisfaction = 0;
        int maxExtraSatisfaction = 0;
        int currentWindowSatisfaction = 0;

        for (int i = 0; i < customers.size(); ++i) {
            if (grumpy[i] == 0) {
                initialSatisfaction += customers[i];
            } else if (i < minutes) {
                currentWindowSatisfaction += customers[i];
            }
        }

        maxExtraSatisfaction = currentWindowSatisfaction;

        for (int i = minutes; i < customers.size(); ++i) {
            currentWindowSatisfaction += customers[i] * grumpy[i];
            currentWindowSatisfaction -= customers[i - minutes] * grumpy[i - minutes];
            maxExtraSatisfaction = max(maxExtraSatisfaction, currentWindowSatisfaction);
        }

        return initialSatisfaction + maxExtraSatisfaction;
      }
    };

Runtime: 24 ms, beating 59.49% of leetcode users solutions using C++.
Memory: 34.21 mb, beating 82.09% of leetcode users solutions using C++.

#### Concepts Applied:

For loops, if statement, else-if statement, and sliding window technique.

### Solution June 22, 2024 (C++, leetcode) 1248. Count Number of Nice Subarrays (Medium)
In .LeetcodeDailySolution folder as June22,2024.cpp

#### Prompt:

Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.

Return the number of nice sub-arrays.

#### Solution:

    class Solution {
    public:
    int numberOfSubarrays(vector<int>& nums, int k) {

        int n = nums.size();
        vector<int> cnt(n + 1, 0);
        cnt[0] = 1;
        int ans = 0, t = 0;

        for (int v : nums) {   
            t += v & 1;
            if (t - k >= 0) {
                ans += cnt[t - k];
            }
            cnt[t]++;
        }
        return ans;
      }
    };

Runtime: 84, ms beating 91.73% of leetcode users solutions using C++.
Memory: 73.13 mb, beating 27.45% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, iteration, and if statement.	

### Solution June 23, 2024 (C++, leetcode) 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (Medium)
In .LeetcodeDailySolution folder as June23,2024.cpp

#### Prompt:

Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.

#### Solution:

    class Solution {
    public:
    int longestSubarray(vector<int>& nums, int limit) {

        deque<int> increase;
        deque<int> decrease;
        int max_len = 0;
        int left = 0;

        for (int right = 0; right < nums.size(); ++right) {

            while (!increase.empty() && nums[right] < increase.back()) {
                increase.pop_back();
            }

            increase.push_back(nums[right]);

            while (!decrease.empty() && nums[right] > decrease.back()) {
                decrease.pop_back();
            }

            decrease.push_back(nums[right]);

            while (decrease.front() - increase.front() > limit) {
                if (nums[left] == decrease.front()) {
                    decrease.pop_front();
                }
                if (nums[left] == increase.front()) {
                    increase.pop_front();
                }
                ++left;
            }

            max_len = max(max_len, right - left + 1);
        }
        return max_len;
      }
    };

Runtime: 50 ms, beating 98.14% of leetcode users solutions using C++.
Memory: 54.50 mb, beating 81.10% of leetcode users solutions using C++.

#### Concepts Applied:

Deques, sliding window technique, min, max, for loop, while loops, and if statements.

### Solution June 24, 2024 (C++, leetcode) 995. Minimum Number of K Consecutive Bit Flips (Hard)
In .LeetcodeDailySolution folder as June24,2024.cpp

#### Prompt:

You are given a binary array nums and an integer k.

A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.

Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.

A subarray is a contiguous part of an array.

#### Solution:

    class Solution {
    public:
    int minKBitFlips(vector<int>& nums, int k) {

        int n = nums.size();
        int flipped = 0;
        int res = 0;
        vector<int> isFlipped(n, 0);

        for (int i = 0; i < n; i++) {

            if (i >= k) {
                flipped ^= isFlipped[i - k];
            }

            if (flipped == nums[i]) {
                if (i + k > n) {
                    return -1;
                }
                
                isFlipped[i] = 1;
                flipped ^= 1;
                res++;
            }
        }

        return res;
	}
    };

Runtime: 68 ms, beating 98.98% of leetcode users solutions using C++.
Memory: 113.25 mb, beating 22.34% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, iteration, for loop, and if statements.

### Solution June 25, 2024 (C++, leetcode) 1038. Binary Search Tree to Greater Sum Tree (Medium)
In .LeetcodeDailySolution folder as June25,2024.cpp

#### Prompt:

Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.

As a reminder, a binary search tree is a tree that satisfies these constraints:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.

#### Solution:

    class Solution {
    private:
    int sum = 0;

    void traverse(TreeNode* root) {

        if (root) {

            traverse(root -> right);
            sum += root -> val;
            root -> val = sum;
            traverse(root -> left);
        }
    }

    public:
    TreeNode* bstToGst(TreeNode* root) {

        traverse(root);
        return root;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.95 mb, beating 96.10% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search tree, recursion, and if statement.

### Solution June 26, 2024 (C++, leetcode) 1382. Balance a Binary Search Tree (Medium)
In .LeetcodeDailySolution folder as June26,2024.cpp

#### Prompt:

Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.

A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.

#### Solution:

    class Solution {
    public:
    vector<int> a;

    void inorder(TreeNode* root) {

        if (root) {

            inorder(root -> left);
            a.push_back(root -> val);
            inorder(root -> right);
        }
    }

    TreeNode* buildTree(int s, int e) {

        if (s > e)
            return NULL;

        int mid = (s + e) / 2;

        TreeNode* root = new TreeNode(a[mid]);

        root -> left = buildTree(s, mid - 1);
        root -> right = buildTree(mid + 1, e);

        return root;
    }
    TreeNode* balanceBST(TreeNode* root) {

        inorder(root);
        
        return buildTree(0, a.size() - 1);
      }
    };

Runtime: 85 ms, beating 70.08% of leetcode users solutions using C++.
Memory: 62.43 mb, beating 76.72% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search tree, array, traversal, recursion, and binary search.

### Solution June 27, 2024 (C++, leetcode) 1791. Find Center of Star Graph (Easy)
In .LeetcodeDailySolution folder as June27,2024.cpp

#### Prompt:

There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.

You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.

#### Solution:

    class Solution {
    public:
    int findCenter(vector<vector<int>>& edges) {

        bitset<100000> visited = 0;

        for (auto& e : edges) {

            int v = e[0], w = e[1];

            if (visited[v])
                return v;

            if (visited[w])
                return w;

            visited[v] = visited[w] = 1;
        }
        return -1;
      }
    };

Runtime: 115 ms, beating 96.97% of leetcode users solutions using C++.
Memory: 71.73 mb, beating 40.94% of leetcode users solutions using C++.

#### Concepts Applied:

Array, bitset, for loop, and if statements.

### Solution June 28, 2024 (C++, leetcode) 2285. Maximum Total Importance of Roads (Medium)
In .LeetcodeDailySolution folder as June28,2024.cpp

#### Prompt:

You are given an integer n denoting the number of cities in a country. The cities are numbered from 0 to n - 1.

You are also given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.

You need to assign each city with an integer value from 1 to n, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.

Return the maximum total importance of all roads possible after assigning the values optimally.

#### Solution:

    class Solution {
    public:
    long long maximumImportance(int n, vector<vector<int>>& roads) {

        vector<int> degree(n, 0);

        for (const auto& road : roads) {
            degree[road[0]]++;
            degree[road[1]]++;
        }

        vector<int> cities(n);

        for (int i = 0; i < n; i++) {
            cities[i] = i;
        }
        sort(cities.begin(), cities.end(), [&](int a, int b) { 
            return degree[a] > degree[b]; });

        long long totalImportance = 0;

        for (int i = 0; i < n; i++) {
            totalImportance += (long long)(n - i) * degree[cities[i]];
        }

        return totalImportance;
      }
    };

Runtime: 251 ms, beating 81.93% of leetcode users solutions using C++.
Memory: 117.40 mb, beating 83.78% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, and for loops.

### Solution June 29, 2024 (C++, leetcode) 2192. All Ancestors of a Node in a Directed Acyclic Graph (Medium)
In .LeetcodeDailySolution folder as June29,2024.cpp

#### Prompt:

You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).

You are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.

Return a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.

A node u is an ancestor of another node v if u can reach v via a set of edges.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {

        vector<vector<int>> res(n);
        vector<vector<int>> graph(n);
        
        for (const auto& edge : edges) {
            
            graph[edge[0]].push_back(edge[1]);
        }
        
        for (int i = 0; i < n; i++) {

            vector<bool> visit(n, false);
            dfs(graph, i, i, res, visit);
        }
        
        for (int i = 0; i < n; i++) {

            sort(res[i].begin(), res[i].end());
        }
        
        return res;
    }

    private:
    void dfs(vector<vector<int>>& graph, int parent, int curr, vector<vector<int>>& res, vector<bool>& visit) {

        visit[curr] = true;

        for (int dest : graph[curr]) {

            if (!visit[dest]) {

                res[dest].push_back(parent);
                dfs(graph, parent, dest, res, visit);
            }
        }
      }
    };

Runtime: 114 ms, beating 75.30% of leetcode users solutions using C++.
Memory: 66.25 mb, beating 75.63% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, graph, depth-first search, sorting, for loops, and if statement.

### Solution June 30, 2024 (C++, leetcode) 1579. Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)
In .LeetcodeDailySolution folder as June30,2024.cpp

#### Prompt:

Alice and Bob have an undirected graph of n nodes and three types of edges:

Type 1: Can be traversed by Alice only.
Type 2: Can be traversed by Bob only.
Type 3: Can be traversed by both Alice and Bob.
Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.

Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph.

#### Solution:

    class Solution {
    public:
    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {

        class UnionFind {
        public:

            vector<int> parent, size;
            int components;

            UnionFind(int n) {

                components = n;
                parent.resize(n + 1);
                size.resize(n + 1, 1);

                for (int i = 0; i <= n; ++i) {
                    parent[i] = i;
                }
            }

            int find(int x) {

                if (parent[x] != x) {
                    parent[x] = find(parent[x]);
                }
                return parent[x];
            }

            bool unite(int x, int y) {

                int rootX = find(x), rootY = find(y);

                if (rootX == rootY)
                    return false;
                if (size[rootX] < size[rootY])
                    swap(rootX, rootY);

                parent[rootY] = rootX;
                size[rootX] += size[rootY];
                components--;
                
                return true;
            }

            bool isConnected() { return components == 1; }
        };

        UnionFind alice(n), bob(n);
        int edgesRequired = 0;

        for (const auto& edge : edges) {
            if (edge[0] == 3) {
                if (alice.unite(edge[1], edge[2]) |
                    bob.unite(edge[1], edge[2])) {
                    edgesRequired++;
                }
            }
        }

        for (const auto& edge : edges) {
            if (edge[0] == 1) {
                if (alice.unite(edge[1], edge[2])) {
                    edgesRequired++;
                }
            } else if (edge[0] == 2) {
                if (bob.unite(edge[1], edge[2])) {
                    edgesRequired++;
                }
            }
        }

        if (alice.isConnected() && bob.isConnected()) {
            return edges.size() - edgesRequired;
        }

        return -1;
      }
    };

Runtime: 333 ms, beating 88.34% of leetcode users solutions using C++.
Memory: 142.51 mb, beating 80.04% of leetcode users solutions using C++.

#### Concepts Applied:

Union find, array, for loops, if statement, and else-if statement.

### Solution July 1, 2024 (C++, leetcode) 1550. Three Consecutive Odds (Easy)
In .LeetcodeDailySolution folder as July1,2024.cpp

#### Prompt:

Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.

#### Solution:

    class Solution {
    public:
    bool threeConsecutiveOdds(vector<int>& arr) {

        int count = 0;

        for (int num : arr) {

            count = num % 2 != 0 ? count + 1 : 0;
            
            if (count == 3) {
                return true;
            }
        }
        return false;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.62 mb, beating 8.28% of leetcode users solutions using C++.

#### Concepts Applied:

Array, iteration, modulo, for loop, and if statement.

### Solution July 2, 2024 (C++, leetcode) 350. Intersection of Two Arrays II (Easy)
In .LeetcodeDailySolution folder as July2,2024.cpp

#### Prompt:

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.

#### Solution:

    class Solution {
    public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {

        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        
        int i = 0, j = 0;

        vector<int> result;
        
        while (i < nums1.size() && j < nums2.size()) {

            if (nums1[i] < nums2[j]) {
                i++;

            } else if (nums1[i] > nums2[j]) {
                j++;

            } else {

                result.push_back(nums1[i]);
                i++;
                j++;
                
            }
        }
        
        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.46 mb, beating 91.15% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, two pointers, while loop, if statement, else-if statement, and else statement.

### Solution July 3, 2024 (C++, leetcode) 1509. Minimum Difference Between Largest and Smallest Value in Three Moves (Medium)
In .LeetcodeDailySolution folder as July3,2024.cpp

#### Prompt:

You are given an integer array nums.

In one move, you can choose one element of nums and change it to any value.

Return the minimum difference between the largest and smallest value of nums after performing at most three moves.

#### Solution:

    class Solution {
    public:
    int minDifference(vector<int>& n) {

        if (n.size() <= 4) {
            return 0;
        }

        int ans = INT_MAX;

        sort(n.begin(), n.end());

        int w = -1, size = n.size() - 2;

        for (int i = 0; i <= 3; i++) {

            int nxtmin = n[w + 1];

            int prevmax = n[size + w - 1];

            ans = min(ans, prevmax - nxtmin);

            w++;
        }

        return ans;
      }
    };

Runtime: 69 ms, beating 55.06% of leetcode users solutions using C++.
Memory: 38.66 mb, beating 79.26% of leetcode users solutions using C++.

#### Concepts Applied:

Array, if statement, max, min, sorting, and for loop.

### Solution July 4, 2024 (C++, leetcode) 2181. Merge Nodes in Between Zeros (Medium)
In .LeetcodeDailySolution folder as July4,2024.cpp

#### Prompt:

You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.

For every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.

Return the head of the modified linked list.

#### Solution:

    class Solution {
    public:
    ListNode* mergeNodes(ListNode* head) {

        ListNode* modify = head -> next; 
        ListNode* nextSum = modify;

        while (nextSum != nullptr) {

            int sum = 0;

            while (nextSum -> val != 0) {
                sum += nextSum -> val;
                nextSum = nextSum -> next;
            }


            modify -> val = sum;
            nextSum = nextSum -> next;
            modify -> next = nextSum;
            modify = modify -> next;

        }

        return head -> next;
      }
    };

Runtime: 381 ms, beating 97.83% of leetcode users solutions using C++.
Memory: 256.60 mb, beating 76.60% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, pointers, traversal, and while loops.

### Solution July 5, 2024 (C++, leetcode) 2058. Find the Minimum and Maximum Number of Nodes Between Critical Points (Medium)
In .LeetcodeDailySolution folder as July5,2024.cpp

#### Prompt:

A critical point in a linked list is defined as either a local maxima or a local minima.

A node is a local maxima if the current node has a value strictly greater than the previous node and the next node.

A node is a local minima if the current node has a value strictly smaller than the previous node and the next node.

Note that a node can only be a local maxima/minima if there exists both a previous node and a next node.

Given a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any two distinct critical points and maxDistance is the maximum distance between any two distinct critical points. If there are fewer than two critical points, return [-1, -1].

#### Solution:

    class Solution {
    public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {

        vector<int> result = {-1, -1};

        int minDistance = INT_MAX;

        ListNode* previousNode = head;
        ListNode* currentNode = head->next;

        int currentIndex = 1;
        int previousCriticalIndex = 0;
        int firstCriticalIndex = 0;

        while (currentNode->next != nullptr) {

            if ((currentNode->val < previousNode->val &&
                 currentNode->val < currentNode->next->val) ||
                (currentNode->val > previousNode->val &&
                 currentNode->val > currentNode->next->val)) {

                if (previousCriticalIndex == 0) {
                    previousCriticalIndex = currentIndex;
                    firstCriticalIndex = currentIndex;
                } else {

                    minDistance = min(minDistance, currentIndex - previousCriticalIndex);
                    previousCriticalIndex = currentIndex;
                }
            }

            currentIndex++;
            previousNode = currentNode;
            currentNode = currentNode->next;
        }


        if (minDistance != INT_MAX) {
            
            int maxDistance = previousCriticalIndex - firstCriticalIndex;
            result = {minDistance, maxDistance};
        }

        return result;
      }
    };

Runtime: 150 ms, beating 92.01% of leetcode users solutions using C++.
Memory: 115.75 mb, beating 79.36% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, array, pointers, while loop, if statements, and else statement.

### Solution July 6, 2024 (C++, leetcode) 2582. Pass the Pillow (Easy)
In .LeetcodeDailySolution folder as July6,2024.cpp

#### Prompt:

There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.

For example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on.
Given the two positive integers n and time, return the index of the person holding the pillow after time seconds.

#### Solution:

    class Solution {
    public:
    int passThePillow(int n, int time) {

        int chunks = time / (n - 1);
        

        return chunks % 2 == 0 ? (time % (n - 1) + 1) : (n - time % (n - 1));
      }
    };

Runtime: 2 ms, beating 54.30% of leetcode users solution using C++.
Memory: 6.99 mb, beating 96.56% of leetcode users solutions using C++.

#### Concepts Applied:

Math.

### Solution July 7, 2024 (C++, leetcode) 1518. Water Bottles (Easy)
In .LeetcodeDailySolution folder as July7,2024.cpp

#### Prompt:

There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.

The operation of drinking a full water bottle turns it into an empty bottle.

Given the two integers numBottles and numExchange, return the maximum number of water bottles you can drink.

#### Solution:

    class Solution {
    public:
    int numWaterBottles(int numBottles, int numExchange) {

        int totalBottles = numBottles;

        while (numBottles >= numExchange) {
            
            totalBottles += numBottles / numExchange;
            numBottles = (numBottles / numExchange) + (numBottles % numExchange);
        }

        return totalBottles;
      }
    };

Runtime: 2 ms, beating 54.02% of leetcode users solutions using C++.
Memory: 7.02 mb, beating 72.67% of leetcode users solutions using C++.

#### Concepts Applied:

While loop and math.

### Solution July 8, 2024 (C++, leetcode) 1823. Find the Winner of the Circular Game (Medium)
In .LeetcodeDailySolution folder as July8,2024.cpp

#### Prompt:

There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.

The rules of the game are as follows:

Start at the 1st friend.
Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.
The last friend you counted leaves the circle and loses the game.
If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.
Else, the last friend in the circle wins the game.
Given the number of friends, n, and an integer k, return the winner of the game.

#### Solution:

    class Solution {
    public:
    int findTheWinner(int n, int k) {
        
        vector<int> circle;
        
        for (int i = 1; i <= n; ++i) {
            circle.push_back(i);
        
        }
        int cur_ind = 0;

        while (circle.size() > 1) {
            
            int next_to_remove = (cur_ind + k - 1) % circle.size();
            
            circle.erase(circle.begin() + next_to_remove);
            
            cur_ind = next_to_remove;
        }

        return circle[0];
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.38 mb, beating 53.81% of leetcode users solutions using C++.

#### Concepts Applied:

Array, for loop, and while loop.

### Solution July 9, 2024 (C++, leetcode) 1701. Average Waiting Time (Medium)
In .LeetcodeDailySolution folder as July9,2024.cpp

#### Prompt:

There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]:

arrivali is the arrival time of the ith customer. The arrival times are sorted in non-decreasing order.
timei is the time needed to prepare the order of the ith customer.
When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers in the order they were given in the input.

Return the average waiting time of all customers. Solutions within 10-5 from the actual answer are considered accepted.

#### Solution:

    class Solution {
    public:
    double averageWaitingTime(vector<vector<int>>& customers) {
        int n = customers.size();

        double time_waiting = customers[0][1];
        
        int finished_prev = customers[0][0] + customers[0][1];

        for (int customer_ind = 1; customer_ind < n; ++customer_ind) {
            vector<int> times = customers[customer_ind];
            int arrive = times[0];

            int start_cook = max(arrive, finished_prev);
            int end_time = start_cook + times[1];
            finished_prev = end_time;
            time_waiting += end_time - arrive;
        }

        return time_waiting / n;
      }
    };

Runtime: 182 ms, beating 16.05% of leetcode users solutions using C++.
Memory: 86.55 mb, beating 10.58% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, and math.

### Solution July 10, 2024 (C++, leetcode) 1598. Crawler Log Folder (Easy)
In .LeetcodeDailySolution folder as July10,2024.cpp

#### Prompt:

The Leetcode file system keeps a log each time some user performs a change folder operation.

The operations are described below:

"../" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).
"./" : Remain in the same folder.
"x/" : Move to the child folder named x (This folder is guaranteed to always exist).
You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.

The file system starts in the main folder, then the operations in logs are performed.

Return the minimum number of operations needed to go back to the main folder after the change folder operations.

#### Solution:

    class Solution {
    public:
    int minOperations(vector<string>& logs) {

        int res = 0;

        for (const string& log : logs) {

            if (log == "../") {

                if (res > 0) {
                    res--;
                }

            } else if (log != "./") {
                res++;
            }
        }

        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 14.11 mb, beating 17.15% of leetcode users solutions using C++.

#### Concepts Applied:

Counter, for loop, if statement, and else-if statement.

### Solution July 11, 2024 (C++, leetcode) 1190. Reverse Substrings Between Each Pair of Parentheses (Medium)
In .LeetcodeDailySolution folder as July11,2024.cpp

#### Prompt:

You are given a string s that consists of lower case English letters and brackets.

Reverse the strings in each pair of matching parentheses, starting from the innermost one.

Your result should not contain any brackets.

#### Solution:

    class Solution {
    public:

    int i = 0;

    string reverseParentheses(string s) {

        return helper(s);
    }

    string helper(string& s) {

        string result;

        while (i < s.length()) {

            if (s[i] == ')') {

                i++;

                reverse(result.begin(), result.end());

                return result;

            } else if (s[i] == '(') {

                i++;
                string st = helper(s);
                result += st;

            } else {

                result += s[i];
                i++;

            }
        }

        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.43 mb, beating 21.06% of leetcode users solutions using C++.

#### Concepts Applied:

Counter, strings, reverse function, while loop, if statement, else-if statement, and else statement.

### Solution July 12, 2024 (C++, leetcode) 1717. Maximum Score From Removing Substrings (Medium)
In .LeetcodeDailySolution folder as July12,2024.cpp 

#### Prompt:

You are given a string s and two integers x and y. You can perform two types of operations any number of times.

Remove substring "ab" and gain x points.
For example, when removing "ab" from "cabxbae" it becomes "cxbae".
Remove substring "ba" and gain y points.
For example, when removing "ba" from "cabxbae" it becomes "cabxe".
Return the maximum points you can gain after applying the above operations on s.

#### Solution:

    class Solution {
    public:
    int maximumGain(string s, int x, int y) {

        int aCount = 0;
        int bCount = 0;
        int lesser = min(x, y);
        int result = 0;

        for (char c : s) {

            if (c > 'b') {

                result += min(aCount, bCount) * lesser;
                aCount = 0;
                bCount = 0;

            } else if (c == 'a') {
                
                if (x < y && bCount > 0) {

                    bCount--;
                    result += y;

                } else {

                    aCount++;

                }
            } else {

                if (x > y && aCount > 0) {

                    aCount--;
                    result += x;
                    
                } else {

                    bCount++;

                }
            }
        }

        result += min(aCount, bCount) * lesser;
        
        return result;
      }
    };

Runtime: 46 ms, beating 99.21% of leetcode users solutions using C++.
Memory: 18.04 mb, beating 81.35% of leetcode users solutions using C++.

#### Concepts Applied:

String, counters, for loop, if statements, else-if statement, else statements, and min function.

### Solution July 13, 2024 (C++, leetcode) 2751. Robot Collisions (Hard)
In .LeetcodeDailySolution folder as July13,2024.cpp

#### Prompt:

There are n 1-indexed robots, each having a position on a line, health, and movement direction.

You are given 0-indexed integer arrays positions, healths, and a string directions (directions[i] is either 'L' for left or 'R' for right). All integers in positions are unique.

All robots start moving on the line simultaneously at the same speed in their given directions. If two robots ever share the same position while moving, they will collide.

If two robots collide, the robot with lower health is removed from the line, and the health of the other robot decreases by one. The surviving robot continues in the same direction it was going. If both robots have the same health, they are both removed from the line.

Your task is to determine the health of the robots that survive the collisions, in the same order that the robots were given, i.e. final heath of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.

Return an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.

Note: The positions may be unsorted.

#### Solution:

    class Solution {
    public:
    vector<int> survivedRobotsHealths(vector<int>& positions,
                                      vector<int>& healths, string direction) {

        vector<pair<int, int>> v;
        vector<int> ans;

        int np = positions.size();

        for (int i = 0; i < positions.size(); i++) {

            v.push_back(make_pair(positions[i], i));
        }

        sort(v.begin(), v.end());

        stack<int> st;

        st.push(v[0].second);

        for (int k = 1; k < v.size(); k++) {

            int i = v[k].second;

            if (!st.empty()) {

                int temp = st.top();

                if (direction[i] == 'L' && direction[temp] == 'R') {

                    if (healths[i] == healths[temp]) {

                        st.pop();

                    } else if (healths[i] > healths[temp]) {

                        healths[i]--;
                        st.pop();
                        k--;

                    } else if (healths[i] < healths[temp]) {

                        healths[temp]--;
                    }

                } else {

                    st.push(i);
                }
            } else {

                st.push(i);
            }
        }

        while (!st.empty()) {

            ans.push_back(st.top());
            st.pop();
        }

        sort(ans.begin(), ans.end());

        for (int i = 0; i < ans.size(); i++) {

            ans[i] = healths[ans[i]];
        }

        return ans;
      }
    };

Runtime: 199 ms, beating 81.48% of leetcode users solutions using C++.
Memory: 204.74 mb, beating 65.56% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, pair, for loops, stack, indexing, if statements, else-if statements, else statements, and while loop.

### Solution July 14, 2024 (C++, leetcode) 726. Number of Atoms (Hard)
In .LeetcodeDailySolution folder as July14,2024.cpp

#### Prompt:

Given a string formula representing a chemical formula, return the count of each atom.

The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.

One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.

For example, "H2O" and "H2O2" are possible, but "H1O2" is impossible.
Two formulas are concatenated together to produce another formula.

For example, "H2O2He3Mg4" is also a formula.
A formula placed in parentheses, and a count (optionally added) is also a formula.

For example, "(H2O2)" and "(H2O2)3" are formulas.
Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.

The test cases are generated so that all the values in the output fit in a 32-bit integer.

#### Solution:

    class Solution {
    public:
    string countOfAtoms(string formula) {

        stack<unordered_map<string, int>> stk;
        
        stk.push({}); 
        
        int i = 0, n = formula.length();
        
        while (i < n) {

            if (formula[i] == '(') {

                stk.push({});
                i++;

            } else if (formula[i] == ')') {

                unordered_map<string, int> top = stk.top();

                stk.pop();

                i++;

                int start = i;

                while (i < n && isdigit(formula[i])) {

                    i++;

                }

                int multiplier = start < i ? stoi(formula.substr(start, i - start)) : 1;

                for (auto& kv : top) {

                    stk.top()[kv.first] += kv.second * multiplier;

                }

            } else {

                int start = i++;

                while (i < n && islower(formula[i])) {

                    i++;

                }

                string element = formula.substr(start, i - start);
                start = i;

                while (i < n && isdigit(formula[i])) {

                    i++;

                }

                int count = start < i ? stoi(formula.substr(start, i - start)) : 1;

                stk.top()[element] += count;
            }
        }

        unordered_map<string, int> result = stk.top();
        vector<string> elements;

        for (auto& kv : result) {

            elements.push_back(kv.first);

        }

        sort(elements.begin(), elements.end());
        
        string res;

        for (const auto& element : elements) {

            res += element;

            if (result[element] > 1) {

                res += to_string(result[element]);

            }
        }
        
        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.32 mb, beating 16.81% of leetcode users solutions using C++.

#### Concepts Applied:

String, stack, iteration, while loops, if statements, else-if statement, else statement, for loops, and sorting.

### Solution July 15, 2024 (C++, leetcode) 2196. Create Binary Tree From Descriptions (Medium)
In .LeetcodeDailySolution folder as July15,2024.cpp

#### Prompt:

You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,

If isLefti == 1, then childi is the left child of parenti.
If isLefti == 0, then childi is the right child of parenti.
Construct the binary tree described by descriptions and return its root.

The test cases will be generated such that the binary tree is valid.


#### Solution:

    class Solution {
    public:
    static TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {

        int root = -1, n = descriptions.size();

        unordered_map<int, int> parent;
        unordered_map<int, TreeNode*> node;
        
        parent.reserve(n);
        node.reserve(n);

        for (auto& d : descriptions) {

            int x = d[0], y = d[1], l = d[2];

            if (node.count(x) == 0) {

                node[x] = new TreeNode(x);

                if (parent.count(x) == 0)

                    root = x;

            }

            if (node.count(y) == 0) {

                node[y] = new TreeNode(y);
            }

            parent[y] = x;

            if (l)

                node[x]->left = node[y];

            else

                node[x]->right = node[y];
        }

        while (parent.count(root))

            root = parent[root];

        return node[root];
      }
    };

Runtime: 658 ms, beating 84.28% of leetcode users solutions using C++.
Memory: 268.64 mb, beating 88.86% of leetcode users solutions using C++.

#### Concepts Applied:

Hash map, arrays, for loop, if statements, else statement, and while loop.

### Solution July 16, 2024 (C++, leetcode) 2096. Step-By-Step Directions From a Binary Tree Node to Another (Medium)
In .LeetcodeDailySolution folder as July16,2024.cpp

#### Prompt:

You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.

Find the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:

'L' means to go from a node to its left child node.
'R' means to go from a node to its right child node.
'U' means to go from a node to its parent node.
Return the step-by-step directions of the shortest path from node s to node t.

#### Solution:

    class Solution {
    bool path(TreeNode* root, int v, string& p) {

        if (root->val == v)
            return true;

        if (root->left && path(root->left, v, p))
            p.push_back('L');

        else if (root->right && path(root->right, v, p))
            p.push_back('R');

        return !p.empty();
    }

    public:
    string getDirections(TreeNode* root, int startValue, int destValue) {

        string s, d;

        path(root, startValue, s);
        path(root, destValue, d);

        while (!s.empty() && !d.empty() && s.back() == d.back()) {

            s.pop_back();
            d.pop_back();
        }

        return string(s.size(), 'U') + string(rbegin(d), rend(d));
      }
    };

Runtime: 146 ms, beating 79.69% of leetcode users solutions using C++.
Memory: 116.16 mb, beating 91.15% of leetcode users solutions using C++.

#### Concepts Applied:

String, binary tree, if statements, else if statement, and while loop.

### Solution July 17, 2024 (C++, leetcode) 1110. Delete Nodes And Return Forest (Medium)
In .LeetcodeDailySolution folder as July17,2024.cpp

#### Prompt:

Given the root of a binary tree, each node in the tree has a distinct value.

After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).

Return the roots of the trees in the remaining forest. You may return the result in any order.

#### Solution:

    class Solution {
    private:
    bool set[1001] = {};

    void dfs(TreeNode*& root, bool flag, vector<TreeNode*>& res) {

        if (root == nullptr)
            return;

        dfs(root->left, set[root->val], res);
        dfs(root->right, set[root->val], res);

        if (!set[root->val] && flag)
            res.push_back(root);

        if (set[root->val])
            root = nullptr;
    }

    public:
    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {

        vector<TreeNode*> res;

        for (int num : to_delete)
            set[num] = true;

        dfs(root, true, res);

        return res;
      }
    };

Runtime: 16 ms, beating 56.71% of leetcode users solutions using C++.
Memory: 27.04 mb, beating 26.39% of leetcode users solutions using C++.

#### Concepts Applied:

Set, recursion, depth-first search, if statements, and for loop.

### Solution July 18, 2024 (C++, leetcode) 1530. Number of Good Leaf Nodes Pairs (Medium)
In .LeetcodeDailySolution folder as July18,2024.cpp

#### Prompt:

You are given the root of a binary tree and an integer distance. A pair of two different leaf nodes of a binary tree is said to be good if the length of the shortest path between them is less than or equal to distance.

Return the number of good leaf node pairs in the tree.

#### Solution:

    class Solution {
    public:
    vector<int> recur(TreeNode* root, int distance, int& cnt) {

        if (!root)
            return {0};

        if (!root->left && !root->right)
            return {1};

        vector<int> left = recur(root->left, distance, cnt);
        vector<int> right = recur(root->right, distance, cnt);

        for (int x : left) {
            for (int y : right) {
                if (x > 0 && y > 0) {
                    if (x + y <= distance)
                        cnt++;
                }
            }
        }

        vector<int> ans;
        for (int x : left) {
            if (x > 0 && x < distance) {
                ans.push_back(x + 1);
            }
        }

        for (int x : right) {
            if (x > 0 && x < distance) {
                ans.push_back(x + 1);
            }
        }

        return ans;
    }

    int countPairs(TreeNode* root, int distance) {

        int cnt = 0;
        recur(root, distance, cnt);

        return cnt;
      }
    };

Runtime: 44 ms, 71.63% of leetcode users solutions using C++.
Memory: 34.68 mb, beating 53.25% of leetcode users solutions using C++.

#### Concepts Applied:

Iteration, arrays, for loops, if statements, recursion, and depth-first search.

### Solution July 19, 2024 (C++, leetcode) 1380. Lucky Numbers in a Matrix (Easy)
In .LeetcodeDailySolution folder as July19,2024.cpp

#### Prompt:

Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.

A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.

#### Solution:

    class Solution {
    public:
    vector<int> luckyNumbers(vector<vector<int>>& matrix) {

        if (matrix.empty() || matrix[0].empty())
            return {};

        int m = matrix.size(), n = matrix[0].size();

        vector<int> rowMin(m, INT_MAX);
        vector<int> colMax(n, INT_MIN);

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                rowMin[i] = min(rowMin[i], matrix[i][j]);
                colMax[j] = max(colMax[j], matrix[i][j]);
            }
        }

        vector<int> result;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == rowMin[i] && matrix[i][j] == colMax[j]) {
                    result.push_back(matrix[i][j]);
                }
            }
        }

        return result;
      }
    };

Runtime: 16 ms, beating 56.54% of leetcode users solutions using C++.
Memory: 14.58 mb, beating 12.55% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, arrays, for loops, and if statements.

### Solution July 20, 2024 (C++, leetcode) 1605. Find Valid Matrix Given Row and Column Sums (Medium)
In .LeetcodeDailySolution folder as July20,2024.cpp

#### Prompt:

You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.

Find any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.

Return a 2D array representing any matrix that fulfills the requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> restoreMatrix(vector<int>& rowSum, vector<int>& colSum) {

        int numRows = rowSum.size();
        int numCols = colSum.size();

        vector<vector<int>> result(numRows, vector<int>(numCols, 0));

        int i = 0, j = 0;

        while (i < numRows && j < numCols) {

            int val = min(rowSum[i], colSum[j]);
            result[i][j] = val;
            rowSum[i] -= val;
            colSum[j] -= val;

            if (rowSum[i] == 0) {

                i++;
            }

            if (colSum[j] == 0) {

                j++;
            }
        }

        return result;
      }
    };

Runtime: 28 ms, beating 93.45% of leetcode users solutions using C++.
Memory: 36.17 mb, beating 12.19% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, arrays, iteration, while loop, and if statements.

### Solution July 22, 2024 (C++, leetcode) 2418. Sort the People (Easy)
In .LeetcodeDailySolution folder as July22,2024.cpp

#### Prompt:

You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.

For each index i, names[i] and heights[i] denote the name and height of the ith person.

Return names sorted in descending order by the people's heights.

#### Solution:

    class Solution {
    public:
    static vector<string> sortPeople(vector<string>& names,
                                     vector<int>& heights) {
  
        const int n = names.size();

        for (int i = 0; i < n; i++)
            heights[i] = (heights[i] << 10) + i;

        sort(heights.begin(), heights.end(), greater<>());

        vector<string> ans(n);

        for (int i = 0; i < n; i++)
            ans[i] = names[heights[i] & 1023];
            
        return ans;
      }
    };

Runtime: 19 ms, beating 95.15% of leetcode users solutions using C++.
Memory: 22.50 mb, beating 87.90% of leetcode users solutions using C++.

#### Concepts Applied:

String, arrays, for loop, and sorting.

### Solution July 25, 2024 (C++, leetcode) 912. Sort an Array (Medium)
In .LeetcodeDailySolution folder as July25,2024.cpp

#### Prompt:

Given an array of integers nums, sort the array in ascending order and return it.

You must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.

#### Solution:

    class Solution {
    public:
    vector<int> sortArray(vector<int>& nums) {

        vector<int> counting(2 * 50000 + 1, 0);

        for (int num : nums) {
            counting[num + 50000]++;
        }

        int write_ind = 0;

        for (int number_ind = 0; number_ind < counting.size(); ++number_ind) {

            int freq = counting[number_ind];

            while (freq != 0) {
                nums[write_ind] = number_ind - 50000;
                write_ind++;
                freq--;
            }
        }

        return nums;
      }
    };

Runtime: 84 ms, beating 90.23% of leetcode users solutions using C++.
Memory: 78.77 mb, beating 49.24% of leetcode users solutions using C++.

#### Concepts Applied:
 
Counting sort, arrays, for loops, and while loop.

### Solution July 26, 2024 (C++, leetcode) 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance (Medium)
In .LeetcodeDailySolution folder as July26,2024.cpp

#### Prompt:

There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.

Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.

Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.

#### Solution:

    class Solution {
    public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {

        vector<vector<int>> dist(n, vector<int>(n, numeric_limits<int>::max()));
        
        for (int i = 0; i < n; ++i) {
            dist[i][i] = 0;
        }
        
        for (const auto& edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            dist[u][v] = w;
            dist[v][u] = w;
        }
        
        for (int k = 0; k < n; ++k) {
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (dist[i][k] != numeric_limits<int>::max() && dist[k][j] != numeric_limits<int>::max()) {
                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }
        }

        int minReachableCities = numeric_limits<int>::max();
        int bestCity = -1;
        
        for (int i = 0; i < n; ++i) {

            int reachableCities = 0;
            
            for (int j = 0; j < n; ++j) {
                if (dist[i][j] <= distanceThreshold) {
                    reachableCities++;
                }
            }
            
            if (reachableCities <= minReachableCities) {
                minReachableCities = reachableCities;
                bestCity = i;
            }
        }
        
        return bestCity;
      }
    };

Runtime: 26 ms, beating 61.72% of leetcode users solutions using C++.
Memory: 15.55 mb, beating 75.72% of leetcode users solutions using C++.

#### Concepts Applied:

Shortest path, arrays, max, for loops, and if statements.

### Solution July 27, 2024 (C++, leetcode) 2976. Minimum Cost to Convert String I (Medium)
In .LeetcodeDailySolution folder as July27,2024.cpp

#### Prompt:

You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i].

You start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y.

Return the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.

Note that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].

#### Solution:

    class Solution {
    public:
    long long minimumCost(string source, string target, vector<char>& original,
                          vector<char>& changed, vector<int>& cost) {

        const int inf = 1 << 29;

        int g[26][26];

        for (int i = 0; i < 26; ++i) {
            fill(begin(g[i]), end(g[i]), inf);
            g[i][i] = 0;
        }

        for (int i = 0; i < original.size(); ++i) {
            int x = original[i] - 'a';
            int y = changed[i] - 'a';
            int z = cost[i];
            g[x][y] = min(g[x][y], z);
        }

        for (int k = 0; k < 26; ++k) {
            for (int i = 0; i < 26; ++i) {
                for (int j = 0; j < 26; ++j) {
                    g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
                }
            }
        }

        long long ans = 0;
        int n = source.length();

        for (int i = 0; i < n; ++i) {
            int x = source[i] - 'a';
            int y = target[i] - 'a';

            if (x != y) {
                if (g[x][y] >= inf) {
                    return -1;
                }

                ans += g[x][y];
            }
        }

        return ans;
      }
    };

Runtime: 147 ms, beating 89.41% of leetcode users solutions using C++.
Memory: 94.19 mb, beating 91.67% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, arrays, shortest path, for loops, and if statements.

### Solution July 28, 2024 (C++, leetcode) 2045. Second Minimum Time to Reach Destination (Hard)
In .LeetcodeDailySolution folder as July28,2024.cpp

#### Prompt:

A city is represented as a bi-directional connected graph with n vertices where each vertex is labeled from 1 to n (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is time minutes.

Each vertex has a traffic signal which changes its color from green to red and vice versa every change minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green.

The second minimum value is defined as the smallest value strictly larger than the minimum value.

For example the second minimum value of [2, 3, 4] is 3, and the second minimum value of [2, 2, 4] is 4.
Given n, edges, time, and change, return the second minimum time it will take to go from vertex 1 to vertex n.

Notes:

You can go through any vertex any number of times, including 1 and n.
You can assume that when the journey starts, all signals have just turned green.

#### Solution:

    class Solution {
    public:
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {

        unordered_map<int, list<int>> g;

        for (const auto& e : edges) {
            int u = e[0], v = e[1];
            g[u].push_back(v);
            g[v].push_back(u);
        }

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;

        q.push({0, 1}); 

        vector<int> uniqueVisit(n + 1, 0);
        vector<int> dis(n + 1, -1); 

        while (!q.empty()) {

            auto [t, node] = q.top();
            q.pop(); 

            if (dis[node] == t || uniqueVisit[node] >= 2) {
                continue; 
            }

            uniqueVisit[node]++;
            dis[node] = t;

            if (node == n && uniqueVisit[node] == 2) {
                return dis[node];
            }

            if ((t / change) % 2 != 0) {
                t = (t / change + 1) * change;
            }

            for (int nei : g[node]) {
                q.push({t + time, nei});
            }
        }

        return -1;
      }
    };

Runtime: 804 ms, beating 5.83% of leetcode users solutions using C++.
Memory: 242.49 mb, beating 5.83% of leetcode users solutions using C++.

#### Concepts Applied:

Shortest path, unordered map, for loops, priority queue, arrays, while loop, and if statements.

### Solution July 29, 2024 (C++, leetcode) 1395. Count Number of Teams (Medium)
In .LeetcodeDailySolution folder as July29,2024.cpp

#### Prompt:

There are n soldiers standing in a line. Each soldier is assigned a unique rating value.

You have to form a team of 3 soldiers amongst them under the following rules:

Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).
A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).
Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).

#### Solution:

    class Solution {
    public:
    static int numTeams(vector<int>& rating) {

        const int n = rating.size();

        int cnt = 0;

        for (int i = 1; i < n - 1; i++) {

            int L[2] = {0}, R[2] = {0};

            for (int j = 0; j < i; j++)
                L[rating[j] < rating[i]]++;

            for (int k = i + 1; k < n; k++)
                R[rating[k] < rating[i]]++;

            cnt += L[0] * R[1] + L[1] * R[0];
        }

        return cnt;
      }
    };

Runtime: 29 ms, beating 64.86% of leetcode users solutions using C++.
Memory: 11.61 mb, beating 72.06% of leetcode users solutions using C++.

#### Concepts Applied:

Array, nested for loop, and counting.

### Solution July 30, 2024 (C++, leetcode) 1653. Minimum Deletions to Make String Balanced (Medium)
In .LeetcodeDailySolution folder as July30,2024.cpp

#### Prompt:

You are given a string s consisting only of characters 'a' and 'b'​​​​.

You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'.

Return the minimum number of deletions needed to make s balanced.

#### Solution:

    class Solution {
    public:
    static int minimumDeletions(string& s) {

        const int n = s.size();

        int cntA = 0, ans = 0;

        for (int i = n - 1; i >= 0; i--) {

            if (s[i] == 'a')
                cntA++;

            else
                ans = min(ans + 1, cntA);
        }

        return ans;
      }
    };

Runtime: 75 ms, beating 79.61% of leetcode users solutions using C++.
Memory: 19.94 mb, beating 98.61% of leetcode users solutions using C++.

#### Concepts Applied:

Iteration, dynamic programming, for loop, if statement, and else statement.

### Solution July 31, 2024 (C++, leetcode) 1105. Filling Bookcase Shelves (Medium)
In .LeetcodeDailySolution folder as July31,2024.cpp

#### Prompt:

You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. You are also given an integer shelfWidth.

We want to place these books in order onto bookcase shelves that have a total width shelfWidth.

We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.

Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.

For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.
Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.

#### Solution:

    class Solution {
    public:
    int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {

        int n = books.size();
        int f[n + 1];

        f[0] = 0;

        for (int i = 1; i <= n; ++i) {

            int w = books[i - 1][0], h = books[i - 1][1];

            f[i] = f[i - 1] + h;

            for (int j = i - 1; j > 0; --j) {

                w += books[j - 1][0];

                if (w > shelfWidth) {
                    break;
                }

                h = max(h, books[j - 1][1]);
                f[i] = min(f[i], f[j - 1] + h);

            }
        }
        
        return f[n];
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.80 mb, beating 74.85% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, dynamic programming, for loops, and if statement. 

### Solution Aug 1, 2024 (C++, leetcode) 2678. Number of Senior Citizens (Easy)
In .LeetcodeDailySolution folder as Aug1,2024.cpp

#### Prompt:

You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:

The first ten characters consist of the phone number of passengers.
The next character denotes the gender of the person.
The following two characters are used to indicate the age of the person.
The last two characters determine the seat allotted to that person.
Return the number of passengers who are strictly more than 60 years old.

#### Solution:

    class Solution {
    public:
    int countSeniors(vector<string>& details) {

        int ans = 0;

        for (int i = 0; i < details.size(); i++) {

            int age = (details[i][11] - '0') * 10 + (details[i][12] - '0');

            if (age > 60)
                ans++;
        }
        return ans;
      }
    };

Runtime: 4 ms, beating 82.84% of leetcode users solutions using C++.
Memory: 17.49 mb, beating 33.89% of leetcode users solutions using C++.

#### Concepts Applied:

ASCII, string, for loop, and if statement.

### Solution Aug 2, 2024 (C++, leetcode) 2134. Minimum Swaps to Group All 1's Together II (Medium)
In .LeetcodeDailySolution folder as Aug2,2024.cpp

#### Prompt:

A swap is defined as taking two distinct positions in an array and swapping the values in them.

A circular array is defined as an array where we consider the first element and the last element to be adjacent.

Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.

#### Solution:

    class Solution {
    public:
    int minSwaps(vector<int>& nums) {

        int k = accumulate(nums.begin(), nums.end(), 0);
        int n = nums.size();
        int cnt = accumulate(nums.begin(), nums.begin() + k, 0);
        int mx = cnt;

        for (int i = k; i < n + k; ++i) {

            cnt += nums[i % n] - nums[(i - k + n) % n];
            mx = max(mx, cnt);

        }
        
        return k - mx;
      }
    };

Runtime: 63 ms, beating 80.27% of leetcode users solutions using C++.
Memory: 83.06 mb, beating 58.03% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, counting, sliding window technique, for loop, and max.

### Solution Aug 3, 2024 (C++, leetcode) 1460. Make Two Arrays Equal by Reversing Subarrays (Easy)
In .LeetcodeDailySolution folder as Aug3,2024.cpp

#### Prompt:

You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty subarray of arr and reverse it. You are allowed to make any number of steps.

Return true if you can make arr equal to target or false otherwise.

#### Solution:

    class Solution {
    public:
    bool canBeEqual(vector<int>& target, vector<int>& arr) {

        sort(target.begin(),target.end());
        sort(arr.begin(),arr.end());
        
        return target == arr;
      }
    };

Runtime: 7 ms, beating 84.56% of leetcode users solutions using C++.
Memory: 17.47 mb, beating 58.54% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting and comparing.

### Solution Aug 4, 2024 (C++, leetcode) 1508. Range of Sorted Subarray Sums (Medium)
In .LeetcodeDailySolution folder as Aug4,2024.cpp

#### Prompt:

You are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.

Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    int rangeSum(vector<int>& nums, int n, int left, int right) {

        const int MOD = 1000000007;

        vector<int> subarraySums;
        
        for (int i = 0; i < n; i++) {

            int sum = 0;

            for (int j = i; j < n; j++) {
                sum += nums[j];
                subarraySums.push_back(sum);
            }
        }
        
        sort(subarraySums.begin(), subarraySums.end());
        
        long long rangeSum = 0;
        
        for (int i = left - 1; i < right; i++) {
            rangeSum = (rangeSum + subarraySums[i]) % MOD;
        }
        
        return static_cast<int>(rangeSum);
      }
    };

Runtime: 89 ms, beating 68.30% of leetcode users solutions using C++.
Memory: 27.35 mb, beating 22.39% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, iteration, subarrays, sorting, and modulus.

### Solution Aug 5, 2024 (C++, leetcode) 2053. Kth Distinct String in an Array (Easy)
In .LeetcodeDailySolution folder as Aug5,2024.cpp

#### Prompt:

A distinct string is a string that is present only once in an array.

Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string "".

Note that the strings are considered in the order in which they appear in the array.

#### Solution:

    class Solution {
    public:
    string kthDistinct(vector<string>& arr, int k) {

        unordered_map<string, int> counter;

        for (auto& v : arr)
            ++counter[v];

        for (auto& v : arr) {
            if (counter[v] == 1) {
                --k;
                if (k == 0)
                    return v;
            }
        }

        return "";
      }
    };

Runtime: 7 ms, beating 98.16% of leetcode users solutions using C++.
Memory: 18.45 mb, beating 63.70% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered map, arrays, hashing, for loops, and if statements.

### Solution Aug 6, 2024 (C++, leetcode) 3016. Minimum Number of Pushes to Type Word II (Medium)
In .LeetcodeDailySolution folder as Aug6,2024.cpp

#### Prompt:

You are given a string word containing lowercase English letters.

Telephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with ["a","b","c"], we need to push the key one time to type "a", two times to type "b", and three times to type "c" .

It is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word.

Return the minimum number of pushes needed to type word after remapping the keys.

An example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.

#### Solution:

    class Solution {
    public:
    int minimumPushes(string word) {

        vector<int> freq(26, 0);

        for (char c : word) {
            freq[c - 'a']++;
        }
        
        sort(freq.begin(), freq.end());
        
        int totalPushes = 0;
        int multiplier = 1;
        
        for (int i = 25; i >= 0; i--) {
            
            if (freq[i] == 0) break;
            
            if ((25 - i) % 8 == 0 && i != 25) {
                multiplier++;
            }
            
            totalPushes += freq[i] * multiplier;
        }
        
        return totalPushes;
      }
    };

Runtime: 69 ms, beating 73.41% of leetcode users solutions using C++.
Memory: 25.07 mb, beating 72.89% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, frequency counting, sorting, for loops, and if statements.

### Solution Aug 7, 2024 (C++, leetcode) 273. Integer to English Words (Hard)
In .LeetcodeDailySolution folder as Aug7,2024.cpp

#### Prompt:

Convert a non-negative integer num to its English words representation.

#### Solution:

    class Solution {
    public:
    vector<pair<int, string>> mp = {

        {1000000000, "Billion"},
        {1000000, "Million"},
        {1000, "Thousand"},
        {100, "Hundred"},
        {90, "Ninety"},
        {80, "Eighty"},
        {70, "Seventy"},
        {60, "Sixty"},
        {50, "Fifty"},
        {40, "Forty"},
        {30, "Thirty"},
        {20, "Twenty"},
        {19, "Nineteen"},
        {18, "Eighteen"},
        {17, "Seventeen"},
        {16, "Sixteen"},
        {15, "Fifteen"},
        {14, "Fourteen"},
        {13, "Thirteen"},
        {12, "Twelve"},
        {11, "Eleven"},
        {10, "Ten"},
        {9, "Nine"},
        {8, "Eight"},
        {7, "Seven"},
        {6, "Six"},
        {5, "Five"},
        {4, "Four"},
        {3, "Three"},
        {2, "Two"},
        {1, "One"}
    };

    string numberToWords(int num) {

        if (num == 0) {
            return "Zero";
        }

        for (auto it : mp) {
            if (num >= it.first) {
                string a = "";
                if (num >= 100) {
                    a = numberToWords(num / it.first) + " ";
                }

                string b = it.second;
                string c = "";

                if (num % it.first != 0) {
                    c = " " + numberToWords(num % it.first);
                }

                return a + b + c;
            }
        }

        return "";
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.42 mb, beating 19.58% of leetcode users solutions using C++.

#### Concepts Applied:

Map, strings, if statements, for loop, and math.

### Solution Aug 8, 2024 (C++, leetcode) 885. Spiral Matrix III (Medium)
In .LeetcodeDailySolution folder as Aug8,2024.cpp

#### Prompt:

You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.

You will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid.

Return an array of coordinates representing the positions of the grid in the order you visited them.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {

        vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; 
        vector<vector<int>> result = {{rStart, cStart}};

        int steps = 0, d = 0;
        
        while (result.size() < rows * cols) {

            if (d == 0 || d == 2) steps++;
            
            for (int i = 0; i < steps; i++) {
                
                rStart += directions[d][0];
                cStart += directions[d][1];
                
                if (rStart >= 0 && rStart < rows && cStart >= 0 && cStart < cols) {
                    result.push_back({rStart, cStart});
                }
                
                if (result.size() == rows * cols) return result;
            }
            
            d = (d + 1) % 4;
        }
        
        return result;
      }
    };

Runtime: 3 ms, beating 98.91% of leetcode users solutions using C++.
Memory: 14.03 mb, beating 9.14% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, grid, while loop, if statements, and for loop.

### Solution Aug 9, 2024 (C++, leeetcode) 840. Magic Squares In Grid (Medium)
In .LeetcodeDailySolution folder as Aug9,2024.cpp

#### Prompt:

A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.

Given a row x col grid of integers, how many 3 x 3 contiguous magic square subgrids are there?

Note: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.

#### Solution:

    class Solution {
    public:
    static bool isMagic(int i, int j, int a, int b, int c, int d,
                        vector<vector<int>>& grid) {

        return (a + grid[i - 1][j] + b == 15) &&
               (a + grid[i][j - 1] + c == 15) &&
               (b + grid[i][j + 1] + d == 15) && (c + grid[i + 1][j] + d == 15);
    }

    static int numMagicSquaresInside(vector<vector<int>>& grid) {
        const int r = grid.size(), c = grid[0].size();

        if (r < 3 || c < 3)
            return 0;

        int cnt = 0;

        for (int i = 1; i < r - 1; i++) {
            for (int j = 1; j < c - 1; j++) {
                if (grid[i][j] != 5)
                    continue;

                int a = grid[i - 1][j - 1], b = grid[i - 1][j + 1],
                    c = grid[i + 1][j - 1], d = grid[i + 1][j + 1];
                bitset<16> once =
                    (1 << a) + (1 << b) + (1 << c) + (1 << d) + (1 << 5);

                if (once.count() == 5 && (a & 1) == 0 && a + d == 10 &&
                    (b & 1) == 0 && b + c == 10)
                    cnt += isMagic(i, j, a, b, c, d, grid);
            }
        }
        
        return cnt;
      }
    };

Runtime: 2 ms, beating 65.89% of leetcode users solutions using C++.
Memory: 10.23 mb, beating 99.25% of leetcode users solutions using C++.

#### Concepts Applied:

Math, magic square, arrays, matrix, grid, if statements, for loops, and bitset.

### Solution Aug 10, 2024 (C++, leetcode) 959. Regions Cut By Slashes (Medium)
In .LeetcodeDailySolution folder as Aug10,2024.cpp

#### Prompt:

An n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a '/', '\', or blank space ' '. These characters divide the square into contiguous regions.

Given the grid grid represented as a string array, return the number of regions.

Note that backslash characters are escaped, so a '\' is represented as '\\'.

#### Solution:

    class Solution {
    public:
    void dfs(int i, int j, vector<vector<int>>& mat, vector<vector<int>>& vis) {

        vis[i][j] = 1;
        int n = mat.size(), m = mat[0].size();
        int delr[] = {-1, 0, 1, 0};
        int delc[] = {0, 1, 0, -1};

        for (int k = 0; k < 4; k++) {

            int nrow = i + delr[k], ncol = j + delc[k];

            if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= m ||
                mat[nrow][ncol] != 0 || vis[nrow][ncol])
                continue;

            dfs(nrow, ncol, mat, vis);
        }
    }
    int regionsBySlashes(vector<string>& grid) {

        int n = grid.size();
        vector<vector<int>> mat(n * 3, vector<int>(n * 3, 0));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '/') {
                    mat[i * 3][j * 3 + 2] = 1;
                    mat[i * 3 + 1][j * 3 + 1] = 1;
                    mat[i * 3 + 2][j * 3] = 1;
                } else if (grid[i][j] == '\\') {
                    mat[i * 3][j * 3] = 1;
                    mat[i * 3 + 1][j * 3 + 1] = 1;
                    mat[i * 3 + 2][j * 3 + 2] = 1;
                }
            }
        } 
        int count = 0;
        vector<vector<int>> vis(n * 3, vector<int>(n * 3, 0));

        for (int i = 0; i < n * 3; i++) {
            for (int j = 0; j < n * 3; j++) {
                if (mat[i][j] == 0 && !vis[i][j]) {
                    count++;
                    dfs(i, j, mat, vis);
                }
            }
        }
        
        return count;
      }
    };

Runtime: 15 ms, beating 32.82% of leetcode users solutions using C++.
Memory: 15.65 mb, beating 26.69% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, matrix, grid, strings, arrays, for loops, and if statements.

### Solution Aug 11, 2024 (C++, leetcode) 1568. Minimum Number of Days to Disconnect Island (Hard)
In .LeetcodeDailySolution folder as Aug11,2024.cpp

#### Prompt:

You are given an m x n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's.

The grid is said to be connected if we have exactly one island, otherwise is said disconnected.

In one day, we are allowed to change any single land cell (1) into a water cell (0).

Return the minimum number of days to disconnect the grid.

#### Solution:

    class Solution {
    public:
    void dfs(int i, int j, vector<vector<int>>& visited, int m, int n,
             vector<vector<int>>& grid) {

        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] == 1 ||
            grid[i][j] == 0) {

            return;
        }

        visited[i][j] = 1;

        dfs(i + 1, j, visited, m, n, grid);
        dfs(i - 1, j, visited, m, n, grid);
        dfs(i, j + 1, visited, m, n, grid);
        dfs(i, j - 1, visited, m, n, grid);
    }

    int islandcount(vector<vector<int>>& grid) {

        int m = grid.size();
        int n = grid[0].size();

        vector<vector<int>> visited(m, vector<int>(n, 0));
        int islands = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1 && visited[i][j] == 0) {
                    dfs(i, j, visited, m, n, grid);
                    islands++;
                }
            }
        }

        return islands;
    }

    int minDays(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        int islands = islandcount(grid);

        if (islands > 1 || islands == 0) {
            return 0;
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    grid[i][j] = 0;
                    islands = islandcount(grid);

                    if (islands > 1 || islands == 0) {
                        return 1;
                    }

                    grid[i][j] = 1;
                }
            }
        }

        return 2;
      }
    };

Runtime: 63 ms, beating 67.86% of leetcode users solutions using C++.
Memory: 25.50 mb, beating 43.96% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, matrix, binary grid, if statements, and for loops.

### Solution Aug 12, 2024 (C++, leetcode) 703. Kth Largest Element in a Stream (Easy)
In .LeetcodeDailySolution folder as Aug12,2024.cpp

#### Prompt:

Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Implement KthLargest class:

KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.
int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.

#### Solution:

    class KthLargest {
    public:

    int k;
    priority_queue<int, vector<int>, greater<int>> pq;

    KthLargest(int k, vector<int>& nums) : k(k) {

        for (int x : nums) {
            pq.push(x);

            if (pq.size() > k)
                pq.pop();
        }
    }
    int add(int val) {
        pq.push(val);

        if (pq.size() > k)
            pq.pop();

        return pq.top();
      }
    };

Runtime: 25 ms, beating 67.33% of leetcode users solutions using C++.
Memory: 24.74 mb, beating 40.40% of leetcode users solutions using C++.

#### Concepts Applied:

Priority queue, arrays, for loop, and if statements.

### Solution Aug 13, 2024 (C++, leetcode) 40. Combination Sum II (Medium)
In .LeetcodeDailySolution folder as Aug13,2024.cpp

#### Prompt:

Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.

Each number in candidates may only be used once in the combination.

Note: The solution set must not contain duplicate combinations.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {

        sort(candidates.begin(), candidates.end());

        vector<vector<int>> ans;
        vector<int> ds;

        findCombination(0, target, candidates, ans, ds);

        return ans;
    }
    void findCombination(int ind, int target, vector<int>& arr,
                         vector<vector<int>>& ans, vector<int>& ds) {

        if (target == 0) {
            ans.push_back(ds);
            return;
        }

        for (int i = ind; i < arr.size(); i++) {
            if (i > ind && arr[i] == arr[i - 1])
                continue;
            if (arr[i] > target)
                break;
                
            ds.push_back(arr[i]);
            findCombination(i + 1, target - arr[i], arr, ans, ds);
            ds.pop_back();
        }
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.80 mb, beating 66.93% of leetcode users solutions using C++.

#### Concepts Applied:

Backtracking, sorting, arrays, combinations, for loop, and if statements.

### Solution Aug 14, 2024 (C++, leetcode) 719. Find K-th Smallest Pair Distance (Hard)
In .LeetcodeDailySolution folder as Aug14,2024.cpp

#### Prompt:

The distance of a pair of integers a and b is defined as the absolute difference between a and b.

Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.

#### Solution:

    class Solution {
    public:
    int smallestDistancePair(vector<int>& nums, int k) {

        sort(nums.begin(), nums.end());
        
        int n = nums.size();
        int low = 0, high = nums[n - 1] - nums[0];

        auto count_pairs = [&](int max_distance) {

            int count = 0, j = 0;

            for (int i = 0; i < n; ++i) {
                
                while (j < n && nums[j] - nums[i] <= max_distance)
                    ++j;

                count += j - i - 1;
            }

            return count;
        };

        while (low < high) {

            int mid = low + (high - low) / 2;

            if (count_pairs(mid) < k)
                low = mid + 1;
            else
                high = mid;
        }

        return low;
      }
    };

Runtime: 7 ms, beating 83.74% of leetcode users solutions using C++.
Memory: 12.94 mb, beating 26.29% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search, two-pointers, arrays, sorting, for loop, while loops, if statement, and else statement.

### Solution Aug 15, 2024 (C++, leetcode) 860. Lemonade Change (Easy)
In .LeetcodeDailySolution folder as Aug15,2024.cpp

#### Prompt:

At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.

Note that you do not have any change in hand at first.

Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.

#### Solution:

    class Solution {
    public:
    bool lemonadeChange(vector<int>& bills) {

        int c5 = 0, c10 = 0;

        for (auto bill : bills) {

            if (bill == 5)
                c5++;

            else if (bill == 10 && c5 >= 1) {
                c10++;
                c5--;

            } else if (bill == 20 && c10 >= 1 && c5 >= 1) {
                c10--;
                c5--;

            } else if (bill == 20 && c5 >= 3) {
                c5 -= 3;

            } else

                return false;
        }
        
        return true;
      }
    };

Runtime: 68 ms, beating 74.03% of leetcode users solutions using C++.
Memory: 85.91 mb, beating 50.86% of leetcode users solutions using C++.

#### Concepts Applied:

Array, for loop, simple if-else-else if statement.

### Solution Aug 16, 2024 (C++, leetcode) 624. Maximum Distance in Arrays (Medium)
In .LeetcodeDailySolution folder as Aug16,2024.cpp

#### Prompt:

You are given m arrays, where each array is sorted in ascending order.

You can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a - b|.

Return the maximum distance.

#### Solution:

    class Solution {
    public:
    static int maxDistance(vector<vector<int>>& arrays) {

        int xMin = 1e5, xMax = -1e5;
        int diff = 0;
        int m = arrays.size();

        for (auto& arr : arrays) {

            int a0 = arr[0], aN = arr.back();
            
            diff = max({diff, aN - xMin, xMax - a0});
            xMin = min(a0, xMin);
            xMax = max(aN, xMax);
        }
        
        return diff;
      }
    };

Runtime: 222 ms, beating 81.13% of leetcode users solutions using C++.
Memory: 107.88 mb, beating 57.08% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, greedy, 1 pass, for loop, max, and min.

### Solution Aug 17, 2024 (C++, leetcode) 1937. Maximum Number of Points with Cost (Medium)
In .LeetcodeDailySolution folder as Aug17,2024.cpp

#### Prompt:

You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix.

To gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score.

However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows r and r + 1 (where 0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score.

Return the maximum number of points you can achieve.

abs(x) is defined as:

x for x >= 0.
-x for x < 0.

#### Solution:

    class Solution {
    public:
    long long maxPoints(vector<vector<int>>& points) {

        int row = points.size();
        int col = points[0].size();
        vector<long long> dp(col, 0);
        
        for(int i = 0; i < col; i++) {
            dp[i] = points[0][i];
        }
        
        for(int r = 1; r < row; r++) {

            vector<long long> leftMax(col, 0), rightMax(col, 0);
            vector<long long> newDp(col, 0);
            
            leftMax[0] = dp[0];

            for(int i = 1; i < col; i++) {
                leftMax[i] = max(leftMax[i-1], dp[i] + i);
            }
            rightMax[col-1] = dp[col-1] - (col-1);

            for(int i = col-2; i >= 0; i--) {
                rightMax[i] = max(rightMax[i+1], dp[i] - i);
            }
            
            for(int i = 0; i < col; i++) {
                newDp[i] = max(leftMax[i] - i, rightMax[i] + i) + points[r][i];
            }
            
            dp = newDp;
        }
        
        return *max_element(dp.begin(), dp.end());
      }
    };

Runtime: 211 ms, beating 40.58% of leetcode users solutions using C++.
Memory: 129.20 mb, beating 30.24% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, dynamic programming, two pass, for loops, and max.

### Solution Aug 18, 2024 (C++, leetcode) 264. Ugly Number II (Medium)
In .LeetcodeDailySolution folder as Aug18,2024.cpp

#### Prompt:

An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.

Given an integer n, return the nth ugly number.

#### Solution:

    class Solution {
    public:
    int nthUglyNumber(int n) {

        vector<int> dp(n);
        dp[0] = 1;

        int p1 = 0;
        int p2 = 0;
        int p3 = 0;

        for (int i = 1; i < n; i++) {

            int twoMul = dp[p1] * 2;
            int threeMul = dp[p2] * 3;
            int fiveMul = dp[p3] * 5;

            dp[i] = min(twoMul, min(threeMul, fiveMul));

            if (dp[i] == twoMul)
                p1++;
            if (dp[i] == threeMul)
                p2++;
            if (dp[i] == fiveMul)
                p3++;
        }

        return dp[n - 1];
      }
    };

Runtime: 6 ms, beating 56.38% of leetcode users solutions using C++.
Memory: 9.72 mb, beating 56.70% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, dynamic programming, for loop, and if statements.

### Solution Aug 19, 2024 (C++, leetcode) 650. 2 Keys Keyboard (Medium)
In .LeetcodeDailySolution folder as Aug19,2024.cpp

#### Prompt:

There is only one character 'A' on the screen of a notepad. You can perform one of two operations on this notepad for each step:

Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).
Paste: You can paste the characters which are copied last time.
Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.

#### Solution:

    class Solution {
    public:
    int minSteps(int n) {

        if (n == 1)
            return 0;

        int steps = 0;
        int factor = 2;

        while (n > 1) {
            while (n % factor == 0) {
                steps += factor;
                n /= factor;
            }
            
            factor++;
        }

        return steps;
      }
    };

Runtime: 2 ms, beating 76.41% of leetcode users solutions using C++.
Memory: 7.49 mb, beating 71.95% of leetcode users solutions using C++.

#### Concepts Applied:

Factorization, divison, if statement, and while loops.

### Solution Aug 20, 2024 (C++, leetcode) 1140. Stone Game II (Medium)
In .LeetcodeDailySolution folder as Aug20,2024.cpp

#### Prompt:

Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones. 

Alice and Bob take turns, with Alice starting first.  Initially, M = 1.

On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).

The game continues until all the stones have been taken.

Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.

#### Solution:

    class Solution {
    public:
    int stoneGameII(vector<int>& piles) {

        int n = piles.size();

        vector<vector<int>> dp(n, vector<int>(n + 1, 0));
        vector<int> suffixSum(n, 0);
        
        suffixSum[n - 1] = piles[n - 1];

        for (int i = n - 2; i >= 0; i--) {
            suffixSum[i] = suffixSum[i + 1] + piles[i];
        }

        for (int i = n - 1; i >= 0; i--) {
            for (int m = 1; m <= n; m++) {
                if (i + 2 * m >= n) {
                    dp[i][m] = suffixSum[i];
                } else {
                    for (int x = 1; x <= 2 * m; x++) {
                        dp[i][m] =
                            max(dp[i][m], suffixSum[i] - dp[i + x][max(m, x)]);
                    }
                }
            }
        }

        return dp[0][1];
      }
    };

Runtime: 16 ms, beating 64.93% of leetcode users solutions using C++.
Memory: 12.35 mb, beating 61.31% of leetcode users solutions using C++.

#### Concepts Applied:

Suffix sum, dynamic programming table, arrays, for loops, if statement, and else statement.

### Solution Aug 21, 2024 (C++, leetcode) 664. Strange Printer (Hard)
In .LeetcodeDailySolution folder as Aug21,2024.cpp

#### Prompt:

There is a strange printer with the following two special properties:

The printer can only print a sequence of the same character each time.
At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.
Given a string s, return the minimum number of turns the printer needed to print it.

#### Solution:

    class Solution {
    public:
    int strangePrinter(string s) {

        int n = s.length();
        vector<vector<int>> dp(n, vector<int>(n, -1));
        return Util(0, n - 1, s, dp);
    }
    
    int Util(int i, int j, const string& s, vector<vector<int>>& dp) {

        if (i > j) {
            return 0;
        }

        if (dp[i][j] != -1)
            return dp[i][j];

        char firstLetter = s[i];
        int answer = 1 + Util(i + 1, j, s, dp);

        for (int k = i + 1; k <= j; k++) {
            if (s[k] == firstLetter) {

                int betterAnswer =
                    Util(i, k - 1, s, dp) + Util(k + 1, j, s, dp);

                answer = min(answer, betterAnswer);
            }
        }

        return dp[i][j] = answer;
      }
    };

Runtime: 17 ms, beating 67.58% of leetcode users solutions using C++.
Memory: 11.28 mb, beating 38.69% of leetcode users solutions using C++.

#### Concepts Applied:

Backtracking, arrays, strings, if statements, dynamic programming, and for loop.

### Solution Aug 22, 2024 (C++, leetcode) 476. Number Complement (Easy)
In .LeetcodeDailySolution folder as Aug22,2024.cpp

#### Prompt:

The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.

For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
Given an integer num, return its complement.

#### Solution:

    class Solution {
    public:
    static int findComplement(int num) {

        if (num == 1)
            return 0;

        int ans = 0;

        for (int b = 0; num; b++, num >>= 1) { 
            ans += (1 - (num & 1)) << b;       
        }
        
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.32 mb, beating 65.77% of leetcode users solutions using C++.

#### Concepts Applied:

If statement, for loop, and bit manipulation.

### Solution Aug 24, 2024 (C++, leetcode) 564. Find the Closest Palindrome (Hard)
In .LeetcodeDailySolution folder as Aug24,2024.cpp

#### Prompt:

Given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one.

The closest is defined as the absolute difference minimized between two integers.

#### Solution:

    class Solution {
    public:
    string nearestPalindromic(string numberStr) {

        long long number = stoll(numberStr);

        if (number <= 10)
            return to_string(number - 1);
        if (number == 11)
            return "9";

        int length = numberStr.length();
        long long leftHalf = stoll(numberStr.substr(0, (length + 1) / 2));
        vector<long long> palindromeCandidates(5);

        palindromeCandidates[0] =
            generatePalindromeFromLeft(leftHalf - 1, length % 2 == 0);
        palindromeCandidates[1] =
            generatePalindromeFromLeft(leftHalf, length % 2 == 0);
        palindromeCandidates[2] =
            generatePalindromeFromLeft(leftHalf + 1, length % 2 == 0);
        palindromeCandidates[3] = pow(10, length - 1) - 1;
        palindromeCandidates[4] = pow(10, length) + 1;

        long long nearestPalindrome = 0;
        long long minDifference = LLONG_MAX;

        for (long long candidate : palindromeCandidates) {
            if (candidate == number)
                continue;

            long long difference = abs(candidate - number);

            if (difference < minDifference || (difference == minDifference &&
                                               candidate < nearestPalindrome)) {
                minDifference = difference;
                nearestPalindrome = candidate;
            }
        }

        return to_string(nearestPalindrome);
    }

    private:
    long long generatePalindromeFromLeft(long long leftHalf,
                                         bool isEvenLength) {

        long long palindrome = leftHalf;

        if (!isEvenLength)
            leftHalf /= 10;
        while (leftHalf > 0) {
            palindrome = palindrome * 10 + leftHalf % 10;
            leftHalf /= 10;
        }

        return palindrome;
      }
    };

Runtime: 3 ms, beating 46.80% of leetcode users solutions using C++.
Memory: 7.87 mb, beating 96.47% of leetcode users solutions using C++.
 
#### Concepts Applied:

Palindromes, strings, if statements, arrays, for loop, and while loop.

### Solution Aug 26, 2024 (C++, leetcode) 590. N-ary Tree Postorder Traversal (Easy)
In .LeetcodeDailySolution folder as Aug26,2024.cpp

#### Prompt:

Given the root of an n-ary tree, return the postorder traversal of its nodes' values.

Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

#### Solution:

    class Solution {
    public:
    vector<int> postorder(Node* root) {

        if (!root)
            return {};

        vector<int> res;

        function<void(Node*)> dfs = [&](Node* node) {
            for (Node* child : node->children) {
                dfs(child);
            }

            res.push_back(node->val);
        };

        dfs(root);

        return res;
      }
    };

Runtime: 13 ms, beating 64.20% of leetcode users solutions using C++.
Memory: 15.28 mb, beating 51.23% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, arrays, and for loop.

### Solution Aug 27, 2024 (C++, leetcode) 1. Two Sum (Easy)
In .LeetcodeDailySolution folder as Aug27,2024.cpp

#### Prompt:

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

#### Solution:

    class Solution {
    public:
    vector<int> twoSum(vector<int>& nums, int target) {

        int n = nums.size();

        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }

        return {};
      }
    };

Runtime: 49 ms, beating 36.90% of leetcode users solutions using C++.
Memory: 13 mb, beating 70.65% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, and if statement.

### Solution Aug 28, 2024 (C++, leetcode) 1905. Count Sub Islands (Medium)
In .LeetcodeDailySolution folder as Aug28,2024.cpp

#### Prompt:

You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.

An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.

Return the number of islands in grid2 that are considered sub-islands.

#### Solution:

    class Solution {
    public:

    int r, c;
    const int d[5] = {0, 1, 0, -1, 0};

    inline bool outside(int i, int j) {
        return i < 0 || i >= r || j < 0 || j >= c;
    }

    bool dfs(int i, int j, int mark, vector<vector<int>>& grid1,
             vector<vector<int>>& grid2) {

        if (grid1[i][j] != 1)
            return false;

        grid2[i][j] = mark;

        bool isSub = true;

        for (int a = 0; a < 4; a++) {

            int s = i + d[a], t = j + d[a + 1];

            if (outside(s, t) || grid2[s][t] != 1)
                continue;

            if (grid1[s][t] != 1)
                isSub = false;

            if (!dfs(s, t, mark, grid1, grid2))
                isSub = false;
        }

        return isSub;
    }

    int countSubIslands(vector<vector<int>>& grid1,
                        vector<vector<int>>& grid2) {

        r = grid1.size();
        c = grid1[0].size();
        int cnt = 0, mark = 2;

        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                if (grid2[i][j] == 1) {

                    cnt += dfs(i, j, mark++, grid1, grid2);
                }
            }
        }

        return cnt;
      }
    };

Runtime: 212 ms, beating 66.93% of leetcode users solutions using C++.
Memory: 92.80 mb, beating 89.12% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, arrays, depth-first search, if statements, for loops, and grid.

### Solution Aug 29, 2024 (C++, leetcode) 947. Most Stones Removed with Same Row or Column (Medium)
In .LeetcodeDailySolution folder as Aug29,2024.cpp

#### Prompt:

On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.

A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.

Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.

#### Solution:

    class Solution {
    public:
    void dfs(int& n, int idx, vector<bool>& visited,
             vector<vector<int>>& stones) {

        visited[idx] = true;

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                if (stones[idx][0] == stones[i][0])
                    dfs(n, i, visited, stones);

                if (stones[idx][1] == stones[i][1])
                    dfs(n, i, visited, stones);
            }
        }
    }
    int removeStones(vector<vector<int>>& stones) {

        int n = stones.size();
        int group = 0;

        vector<bool> visited(n);

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(n, i, visited, stones);
                group += 1;
            }
        }

        return n - group;
      }
    };

Runtime: 214 ms, beating 5.07% of leetcode users solutions using C++.
Memory: 18 mb, beating 85.97% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, for loops, if statements, arrays, and grid.

### Solution Aug 30, 2024 (C++, leetcode) 2699. Modify Graph Edge Weights (Hard)
In .LeetcodeDailySolution folder as Aug30,2024.cpp

#### Prompt:

You are given an undirected weighted connected graph containing n nodes labeled from 0 to n - 1, and an integer array edges where edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and bi with weight wi.

Some edges have a weight of -1 (wi = -1), while others have a positive weight (wi > 0).

Your task is to modify all edges with a weight of -1 by assigning them positive integer values in the range [1, 2 * 109] so that the shortest distance between the nodes source and destination becomes equal to an integer target. If there are multiple modifications that make the shortest distance between source and destination equal to target, any of them will be considered correct.

Return an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from source to destination equal to target, or an empty array if it's impossible.

Note: You are not allowed to modify the weights of edges with initial positive weights.

#### Solution:

    class Solution {
    public:
    using int2 = pair<int, int>;

    int n, m;
    vector<vector<int2>> adj;
    vector<int> wild_edges;

    inline void build_graph(vector<vector<int>>& edges) {

        for (int i = 0; i < m; i++) {

            auto& e = edges[i];
            int u = e[0], v = e[1], w = e[2];

            if (w > 0) {
                adj[u].emplace_back(w, v);
                adj[v].emplace_back(w, u);
            } else {
                wild_edges.push_back(i);
            }
        }
    }
    int dijkstra(int src, int des, vector<vector<int2>>& adj) {

        int dist[100];
        fill(dist, dist + n, INT_MAX);
        priority_queue<int2, vector<int2>, greater<int2>> pq;
        pq.emplace(0, src);
        dist[src] = 0;

        while (!pq.empty()) {

            auto [d0, i] = pq.top();
            pq.pop();

            if (i == des)
                return d0;

            for (auto& [d_next, j] : adj[i]) {

                int new_d = d0 + d_next;

                if (new_d < dist[j]) {
                    dist[j] = new_d;
                    pq.emplace(new_d, j);
                }
            }
        }

        return INT_MAX;
    }
    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges,
                                           int source, int destination,
                                           int target) {

        this -> n = n;
        adj.resize(n);
        m = edges.size();
        build_graph(edges);
        int dist = dijkstra(source, destination, adj);

        if (dist < target)
            return {};

        for (auto i : wild_edges)

            edges[i][2] = target + 1;

        if (dist == target)
            return edges;

        for (auto i : wild_edges) {

            auto& new_edge = edges[i];
            int u = new_edge[0], v = new_edge[1];
            new_edge[2] = 1;
            adj[u].emplace_back(1, v);
            adj[v].emplace_back(1, u);
            dist = dijkstra(source, destination, adj);

            if (dist <= target) {
                new_edge[2] += target - dist;
                
                return edges;
            }
        }

        return {};
      }
    };

Runtime: 586 ms, beating 65.18% of leetcode users solutions using C++.
Memory: 240.66 mb, beating 85.02% of leetcode users solutions using C++.

#### Concepts Applied:

Dijkstra's algorithm, breadth-first search, min heap, arrays, for loops, if statements, while loop, and else statement.

### Solution Aug 31, 2024 (C++, leetcode) 1514. Path with Maximum Probability (Medium)
In .LeetcodeDailySolution folder as Aug31,2024.cpp

#### Prompt:

You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].

Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.

If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.

#### Solution:

    class Solution {
    public:
    double maxProbability(int n, vector<vector<int>>& edges,
                          vector<double>& succProb, int start_node,
                          int end_node) {

        vector<double> maxProb(n, 0.0);
        maxProb[start_node] = 1.0;

        for (int i = 0; i < n - 1; ++i) {

            bool updated = false;

            for (int j = 0; j < edges.size(); ++j) {

                int u = edges[j][0];
                int v = edges[j][1];
                double prob = succProb[j];

                if (maxProb[u] * prob > maxProb[v]) {
                    maxProb[v] = maxProb[u] * prob;
                    updated = true;
                }
                if (maxProb[v] * prob > maxProb[u]) {
                    maxProb[u] = maxProb[v] * prob;
                    updated = true;
                }
            }
            if (!updated)
                break;
        }

        return maxProb[end_node];
      }
    };

Runtime: 102 ms, beating 74.70% of leetcode users solutions using C++.
Memory: 53.28 mb, beating 90.01% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, maximum probability, bellman-ford algorithm, shortest path, for loop, and if statements.

### Solution Sept 1, 2024 (C++, leetcode) 2022. Convert 1D Array Into 2D Array (Easy)
In .LeetcodeDailySolution folder as Sept1,2024.cpp

#### Prompt:

You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.

The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.

Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.

#### Solution:

    class Solution {
    public:
    static vector<vector<int>> construct2DArray(vector<int>& original, int m,
                                                int n) {

        const int sz = original.size();

        if (sz != m * n)
            return {};

        vector<vector<int>> ans(m);

        for (int i = 0; i < m; i++) {
            ans[i].assign(original.begin() + i * n,
                          original.begin() + (i + 1) * n);
        }

        return ans;
      }
    };

Runtime: 76 ms, beating 70.32% of leetcode users solutions using C++.
Memory: 87.57 mb, beating 97.55% of leetcode users solutions using C++.

#### Concepts Applied:

Vector assign, if statement, arrays, and for loop.

### Solution Sept 2, 2024 (C++, leetcode) 1894. Find the Student that Will Replace the Chalk (Medium)
In .LeetcodeDailySolution folder as Sept2,2024.cpp

#### Prompt:

There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.

You are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.

Return the index of the student that will replace the chalk pieces.

#### Solution:

    class Solution {
    public:
    int chalkReplacer(vector<int>& chalk, int initialChalkPieces) {

        long long totalChalkNeeded = 0;

        for (int studentChalkUse : chalk) {
            totalChalkNeeded += studentChalkUse;
        }
        
        int remainingChalk = initialChalkPieces % totalChalkNeeded;
        
        for (int studentIndex = 0; studentIndex < chalk.size(); studentIndex++) {

            if (remainingChalk < chalk[studentIndex]) {
                
                return studentIndex;
            }

            remainingChalk -= chalk[studentIndex];
        }
        
        return 0;
      }
    };

Runtime: 90 ms, beating 75.25% of leetcode users solutions using C++.
Memory: 77.01 mb, beating 53.48% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, modulo, and if statement.

### Solution Sept 5, 2024 (C++, leetcode) 2028. Find Missing Observations (Medium)
In .LeetcodeDailySolution folder as Sept5,2024.cpp

#### Prompt:

You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls. Fortunately, you have also calculated the average value of the n + m rolls.

You are given an integer array rolls of length m where rolls[i] is the value of the ith observation. You are also given the two integers mean and n.

Return an array of length n containing the missing observations such that the average value of the n + m rolls is exactly mean. If there are multiple valid answers, return any of them. If no such array exists, return an empty array.

The average value of a set of k numbers is the sum of the numbers divided by k.

Note that mean is an integer, so the sum of the n + m rolls should be divisible by n + m.

#### Solution:

    class Solution {
    public:
    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {

        int nNumsSum = 0;

        for (int i : rolls)
            nNumsSum += i;

        int m = rolls.size();
        int totalLength = n + m;

        int mNumsSum = mean * totalLength - nNumsSum;

        if (n * 6 < mNumsSum || mNumsSum < n)
            return {};

        int rem = mNumsSum % n;
        int q = mNumsSum / n;

        vector<int> res(n, q);

        for (int i = 1; i <= rem; i++)
            res[i]++;

        return res;
      }
    };

Runtime: 100 ms, beating 48.90% of leetcode users solutions using C++.
Memory: 116.32 mb, beating 69.59% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, total sum, for loops, and if statement.

### Solution Sept 6, 2024 (C++, leetcode) 3217. Delete Nodes From Linked List Present in Array (Medium)
In .LeetcodeDailySolution folder as Sept6,2024.cpp

#### Prompt:

You are given an array of integers nums and the head of a linked list. Return the head of the modified linked list after removing all nodes from the linked list that have a value that exists in nums.

#### Solution:

    class Solution {
    public:
    ListNode* modifiedList(vector<int>& nums, ListNode* head) {

        bitset<100001> hasN = 0;

        for (int x : nums)
            hasN[x] = 1;

        ListNode dummy(0, head);
        ListNode *prev = &dummy, *tmp = NULL;

        for (ListNode* curr = head; curr; curr = curr -> next, delete tmp) {
            if (hasN[curr -> val]) {
                prev -> next = curr -> next;
                tmp = curr;
            } else {
                prev = prev->next;
                tmp = NULL;
            }
        }

        return dummy.next;
      }
    };

Runtime: 357 ms, beating 98.55% of leetcode users solutions using C++.
Memory: 227.94 mb, beating 96.65% of leetcode users solutions using C++.

#### Concepts Applied:

Bitset, linked list, array, for loop, if statement, and else statement.

### Solution Sept 7, 2024 (C++, leetcode) 1367. Linked List in Binary Tree (Medium)
In .LeetcodeDailySolution folder as Sept7,2024.cpp

#### Prompt:

Given a binary tree root and a linked list with head as the first node. 

Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False.

In this context downward path means a path that starts at some node and goes downwards.

#### Solution:

    class Solution {
    private:
    bool check(ListNode* head, TreeNode* root) {

        if (!root)
            return false;
        if (head->val != root->val) {
            return false;
        }
        if (head->next == NULL) {
            return true;
        }

        bool left = false;
        bool right = false;

        if (root->left && head->next && root->left->val == head->next->val) {
            left = check(head->next, root->left);
        }
        if (root->right && head->next && root->right->val == head->next->val) {
            right = check(head->next, root->right);
        }

        return left | right;
    }

    public:
    bool isSubPath(ListNode* head, TreeNode* root) {

        if (!root) {
            return false;
        }
        if (root->val == head->val) {
            if (check(head, root)) {
                return true;
            }
        }

        return isSubPath(head, root->left) | isSubPath(head, root->right);
      }
    };

Runtime: 20 ms, beating 84.05% of leetcode users solutions using C++.
Memory: 30.88 mb, beating 36.88% of leetcode users solutions using C++.

#### Concepts Applied:

Recursion, traversal, if statements, linked list, and binary tree.

### Solution Sept 9, 2024 (C++, leetcode) 2326. Spiral Matrix IV (Medium)
In .LeetcodeDailySolution folder as Sept9,2024.cpp

#### Prompt:

You are given two integers m and n, which represent the dimensions of a matrix.

You are also given the head of a linked list of integers.

Generate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1.

Return the generated matrix.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {
        vector<vector<int>> matrix(m, vector<int>(n, -1));

        int topRow = 0, bottomRow = m - 1, leftColumn = 0, rightColumn = n - 1;

        while (head) {

            for (int col = leftColumn; col <= rightColumn && head; ++col) {
                matrix[topRow][col] = head->val;
                head = head->next;
            }

            topRow++;

            for (int row = topRow; row <= bottomRow && head; ++row) {
                matrix[row][rightColumn] = head->val;
                head = head->next;
            }

            rightColumn--;

            for (int col = rightColumn; col >= leftColumn && head; --col) {
                matrix[bottomRow][col] = head->val;
                head = head->next;
            }

            bottomRow--;

            for (int row = bottomRow; row >= topRow && head; --row) {
                matrix[row][leftColumn] = head->val;
                head = head->next;
            }

            leftColumn++;
        }

        return matrix;
      }
    };

Runtime: 153 ms, beating 86.16% of leetcode users solutions using C++.
Memory: 130.59 mb, beating 66.17% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, arrays, traversal, while loop, and for loops.

### Solution Sept 10, 2024 (C++, leetcode) 2807. Insert Greatest Common Divisors in Linked List (Medium)
In .LeetcodeDailySolution folder as Sept10,2024.cpp

#### Prompt:

Given the head of a linked list head, in which each node contains an integer value.

Between every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.

Return the linked list after insertion.

The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.

#### Solution:

    class Solution {
    public:
    ListNode* insertGreatestCommonDivisors(ListNode* head) {

        if (head == nullptr || head->next == nullptr)
            return head;

        ListNode* node1 = head;
        ListNode* node2 = head->next;

        while (node2 != nullptr) {

            int gcdValue = calculateGCD(node1->val, node2->val);
            ListNode* gcdNode = new ListNode(gcdValue);

            node1->next = gcdNode;
            gcdNode->next = node2;

            node1 = node2;
            node2 = node2->next;
        }

        return head;
    }

    private:
    int calculateGCD(int a, int b) {

        while (b != 0) {

            int temp = b;
            b = a % b;
            a = temp;
        }
        
        return a;
      }
    };

Runtime: 26 ms, beating 97.57% of leetcode users solutions using C++.
Memory: 35.21 mb, beating 98.83% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, greatest common diviser, if statement, and while loops.

### Solution Sept 11, 2024 (C++, leetcode) 2220. Minimum Bit Flips to Convert Number (Easy)
In .LeetcodeDailySolution folder as Sept11,2024.cpp

#### Prompt:

A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.

For example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.
Given two integers start and goal, return the minimum number of bit flips to convert start to goal.

#### Solution:

    class Solution {
    public:
    int minBitFlips(int start, int goal) {
        
        int xorResult = start ^ goal;
        int ans = 0;

        while (xorResult > 0) {
            ans += xorResult & 1;
            xorResult >>= 1;
        }

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.63 mb, beating 44.87% of leetcode users solutions using C++.

#### Concepts Applied:

Bitwise, and while loop.

### Solution Sept 12, 2024 (C++, leetcode) 1684. Count the Number of Consistent Strings (Easy)
In .LeetcodeDailySolution folder as Sept12,2024.cpp

#### Prompt:

You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.

Return the number of consistent strings in the array words.

#### Solution:

    class Solution {
    public:
    int countConsistentStrings(string& allowed, vector<string>& words) {

        bitset<26> ASet = 0;

        for (char c : allowed)

            ASet[c - 'a'] = 1;
        int cnt = 0;

        for (string& w : words) {

            bool consistent = 1;

            for (char c : w) {
                if (ASet[c - 'a'] == 0) {
                    consistent = 0;
                    break;
                }
            }

            cnt += consistent;
        }
        
        return cnt;
      }
    };

Runtime: 32 ms, beating 96.51% of leetcode users solutions using C++.
Memory: 33.84 mb, beating 87.08% of leetcode users solutions using C++.

#### Concepts Applied:

Bitset, traversal, for loops, and if statement.

### Solution Sept 13, 2024 (C++, leetcode) 1310. XOR Queries of a Subarray (Medium)
In .LeetcodeDailySolution folder as Sept13,2024.cpp

#### Prompt:

You are given an array arr of positive integers. You are also given the array queries where queries[i] = [lefti, righti].

For each query i compute the XOR of elements from lefti to righti (that is, arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti] ).

Return an array answer where answer[i] is the answer to the ith query.

#### Solution:

    class Solution {
    public:
    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {

        int n = arr.size();
        vector<int> pre(n);
        pre[0] = arr[0];
        
        for (int i = 1; i < n; ++i) {
            pre[i] = pre[i - 1] ^ arr[i];
        }
        
        vector<int> res(queries.size());
        
        for (int k = 0; k < queries.size(); ++k) {
            int i = queries[k][0];
            int j = queries[k][1];
            if (i == 0) {
                res[k] = pre[j];
            } else {
                res[k] = pre[j] ^ pre[i - 1];
            }
        }
        
        return res;
      }
    };

Runtime: 56 ms, beating 74.42% of leetcode users solutions using C++.
Memory: 41.67 mb, beating 84% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, XOR, for loops, if statement, and else statement.

### Solution Sept 14, 2024 (C++, leetcode) 2419. Longest Subarray With Maximum Bitwise AND (Medium)
In .LeetcodeDailySolution folder as Sept14,2024.cpp

#### Prompt:

You are given an integer array nums of size n.

Consider a non-empty subarray from nums that has the maximum possible bitwise AND.

In other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered.
Return the length of the longest such subarray.

The bitwise AND of an array is the bitwise AND of all the numbers in it.

A subarray is a contiguous sequence of elements within an array.

#### Solution:

    class Solution {
    public:
    static int longestSubarray(vector<int>& nums) {

        const int n = nums.size();
        int m = max_element(nums.begin(), nums.end()) - nums.begin();
        int maxLen = 0, x = nums[m];

        for (int i = m; i < n; i++) {
            int len = 0;

            while (i < n && nums[i] == x) {
                i++;
                len++;
            }

            maxLen = max(maxLen, len);
        }

        return maxLen;
      }
    };

Runtime: 99 ms, beating 76.05% of leetcode users solutions using C++.
Memory: 84.95 mb, beating 34.15% of leetcode users solutions using C++.

#### Concepts Applied:

One pass, arrays, bitwise, for loop, while loop, and max.

### Solution Sept 16, 2024 (C++, leetcode) 539. Minimum Time Difference (Medium)
In .LeetcodeDailySolution folder as Sept16,2024.cpp

#### Prompt:

Given a list of 24-hour clock time points in "HH:MM" format, return the minimum minutes difference between any two time-points in the list.

#### Solution:

    class Solution {
    public:
    int findMinDifference(vector<string>& timePoints) {

        vector<int> minutes(timePoints.size());

        for (int i = 0; i < timePoints.size(); ++i) {
            int h = stoi(timePoints[i].substr(0, 2));
            int m = stoi(timePoints[i].substr(3));
            minutes[i] = h * 60 + m;
        }

        sort(minutes.begin(), minutes.end());

        int minDiff = INT_MAX;

        for (int i = 0; i < minutes.size() - 1; ++i) {
            minDiff = min(minDiff, minutes[i + 1] - minutes[i]);
        }

        minDiff = min(minDiff, 24 * 60 - minutes.back() + minutes.front());

        return minDiff;
      }
    };

Runtime: 12 ms, beating 58.04% of leetcode users solutions using C++.
Memory: 17.44 mb, beating 88.08% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, strings, substrings, for loops, sorting, and min.

### Solution Sept 17, 2024 (C++, leetcode) 884. Uncommon Words from Two Sentences (Easy)
In .LeetcodeDailySolution folder as Sept17,2024.cpp

#### Prompt:

A sentence is a string of single-space separated words where each word consists only of lowercase letters.

A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.

Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.

#### Solution:

    class Solution {
    public:
    vector<string> uncommonFromSentences(string s1, string s2) {

        string s = s1 + " " + s2;
        stringstream str(s);

        cout << s1.max_size();

        unordered_map<string, int> um;
        string tmp;

        while (str >> tmp) {
            um[tmp]++;
        }

        vector<string> ans;

        for (auto& val : um) {

            if (val.second == 1) {
                ans.emplace_back(val.first); 
             }
        }

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.92 mb, beating 44.93% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, unordered map, while loop, array, for loop, and if statement. 

### Solution Sept 18, 2024 (C++, leetcode) 179. Largest Number (Medium)
In .LeetcodeDailySolution folder as Sept18,2024.cpp

#### Prompt:

Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.

Since the result may be very large, so you need to return a string instead of an integer.

#### Solution:

    class Solution {
    public:
    string largestNumber(vector<int>& nums) {

        vector<string> strs;

        for (int num : nums) {
            strs.push_back(to_string(num));
        }

        sort(strs.begin(), strs.end(), [](string &a, string &b) {
            return a + b > b + a;
        });

        if (strs[0] == "0") {
            return "0";
        }

        string ans = "";
        
        for (string &s : strs) {
            ans += s;
        }

        return ans;
      }
    };

Runtime: 7 ms, beating 61.52% of leetcode users solutions using C++.
Memory: 17.15 mb, beating 55.33% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, strings, sorting, for loops, and if statement.

### Solution Sept 19, 2024 (C++, leetcode) 241. Different Ways to Add Parentheses (Medium)
In .LeetcodeDailySolution folder as Sept19,2024.cpp

#### Prompt:

Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.

The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 104.

#### Solution:

    class Solution {
    public:
    vector<int> diffWaysToCompute(string expression) {

        vector<int> res;

        for (int i = 0; i < expression.size(); ++i) {

            char oper = expression[i];

            if (oper == '+' || oper == '-' || oper == '*') {

                vector<int> s1 = diffWaysToCompute(expression.substr(0, i));
                vector<int> s2 = diffWaysToCompute(expression.substr(i + 1));

                for (int a : s1) {
                    for (int b : s2) {
                        if (oper == '+')
                            res.push_back(a + b);
                        else if (oper == '-')
                            res.push_back(a - b);
                        else if (oper == '*')
                            res.push_back(a * b);
                    }
                }
            }
        }
        if (res.empty())
            res.push_back(stoi(expression));
            
        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.90 mb, beating 23.97% of leetcode users solutions using C++.

#### Concepts Applied:

Divide and conquer, strings, arrays, for loops, if statements, and else-if statements.

### Solution Sept 20, 2024 (C++, leetcode) 214. Shortest Palindrome (Hard)
In .LeetcodeDailySolution folder as Sept20,2024.cpp

#### Prompt:

You are given a string s. You can convert s to a palindrome by adding characters in front of it.

Return the shortest palindrome you can find by performing this transformation.

#### Solution:

    class Solution {
    public:
    string shortestPalindrome(string s) {

        int count = kmp(string(s.rbegin(), s.rend()), s);

        return string(s.rbegin(), s.rend()).substr(0, s.length() - count) + s;
    }

    private:
    int kmp(const string& txt, const string& patt) {

        string newString = patt + '#' + txt;
        vector<int> pi(newString.length(), 0);

        int i = 1, k = 0;

        while (i < newString.length()) {
            if (newString[i] == newString[k]) {
                k++;
                pi[i] = k;
                i++;
            } else {
                if (k > 0) {
                    k = pi[k - 1];
                } else {
                    pi[i] = 0;
                    i++;
                }
            }   
        }

        return pi.back();
      }
    };

Runtime: 7 ms, beating 64.08% of leetcode users solutions using C++.
Memory: 11.98 mb, beating 27.29% of leetcode users solutions using C++.

#### Concepts Applied:

KMP algorithm, strings, arrays, while loop, else statements, and if statement.

### Solution Sept 21, 2024 (C++, leetcode) 386. Lexicographical Numbers (Medium)
In .LeetcodeDailySolution folder as Sept21,2024.cpp

#### Prompt:

Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.

You must write an algorithm that runs in O(n) time and uses O(1) extra space. 

#### Solution:

    class Solution {
    public:
    static vector<int> lexicalOrder(int n) {

        vector<int> ans(n);

        int x = 1;

        for (int i = 0; i < n; i++) {

            ans[i] = x;

            if (x * 10 > n) {
                if (x == n)
                    x /= 10;
                x++;
                while (x % 10 == 0)
                    x /= 10;
            } else
                x *= 10;
        }

        return ans;
      }
    };

Runtime: 8 ms, beating 72.41% of leetcode users solutions using C++. 
Memory: 11.86 mb, beating 96.05% of leetcode users solutions using C++.

#### Concepts Applied:

Array, iteration, for loop, if statement, while loop, and else statement.

### Solution Sept 23, 2024 (C++, leetcode) 2707. Extra Characters in a String (Medium)
In .LeetcodeDailySolution folder as Sept23,2024.cpp

#### Prompt:

You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.

Return the minimum number of extra characters left over if you break up s optimally.

#### Solution:

    const int N = 26;

    struct Trie {

    Trie* next[N];
    bool isEnd = 0;

    Trie() { fill(next, next + N, (Trie*)NULL); }

    ~Trie() {
        for (int i = 0; i < N; ++i) {
            if (next[i] != NULL) {
                delete next[i];
            }
        }
    }

    void insert(string& word) {
        Trie* Node = this;
        for (char c : word) {
            int i = c - 'a';
            if (Node->next[i] == NULL)
                Node->next[i] = new Trie();
            Node = Node->next[i];
        }
        Node->isEnd = 1;
    }
    void insert(vector<string>& dictionary) {
        for (auto& word : dictionary)
            insert(word);
      }
    };

    class Solution {
    public:
    int minExtraChar(string s, vector<string>& dictionary) {

        Trie trie;
        trie.insert(dictionary);

        int n = s.size();
        vector<int> dp(n + 1, 0);

        for (int i = n - 1; i >= 0; i--) {

            dp[i] = dp[i + 1] + 1;
            Trie* node = &trie;

            for (int j = i; j < n; j++) {
                if (node->next[s[j] - 'a'] == NULL)
                    break;

                node = node->next[s[j] - 'a'];

                if (node->isEnd)
                    dp[i] = min(dp[i], dp[j + 1]);
            }
        }

        return dp[0];
      }
    };

Runtime: 63 ms, beating 93.53% of leetcode users solutions using C++.
Memory: 112.20 mb, beating 26.57% of leetcode users solutions using C++.

#### Concepts Applied:

Trie, for loops, if statements, strings, arrays, and dynamic programming.

### Solution Sept 24, 2024 (C++, leetcode) 3043. Find the Length of the Longest Common Prefix (Medium)
In .LeetcodeDailySolution folder as Sept24,2024.cpp

#### Prompt:

You are given two arrays with positive integers arr1 and arr2.

A prefix of a positive integer is an integer formed by one or more of its digits, starting from its leftmost digit. For example, 123 is a prefix of the integer 12345, while 234 is not.

A common prefix of two integers a and b is an integer c, such that c is a prefix of both a and b. For example, 5655359 and 56554 have a common prefix 565 while 1223 and 43456 do not have a common prefix.

You need to find the length of the longest common prefix between all pairs of integers (x, y) such that x belongs to arr1 and y belongs to arr2.

Return the length of the longest common prefix among all pairs. If no common prefix exists among them, return 0.

#### Solution:

    class Solution {
    public:
    int longestCommonPrefix(vector<int>& arr1, vector<int>& arr2) {

        unordered_map<string, int> prefixMap;

        for (int num : arr1) {

            string strNum = to_string(num);
            string prefix = "";

            for (char ch : strNum) {
                prefix += ch;
                prefixMap[prefix]++;
            }
        }

        int maxLength = 0;

        for (int num : arr2) {

            string strNum = to_string(num);
            string prefix = "";

            for (char ch : strNum) {

                prefix += ch;

                if (prefixMap.find(prefix) != prefixMap.end()) {
                    maxLength =
                        max(maxLength, static_cast<int>(prefix.length()));
                }
            }
        }

        return maxLength;
      }
    };

Runtime: 472 ms, beating 33.96% of leetcode users solutions using C++.
Memory: 170.42 mb, beating 31.53% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, hashmap, max, and if statement.

### Solution Sept 26, 2024 (C++, leetcode) 729. My Calendar I (Medium)
In .LeetcodeDailySolution folder as Sept26,2024.cpp

#### Prompt:

You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.

A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).

The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.

Implement the MyCalendar class:

MyCalendar() Initializes the calendar object.
boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.

#### Solution:

    class MyCalendar {

    map<int, int> intervals; 

    public:

    MyCalendar() {}

    bool book(int start, int end) {
        auto next = intervals.lower_bound(start); 

        if (next != intervals.end() && next->first < end) {

            return false; 
        }

        if (next != intervals.begin() && prev(next)->second > start) {

            return false; 
        }

        intervals[start] = end; 

        return true;
      }
    };

Runtime: 48 ms, beating 99.89% of leetcode users solutions using C++.
Memory: 42.79 mb, beating 58.59% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search, map, and if statements.

### Solution Sept 27, 2024 (C++, leetcode) 731. My Calendar II (Medium)
In .LeetcodeDailySolution folder as Sept27,2024.cpp

#### Prompt:

You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.

A triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).

The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.

Implement the MyCalendarTwo class:

MyCalendarTwo() Initializes the calendar object.
boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar.

#### Solution:

    class MyCalendarTwo {
    public:
    vector<pair<int, int>> vp;

    MyCalendarTwo() {}

    bool book(int x, int y) {

        for (auto& val : vp) {
            int a = val.first, b = val.second;

            if ((x < b) and (y > a)) {

                int new_x = max(a, x);
                int new_y = min(b, y);

                if (check(new_x, new_y)) {

                    return false;
                }
            }
        }

        vp.push_back({x, y});
        return true;
    }

    bool check(int x, int y) {
        int overlapp_cnt = 0;

        for (int i = 0; i < vp.size(); i++) {
            int a = vp[i].first, b = vp[i].second;

            if ((x < b) and (y > a)) {
                overlapp_cnt++;
                if (overlapp_cnt == 2) {
                    
                    return true;
                }
            }
        }

        return false;
      }
    };

Runtime: 65 ms, beating 94.42% of leetcode users solutions using C++.
Memory: 37.60 mb, beating 99.62% of leetcode users solutions using C++.

#### Concepts Applied:

Brute-force, pair, for loops, if statements, max, and min.

### Solution Sept 28, 2024 (C++, leetcode) 641. Design Circular Deque (Medium)
In .LeetcodeDailySolution folder as Sept28,2024.cpp

#### Prompt:

Design your implementation of the circular double-ended queue (deque).

Implement the MyCircularDeque class:

MyCircularDeque(int k) Initializes the deque with a maximum size of k.
boolean insertFront() Adds an item at the front of Deque. Returns true if the operation is successful, or false otherwise.
boolean insertLast() Adds an item at the rear of Deque. Returns true if the operation is successful, or false otherwise.
boolean deleteFront() Deletes an item from the front of Deque. Returns true if the operation is successful, or false otherwise.
boolean deleteLast() Deletes an item from the rear of Deque. Returns true if the operation is successful, or false otherwise.
int getFront() Returns the front item from the Deque. Returns -1 if the deque is empty.
int getRear() Returns the last item from Deque. Returns -1 if the deque is empty.
boolean isEmpty() Returns true if the deque is empty, or false otherwise.
boolean isFull() Returns true if the deque is full, or false otherwise.

#### Solution:

    class MyCircularDeque {
    public:
    vector<int> v;
    int front, back, sizee, capacity;

    MyCircularDeque(int k) {
        v = vector<int>(k, -1);
        front = 0;
        back = 0;
        sizee = 0;
        capacity = k;
    }

    bool insertFront(int value) {
        if (isFull()) {
            return false;
        }
        if (front == 0) {
            front = capacity - 1;
        } else {
            front--;
        }
        v[front] = value;
        sizee++;
        return true;
    }

    bool insertLast(int value) {
        if (isFull()) {
            return false;
        }
        v[back] = value;
        if (back == capacity - 1) {
            back = 0;
        } else {
            back++;
        }
        sizee++;
        return true;
    }

    bool deleteFront() {
        if (isEmpty()) {
            return false;
        }
        v[front] = -1;
        if (front == capacity - 1) {
            front = 0;
        } else {
            front++;
        }
        sizee--;
        return true;
    }

    bool deleteLast() {
        if (isEmpty()) {
            return false;
        }
        if (back == 0) {
            back = capacity - 1;
        } else {
            back--;
        }
        v[back] = -1;
        sizee--;
        return true;
    }

    int getFront() {
        if (isEmpty()) {
            return -1;
        }
        return v[front];
    }

    int getRear() {
        if (isEmpty()) {
            return -1;
        }
        if (back == 0) {
            return v[capacity - 1];
        } else {
            return v[back - 1];
        }
    }

    bool isEmpty() { return (sizee == 0); }

    bool isFull() { return (sizee == capacity); }
    };
 
Runtime: 16 ms, beating 87.88% of leetcode users solutions using C++.
Memory: 22.72 mb, beating 48.31% of leetcode users solutions using C++.

#### Concepts Applied:

Deque, arrays, if statements, and else statements.

### Solution Sept 29, 2024 (C++, leetcode) 432. All O`one Data Structure (Hard)
In .LeetcodeDailySolution folder as Sept29,2024.cpp

#### Prompt:

Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.

Implement the AllOne class:

AllOne() Initializes the object of the data structure.
inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.
dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.
getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string "".
getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string "".
Note that each function must run in O(1) average time complexity.

#### Solution:

    class AllOne {
    unordered_map<string, int> count;
    map<int, unordered_set<string>> freq;

    public:
    AllOne() {}
    void inc(string key) {
        int cnt = count[key]++;
        if (cnt > 0)
            freq[cnt].erase(key);
        freq[cnt + 1].insert(key);
        if (freq[cnt].empty())
            freq.erase(cnt);
    }
    void dec(string key) {
        int cnt = count[key]--;
        if (cnt > 0)
            freq[cnt].erase(key);
        if (cnt == 1)
            count.erase(key);
        else
            freq[cnt - 1].insert(key);
        if (freq[cnt].empty())
            freq.erase(cnt);
    }
    string getMaxKey() {
        return freq.empty() ? "" : *(freq.rbegin()->second.begin());
    }
    string getMinKey() {
        return freq.empty() ? "" : *(freq.begin()->second.begin());
      }
    };

Runtime: 98 ms, beating 54.21% of leetcode users solutions using C++.
Memory: 63.85 mb, beating 11.65% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered map, map, strings, if statements, and else statement.

### Solution Sept 30, 2024 (C++, leetcode) 1381. Design a Stack With Increment Operation (Medium)
In .LeetcodeDailySolution folder as Sept30,2024.cpp

#### Prompt:

Design a stack that supports increment operations on its elements.

Implement the CustomStack class:

CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack.
void push(int x) Adds x to the top of the stack if the stack has not reached the maxSize.
int pop() Pops and returns the top of the stack or -1 if the stack is empty.
void inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack.

#### Solution:

    class CustomStack {
    public:
    int n;
    stack<int> stack;
    vector<int> inc;

    CustomStack(int n) { this->n = n; }

    void push(int x) {
        if (stack.size() < n) {
            stack.push(x);
            inc.push_back(0);
        }
    }

    int pop() {
        if (stack.empty())
            return -1;
        if (inc.size() > 1)
            inc[inc.size() - 2] += inc.back();
        int res = stack.top() + inc.back();
        stack.pop();
        inc.pop_back();
        return res;
    }

    void increment(int k, int val) {
        if (!stack.empty()) {
            int idx = min(k, (int)inc.size()) - 1;
            inc[idx] += val;
        }
      }
    };

Runtime: 21 ms, beating 90.19% of leetcode users solutions using C++.
Memory: 26.07 mb, beating 29.97% of leetcode users solutions using C++.

#### Concepts Applied:

Stack, inc, arrays, and if statements.

### Solution Oct 1, 2024 (C++, leetcode) 1497. Check If Array Pairs Are Divisible by k (Medium)
In .LeetcodeDailySolution folder as Oct1,2024.cpp

#### Prompt:

Given an array of integers arr of even length n and an integer k.

We want to divide the array into exactly n / 2 pairs such that the sum of each pair is divisible by k.

Return true If you can find a way to do that or false otherwise.

#### Solution:

    class Solution {
    public:
    bool canArrange(vector<int>& arr, int k) {

        vector<int> freq(k, 0);

        for (int num : arr) {

            int rem = num % k;

            if (rem < 0) {
                rem += k;
            }

            freq[rem]++;
        }

        if (freq[0] % 2 != 0) {
            
            return false;
        }

        for (int i = 1; i <= k / 2; i++) {
            if (freq[i] != freq[k - i]) {

                return false;
            }
        }

        return true;
      }
    };

Runtime: 72 ms, beating 95.26% of leetcode users solutions using C++.
Memory: 64.34 mb, beating 88.55% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, frequency, for loops, and if statements.

### Solution Oct 2, 2024 (C++, leetcode) 1331. Rank Transform of an Array (Easy)
In .LeetcodeDailySolution folder as Oct2,2024.cpp

#### Prompt:

Given an array of integers arr, replace each element with its rank.

The rank represents how large the element is. The rank has the following rules:

Rank is an integer starting from 1.
The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
Rank should be as small as possible.

#### Solution:

    class Solution {
    public:
    vector<int> arrayRankTransform(vector<int>& arr) {
        
        unordered_map<int, int> valueToRank;  
        vector<int> sortedUniqueNumbers = arr; 
        
        sort(sortedUniqueNumbers.begin(), sortedUniqueNumbers.end());
        sortedUniqueNumbers.erase(unique(sortedUniqueNumbers.begin(), sortedUniqueNumbers.end()), sortedUniqueNumbers.end());
        
        for (int i = 0; i < sortedUniqueNumbers.size(); i++) {
            valueToRank[sortedUniqueNumbers[i]] = i + 1;
        }

        for (int i = 0; i < arr.size(); i++) {
            arr[i] = valueToRank[arr[i]];
        }

        return arr;  
      }
    };

Runtime: 57 ms, beating 85.28% of leetcode users solutions using C++.
Memory: 43.16 mb, beating 59.88% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, unordered map, sorting, and for loops.

### Solution Oct 3, 2024 (C++, leetcode) 1590. Make Sum Divisible by P (Medium)
In .LeetcodeDailySolution folder as Oct3,2024.cpp

#### Prompt:

Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.

Return the length of the smallest subarray that you need to remove, or -1 if it's impossible.

A subarray is defined as a contiguous block of elements in the array.

#### Solution:

    class Solution {
    public:
    int minSubarray(vector<int>& nums, int p) {

        long totalSum = 0;

        for (int num : nums) {
            totalSum += num;
        }

        int rem = totalSum % p;

        if (rem == 0)
            return 0;

        unordered_map<int, int> prefixMod;
        prefixMod[0] = -1;
        long prefixSum = 0;
        int minLength = nums.size();

        for (int i = 0; i < nums.size(); ++i) {

            prefixSum += nums[i];
            int currentMod = prefixSum % p;
            int targetMod = (currentMod - rem + p) % p;

            if (prefixMod.find(targetMod) != prefixMod.end()) {
                minLength = min(minLength, i - prefixMod[targetMod]);
            }

            prefixMod[currentMod] = i;
        }

        return minLength == nums.size() ? -1 : minLength;
      }
    };

Runtime: 123 ms, beating 91.97% of leetcode users solutions using C++.
Memory: 70.36 mb, beating 85.49% of leetcode users solutions using C++.

#### Concepts Applied:

Total sum, arrays, subarrays, prefix sum, unordered map, min, for loops, and if statements.

### Solution Oct 4, 2024 (C++, leetcode) 2491. Divide Players Into Teams of Equal Skill (Medium)
In .LeetcodeDailySolution folder as Oct4,2024.cpp

#### Prompt:

You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.

The chemistry of a team is equal to the product of the skills of the players on that team.

Return the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.

#### Solution:

    class Solution {
    public:
    long long dividePlayers(vector<int>& skill) {

        sort(skill.begin(), skill.end());
        
        int n = skill.size();
        int totalSkill = skill[0] + skill[n - 1]; 
        long long chemistrySum = 0;

        for (int i = 0; i < n / 2; i++) {

            if (skill[i] + skill[n - i - 1] != totalSkill) {
                return -1; 
            }

            chemistrySum += (long long)skill[i] * skill[n - i - 1];
        }

        return chemistrySum; 
      }
    };

Runtime: 50 ms, beating 96.77% of leetcode users solutions using C++.
Memory: 56.31 mb, beating 84.01% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, two pointers, for loop, and if statement.

### Solution Oct 5, 2024 (C++, leetcode) 567. Permutation in String (Medium)
In .LeetcodeDailySolution folder as Oct5,2024.cpp

#### Prompt:

Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.

In other words, return true if one of s1's permutations is the substring of s2.

#### Solution:

    class Solution {
    public:
    bool checkInclusion(string s1, string s2) {

        if (s1.length() > s2.length())
            return false;

        vector<int> s1Count(26, 0), s2Count(26, 0);

        for (int i = 0; i < s1.length(); ++i) {
            s1Count[s1[i] - 'a']++;
            s2Count[s2[i] - 'a']++;
        }

        for (int i = 0; i < s2.length() - s1.length(); ++i) {
            if (s1Count == s2Count)
                return true;

            s2Count[s2[i] - 'a']--;
            s2Count[s2[i + s1.length()] - 'a']++;
        }

        return s1Count == s2Count;
      }
    };

Runtime: 6 ms, beating 68.06% of leetcode users solutions using C++.
Memory: 8.80 mb, beating 80.32% of leetcode users solutions using C++.

#### Concepts Applied:

Frequencies, sliding window technique, arrays, strings, if statements, and for loops.

### Solution Oct 7, 2024 (C++, leetcode) 2696. Minimum String Length After Removing Substrings (Easy)
In .LeetcodeDailySolution folder as Oct7,2024.cpp

#### Prompt:

You are given a string s consisting only of uppercase English letters.

You can apply some operations to this string where, in one operation, you can remove any occurrence of one of the substrings "AB" or "CD" from s.

Return the minimum possible length of the resulting string that you can obtain.

Note that the string concatenates after removing the substring and could produce new "AB" or "CD" substrings.

#### Solution:

    class Solution {
    public:
    int minLength(string s) {
        stack<char> stack;

        for (int i = 0; i < s.length(); i++) {
            char cur_char = s[i];

            if (stack.empty()) {
                stack.push(cur_char);
                continue;
            }

            if (cur_char == 'B' && stack.top() == 'A') {
                stack.pop();
            } else if (cur_char == 'D' && stack.top() == 'C') {
                stack.pop();
            } else {
                stack.push(cur_char);
            }
        }

        return stack.size();
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.54 mb, beating 62.71% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, stack, for loop, if statements, else if statement, and else statement.

### Solution Oct 8, 2024 (C++, leetcode) 1963. Minimum Number of Swaps to Make the String Balanced (Medium)
In .LeetcodeDailySolution folder as Oct8,2024.cpp

#### Prompt:

You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.

A string is called balanced if and only if:

It is the empty string, or
It can be written as AB, where both A and B are balanced strings, or
It can be written as [C], where C is a balanced string.
You may swap the brackets at any two indices any number of times.

Return the minimum number of swaps to make s balanced.

#### Solution:

    class Solution {
    public:
    int minSwaps(string s) {

        int size = 0;
        int n = s.size();

        for (int i = 0; i < n; i++) {

            char ch = s[i];

            if (ch == '[')
                size++;
                
            else if (size > 0)
                size--;
        }

        return (size + 1) / 2;
      }
    };

Runtime: 104 ms, beating 57.94% of leetcode users solutions using C++.
Memory: 32.76 mb, beating 53.29% of leetcode users solutions using C++.

#### Concepts Applied:

String, counter, for loop, if statement, and else-if statement.

### Solution Oct 9, 2024 (C++, leetcode) 921. Minimum Add to Make Parentheses Valid (Medium)
In .LeetcodeDailySolution folder as Oct9,2024.cpp

#### Prompt:

A parentheses string is valid if and only if:

It is the empty string,
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.
You are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.

For example, if s = "()))", you can insert an opening parenthesis to be "(()))" or a closing parenthesis to be "())))".
Return the minimum number of moves required to make s valid.

#### Solution:

    class Solution {
    public:
    int minAddToMakeValid(string s) {
        int open = 0, close = 0;
        for (auto c : s) {
            if (c == '(') {
                open++;
            } else {
                if (open > 0)
                    open--;
                else
                    close++;
            }
        }
        return open + close;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.82 mb, beating 54.88% of leetcode users solutions using C++.

#### Concepts Applied:

String, for loop, if statements, and else statements.

### Solution Oct 10, 2024 (C++, leetcode) 962. Maximum Width Ramp (Medium)
In .LeetcodeDailySolution folder as Oct10,2024.cpp

#### Prompt:

A ramp in an integer array nums is a pair (i, j) for which i < j and nums[i] <= nums[j]. The width of such a ramp is j - i.

Given an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0.

#### Solution:

    class Solution {
    public:
    int maxWidthRamp(vector<int>& nums) {

        stack<int> monoStack;
        int n = nums.size();
        int result = 0;

        for (int i = 0; i < n; ++i) {
            if (monoStack.empty() || nums[monoStack.top()] > nums[i]) {
                monoStack.push(i);
            }
        }
        
        for (int j = n - 1; j >= 0; --j) {
            while (!monoStack.empty() && nums[j] >= nums[monoStack.top()]) {
                result = max(result, j - monoStack.top());
                monoStack.pop();
            }
        }

        return result;
      }
    };

Runtime: 55 ms, beating 42.31% of leetcode users solutions using C++.
Memory: 47.08 mb, beating 25.09% of leetcode users solutions using C++.

#### Concepts Applied:

Monotonic stack, array, traversal, for loops, if statement, while loop, and max. 

### Solution Oct 11, 2024 (C++, leetcode) 1942. The Number of the Smallest Unoccupied Chair (Medium)
In .LeetcodeDailySolution folder as Oct11,2024.cpp

#### Prompt:

There is a party where n friends numbered from 0 to n - 1 are attending. There is an infinite number of chairs in this party that are numbered from 0 to infinity. When a friend arrives at the party, they sit on the unoccupied chair with the smallest number.

For example, if chairs 0, 1, and 5 are occupied when a friend comes, they will sit on chair number 2.
When a friend leaves the party, their chair becomes unoccupied at the moment they leave. If another friend arrives at that same moment, they can sit in that chair.

You are given a 0-indexed 2D integer array times where times[i] = [arrivali, leavingi], indicating the arrival and leaving times of the ith friend respectively, and an integer targetFriend. All arrival times are distinct.

Return the chair number that the friend numbered targetFriend will sit on.

#### Solution:

    class Solution {
    public:
    int smallestChair(vector<vector<int>>& times, int targetFriend) {
        int n = times.size();

        vector<int> order(n);
        for (int i = 0; i < n; ++i)
            order[i] = i;

        sort(order.begin(), order.end(),
             [&times](int a, int b) { return times[a][0] < times[b][0]; });

        priority_queue<int, vector<int>, greater<int>> emptySeats;
        priority_queue<pair<int, int>, vector<pair<int, int>>,
                       greater<pair<int, int>>>
            takenSeats;

        for (int i = 0; i < n; ++i)
            emptySeats.push(i);

        for (int i : order) {
            int arrival = times[i][0], leave = times[i][1];

            while (!takenSeats.empty() && takenSeats.top().first <= arrival) {
                emptySeats.push(takenSeats.top().second);
                takenSeats.pop();
            }

            int seat = emptySeats.top();
            emptySeats.pop();

            if (i == targetFriend)
                return seat;

            takenSeats.push({leave, seat});
        }

        return -1;
      }
    };

Runtime: 153 ms, beating 52.56% of leetcode users solutions using C++.
Memory: 57.76 mb, beating 88.74% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, arrays, for loops, priority queue, pairs, while loop, and if statement.

### Solution Oct 12, 2024 (C++, leetcode) 406. Divide Intervals Into Minimum Number of Groups (Medium)
In .LeetcodeDailySolution folder as Oct12,2024.cpp

#### Prompt:

You are given a 2D integer array intervals where intervals[i] = [lefti, righti] represents the inclusive interval [lefti, righti].

You have to divide the intervals into one or more groups such that each interval is in exactly one group, and no two intervals that are in the same group intersect each other.

Return the minimum number of groups you need to make.

Two intervals intersect if there is at least one common number between them. For example, the intervals [1, 5] and [5, 8] intersect.

#### Solution:

    class Solution {
    public:
    int minGroups(vector<vector<int>>& intervals) {

        vector<int> start_times, end_times;

        for (const auto& interval : intervals) {
            start_times.push_back(interval[0]);
            end_times.push_back(interval[1]);
        }

        sort(start_times.begin(), start_times.end());
        sort(end_times.begin(), end_times.end());

        int end_ptr = 0, group_count = 0;

        for (int start : start_times) {
            if (start > end_times[end_ptr]) {
                end_ptr++;
            } else {
                group_count++;
            }
        }

        return group_count;
      }
    };

Runtime: 236 ms, beating 89.90% of leetcode users solutions using C++.
Memory: 96.88 mb, beating 67.96% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, arrays, two pointers, for loops, if statement, and else statement.

### Solution Oct 13, 2024 (C++, leetcode) 632. Smallest Range Covering Elements from K Lists (Hard)
In .LeetcodeDailySolution folder as Oct13,2024.cpp

#### Prompt:

You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.

We define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.

#### Solution:

    class Solution {
    public:
    vector<int> smallestRange(vector<vector<int>>& nums) {

        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>
            minHeap;
        int curMax = numeric_limits<int>::min();

        for (int i = 0; i < nums.size(); i++) {
            minHeap.push({nums[i][0], i, 0});
            curMax = max(curMax, nums[i][0]);
        }
        vector<int> smallRange = {0, numeric_limits<int>::max()};

        while (!minHeap.empty()) {

            vector<int> curr = minHeap.top();
            minHeap.pop();
            int curMin = curr[0], listIdx = curr[1], elemIdx = curr[2];

            if (curMax - curMin < smallRange[1] - smallRange[0]) {
                smallRange[0] = curMin;
                smallRange[1] = curMax;
            }

            if (elemIdx + 1 < nums[listIdx].size()) {
                int nextVal = nums[listIdx][elemIdx + 1];
                minHeap.push({nextVal, listIdx, elemIdx + 1});
                curMax = max(curMax, nextVal);
            } else {

                break;
            }
        }
        
        return smallRange;
      }
    };

Runtime: 85 ms, beating 13.66% of leetcode users solutions using C++.
Memory: 27.32 mb, beating 10.22% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, priority queue, min, max, for loop, while loop, if statements, and else statement.

### Solution Oct 14, 2024 (C++, leetcode) 2530. Maximal Score After Applying K Operations (Medium)
In .LeetcodeDailySolution folder as Oct14,2024.cpp

#### Prompt:

You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.

In one operation:

choose an index i such that 0 <= i < nums.length,
increase your score by nums[i], and
replace nums[i] with ceil(nums[i] / 3).
Return the maximum possible score you can attain after applying exactly k operations.

The ceiling function ceil(val) is the least integer greater than or equal to val.

#### Solution:

    class Solution {
    public:
    static long long maxKelements(vector<int>& nums, int k) {

        priority_queue<int> pq(nums.begin(), nums.end());

        long long score = 0;

        for (int i = 0; i < k; i++) {

            int x = pq.top();
            score += x;

            if (x == 1) {
                score += (k - 1 - i);
                
                break;
            }

            pq.pop();
            pq.push((x + 2) / 3);
        }

        return score;
      }
    };

Runtime: 163 ms, beating 94.95% of leetcode users solutions using C++.
Memory: 75.74 mb, beating 96.72% of leetcode users solutions using C++.

#### Concepts Applied:

Priority queue, arrays, for loop, and if statement.

### Solution Oct 15, 2024 (C++, leetcode) 2938. Separate Black and White Balls (Medium)
In .LeetcodeDailySolution folder as Oct15,2024.cpp

#### Prompt:

There are n balls on a table, each ball has a color black or white.

You are given a 0-indexed binary string s of length n, where 1 and 0 represent black and white balls, respectively.

In each step, you can choose two adjacent balls and swap them.

Return the minimum number of steps to group all the black balls to the right and all the white balls to the left.

#### Solution:

    class Solution {
    public:
    long long minimumSteps(string s) {

        long long swap = 0;
        int black = 0; 

        for (int i = 0; i < s.length(); i++) {

            if (s[i] == '0') 
                swap += (long long) black; 

            else
                black++; 
        }
        
        return swap;
      }
    };

Runtime: 35 ms, beating 42.12% of leetcode users solutions using C++.
Memory: 15.28 mb, beating 95.68% of leetcode users solutions using C++.

#### Concepts Applied:

String, for loop, if statement, and else statement.

### Solution Oct 16, 2024 (C++, leetcode) 1405. Longest Happy String (Medium)
In .LeetcodeDailySolution folder as Oct16,2024.cpp

#### Prompt:

A string s is called happy if it satisfies the following conditions:

s only contains the letters 'a', 'b', and 'c'.
s does not contain any of "aaa", "bbb", or "ccc" as a substring.
s contains at most a occurrences of the letter 'a'.
s contains at most b occurrences of the letter 'b'.
s contains at most c occurrences of the letter 'c'.
Given three integers a, b, and c, return the longest possible happy string. If there are multiple longest happy strings, return any of them. If there is no such string, return the empty string "".

A substring is a contiguous sequence of characters within a string.

#### Solution:

    class Solution {
    public:
    string longestDiverseString(int a, int b, int c) {

        priority_queue<pair<int, char>> pq;

        if (a > 0)
            pq.push({a, 'a'});
        if (b > 0)
            pq.push({b, 'b'});
        if (c > 0)
            pq.push({c, 'c'});

        string result = "";

        while (!pq.empty()) {

            auto [count1, char1] = pq.top();
            pq.pop();

            if (result.size() >= 2 && result.back() == char1 &&
                result[result.size() - 2] == char1) {
                    
                if (pq.empty())
                    break;

                auto [count2, char2] = pq.top();
                pq.pop();

                result += char2;
                count2--;

                if (count2 > 0)
                    pq.push({count2, char2});

                pq.push({count1, char1});

            } else {

                result += char1;
                count1--;

                if (count1 > 0)
                    pq.push({count1, char1});
            }
        }

        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.76 mb, beating 63.68% of leetcode users solutions using C++.

#### Concepts Applied:

Greedy, strings, priority queue, if statements, while loop, and else statement.

### Solution Oct 17, 2024 (C++, leetcode) 670. Maximum Swap (Medium)
In .LeetcodeDailySolution folder as Oct17,2024.cpp

#### Prompt:

You are given an integer num. You can swap two digits at most once to get the maximum valued number.

Return the maximum valued number you can get.

#### Solution:

    class Solution {
    public:
    int maximumSwap(int num) {

        string numStr = to_string(num);
        int n = numStr.size();
        
        vector<int> last(10, -1);

        for (int i = 0; i < n; ++i) {
            last[numStr[i] - '0'] = i;
        }
        
        for (int i = 0; i < n; ++i) {

            for (int d = 9; d > numStr[i] - '0'; --d) {

                if (last[d] > i) {

                    swap(numStr[i], numStr[last[d]]);

                    return stoi(numStr); 
                }
            }
        }
        
        return num;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.58 mb, beating 70.33% of leetcode users solutions using C++.

#### Concepts Applied:

String, array, for loops, swap, and if statement.

### Solution Oct 18, 2024 (C++, leetcode) 2044. Count Number of Maximum Bitwise-OR Subsets (Medium)
In .LeetcodeDailySolution folder as Oct18,2024.cpp

#### Prompt:

Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.

An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.

The bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).

#### Solution:

    class Solution {
    public:
    void backtrack(const vector<int>& nums, int index, int currentOR, int maxOR,
                   int& count) {

        if (currentOR == maxOR) {
            count++;
        }

        for (int i = index; i < nums.size(); ++i) {
            backtrack(nums, i + 1, currentOR | nums[i], maxOR, count);
        }
    }

    int countMaxOrSubsets(vector<int>& nums) {
        int maxOR = 0;

        for (int num : nums) {
            maxOR |= num;
        }
        int count = 0;

        backtrack(nums, 0, 0, maxOR, count);

        return count;
      }
    };

Runtime: 8 ms, beating 92.08% of leetcode users solutions using C++.
Memory: 9.99 mb, beating 93.49% of leetcode users solutions using C++.

#### Concepts Applied:

Array, if statements, backtracking, for loop, and bitwise.

### Solution Oct 20, 2024 (C++, leetcode) 1106. Parsing A Boolean Expression (Hard)
In .LeetcodeDailySolution folder as Oct20,2024.cpp

#### Prompt:

A boolean expression is an expression that evaluates to either true or false. It can be in one of the following shapes:

't' that evaluates to true.
'f' that evaluates to false.
'!(subExpr)' that evaluates to the logical NOT of the inner expression subExpr.
'&(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical AND of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.
'|(subExpr1, subExpr2, ..., subExprn)' that evaluates to the logical OR of the inner expressions subExpr1, subExpr2, ..., subExprn where n >= 1.
Given a string expression that represents a boolean expression, return the evaluation of that expression.

It is guaranteed that the given expression is valid and follows the given rules.

#### Solution:

    class Solution {
    public:
    int i = 0;
    bool parseBoolExpr(const string& expr) {

        char c = expr[i++];

        if (c == 't')
            return 1;

        if (c == 'f')
            return 0;
            
        if (c == '!') {
            i++;
            bool ans = parseBoolExpr(expr);
            i++;
            return !ans;
        }
        vector<bool> x;
        i++;

        while (expr[i] != ')') {

            if (expr[i] == ',')
                i++;

            else
                x.push_back(parseBoolExpr(expr));
        }
        i++;

        if (c == '&')
            return all_of(x.begin(), x.end(), [](bool b) { return b; });

        if (c == '|')
            return any_of(x.begin(), x.end(), [](bool b) { return b; });
        return 0;
      }
    };

Runtime: 7 ms, beating 42.32% of leetcode users solutions using C++.
Memory: 15.64 mb, beating 8.80% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean, strings, if statements, while loop, parsing, and else statement.

### Solution Oct 21, 2024 (C++, leetcode) 1593. Split a String Into the Max Number of Unique Substrings (Medium)
In .LeetcodeDailySolution folder as Oct21,2024.cpp

#### Prompt:

Given a string s, return the maximum number of unique substrings that the given string can be split into.

You can split string s into any list of non-empty substrings, where the concatenation of the substrings forms the original string. However, you must split the substrings such that all of them are unique.

A substring is a contiguous sequence of characters within a string.

#### Solution:

    class Solution {
    public:
    int maxUniqueSplit(string s) {
        unordered_set<string> seen;
        return backtrack(0, s, seen);
    }

    private:
    int backtrack(int start, const string& s, unordered_set<string>& seen) {
        if (start == s.size()) {
            return 0;
        }
        int maxSplits = 0;
        for (int end = start + 1; end <= s.size(); ++end) {
            string substring = s.substr(start, end - start);
            if (seen.find(substring) == seen.end()) {
                seen.insert(substring);
                maxSplits = max(maxSplits, 1 + backtrack(end, s, seen));
                seen.erase(substring);
            }
        }
        return maxSplits;
      }
    };

Runtime: 224 ms, beating 61.67% of leetcode users solutions using C++.
Memory: 47.92 mb, beating 56.48% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, substrings, backtracking, unordered set, if statements, and for loop.

### Solution Oct 22, 2024 (C++, leetcode) 2583. Kth Largest Sum in a Binary Tree (Medium)
In .LeetcodeDailySolution folder as Oct22,2024.cpp

#### Prompt:

You are given the root of a binary tree and a positive integer k.

The level sum in the tree is the sum of the values of the nodes that are on the same level.

Return the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.

Note that two nodes are on the same level if they have the same distance from the root.

#### Solution:

    class Solution {
    public:
    static void f(TreeNode* root, int level, long long* sum, int& sz) {

        if (sz <= level)
            sz++;

        sum[level] += root->val;

        if (root->left)
            f(root->left, level + 1, sum, sz);
        if (root->right)
            f(root->right, level + 1, sum, sz);
    }
    static long long kthLargestLevelSum(TreeNode* root, int k) {
        long long sum[100000] = {0};
        int sz = 0;
        f(root, 0, sum, sz);

        if (sz < k)
            return -1;

        nth_element(sum, sum + (k - 1), end(sum), greater<>());

        return sum[k - 1];
      }
    };

Runtime: 7 ms, beating 99.00% of leetcode users solutions using C++. 
Memory: 155.77 mb, beating 5.57% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, if statements, and sorting.

### Solution Oct 23, 2024 (C++, leetcode) 2641. Cousins in Binary Tree II (Medium)
In .LeetcodeDailySolution folder as Oct23,2024.cpp

#### Prompt:

Given the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins' values.

Two nodes of a binary tree are cousins if they have the same depth with different parents.

Return the root of the modified tree.

Note that the depth of a node is the number of edges in the path from the root node to it.

#### Solution:

    class Solution {
    public:
    TreeNode* replaceValueInTree(TreeNode* root) {

        root->val = 0;

        dfs(vector<TreeNode*>{root});
        return root;
    }

    private:
    void dfs(vector<TreeNode*> arr) {

        if (arr.empty())
            return;

        int sum = 0;

        for (auto node : arr) {
            if (!node)
                continue;
            if (node->left)
                sum += node->left->val;
            if (node->right)
                sum += node->right->val;
        }

        vector<TreeNode*> childArr;

        for (auto node : arr) {

            int curSum = 0;

            if (node->left)
                curSum += node->left->val;
            if (node->right)
                curSum += node->right->val;
            if (node->left) {
                node->left->val = sum - curSum;
                childArr.push_back(node->left);
            }

            if (node->right) {
                node->right->val = sum - curSum;
                childArr.push_back(node->right);
            }
        }

        dfs(childArr);
      }
    };

Runtime: 602 ms, beating 84.20% of leetcode users solutions using C++.
Memory: 357.55 mb, beating 16.01% of leetcode users solutions using C++.

#### Concepts Applied:

Root values, depth-first search, if statements, and for loops.

### Solution Oct 24, 2024 (C++, leetcode) 951. Flip Equivalent Binary Trees (Medium)
In .LeetcodeDailySolution folder as Oct24,2024.cpp

#### Prompt:

    class Solution {
    public:
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {

        if (root1 == root2)
            return 1;

        if (!root1 || !root2 || root1->val != root2->val)
            return 0;

        return (flipEquiv(root1->left, root2->left) &&
                flipEquiv(root1->right, root2->right)) ||
               (flipEquiv(root1->left, root2->right) &&
                flipEquiv(root1->right, root2->left));
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 14.43 mb, beating 83.88% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, if statements, and binary tree.

### Solution Oct 25, 2024 (C++, leetcode) 1233. Remove Sub-Folders from the Filesystem (Medium)
In .LeetcodeDailySolution folder as Oct25,2024.cpp

#### Prompt:

Given a list of folders folder, return the folders after removing all sub-folders in those folders. You may return the answer in any order.

If a folder[i] is located within another folder[j], it is called a sub-folder of it. A sub-folder of folder[j] must start with folder[j], followed by a "/". For example, "/a/b" is a sub-folder of "/a", but "/b" is not a sub-folder of "/a/b/c".

The format of a path is one or more concatenated strings of the form: '/' followed by one or more lowercase English letters.

For example, "/leetcode" and "/leetcode/problems" are valid paths while an empty string and "/" are not.

#### Solution:

    class Solution {
    public:
    static vector<string> removeSubfolders(vector<string>& folder) {

        const int n = folder.size();

        sort(folder.begin(), folder.end());

        vector<string> ans = {folder[0]};
        string prev = folder[0];

        for (int i = 1; i < n; i++) {

            string s = folder[i];

            if (s.find(prev + '/') != 0) {
                ans.push_back(s);
                prev = s;
            }
        }

        return ans;
      }
    };

Runtime: 57 ms, beating 92.01% of leetcode users solutions using C++.
Memory: 51.48 mb, beating 67.49% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, arrays, strings, for loop, and if statement.

### Solution Oct 26, 2024 (C++, leetcode) 2458. Height of Binary Tree After Subtree Removal Queries (Hard)
In .LeetcodeDailySolution folder as Oct26,2024.cpp

#### Prompt:

You are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m.

You have to perform m independent queries on the tree where in the ith query you do the following:

Remove the subtree rooted at the node with the value queries[i] from the tree. It is guaranteed that queries[i] will not be equal to the value of the root.
Return an array answer of size m where answer[i] is the height of the tree after performing the ith query.

Note:

The queries are independent, so the tree returns to its initial state after each query.
The height of a tree is the number of edges in the longest simple path from the root to some node in the tree.

#### Solution:

    class Solution {
    public:

    int maxHeightAfterRemoval[100001];
    int currentMaxHeight = 0;

    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {

        traverseLeftToRight(root, 0);
        currentMaxHeight = 0;
        traverseRightToLeft(root, 0);

        int queryCount = queries.size();

        vector<int> queryResults(queryCount);

        for (int i = 0; i < queryCount; i++) {
            queryResults[i] = maxHeightAfterRemoval[queries[i]];
        }

        return queryResults;
    }

    private:
    void traverseLeftToRight(TreeNode* node, int currentHeight) {

        if (node == nullptr)
            return;

        maxHeightAfterRemoval[node->val] = currentMaxHeight;

        currentMaxHeight = max(currentMaxHeight, currentHeight);

        traverseLeftToRight(node->left, currentHeight + 1);
        traverseLeftToRight(node->right, currentHeight + 1);
    }

    void traverseRightToLeft(TreeNode* node, int currentHeight) {

        if (node == nullptr)
            return;

        maxHeightAfterRemoval[node->val] =
            max(maxHeightAfterRemoval[node->val], currentMaxHeight);

        currentMaxHeight = max(currentHeight, currentMaxHeight);

        traverseRightToLeft(node->right, currentHeight + 1);
        traverseRightToLeft(node->left, currentHeight + 1);
      }
    };

Runtime: 15 ms, beating 92.68% of leetcode users solutions using C++.
Memory: 183.60 mb, beating 81.29% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, traversals, for loop, if statements, and max.

### Solution Oct 27, 2024 (C++, leetcode) 1277. Count Square Submatrices with All Ones (Medium)
In .LeetcodeDailySolution folder as Oct27,2024.cpp

#### Prompt:

Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.

#### Solution:

    class Solution {
    public:
    int countSquares(vector<vector<int>>& matrix) {

        int n = matrix.size();    
        int m = matrix[0].size();
        
        vector<vector<int>> dp(n, vector<int>(m, 0));
        
        int ans = 0;
        
        for (int i = 0; i < n; i++) {
            dp[i][0] = matrix[i][0];
            ans += dp[i][0];  
        }
        
        for (int j = 1; j < m; j++) {
            dp[0][j] = matrix[0][j];
            ans += dp[0][j];  
        }
        
        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                if(matrix[i][j] == 1) {
                    dp[i][j] = 1 + min({dp[i][j-1], dp[i-1][j], dp[i-1][j-1]});
                }
                ans += dp[i][j];
            }
        }
        
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 29 mb, beating 68.73% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, arrays, for loops, dynamic programming, and if statement.

### Solution Oct 28, 2024 (C++, leetcode) 2501. Longest Square Streak in an Array (Medium)
In .LeetcodeDailySolution folder as Oct28,2024.cpp

#### Prompt:

You are given an integer array nums. A subsequence of nums is called a square streak if:

The length of the subsequence is at least 2, and
after sorting the subsequence, each element (except the first element) is the square of the previous number.
Return the length of the longest square streak in nums, or return -1 if there is no square streak.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

#### Solution:

    class Solution {
    public:
    int longestSquareStreak(vector<int>& nums) {

        map<int, int> mp;
        sort(nums.begin(), nums.end());
        int res = -1;

        for (int num : nums) {

            int _sqrt = sqrt(num);

            if (_sqrt * _sqrt == num && mp.find(_sqrt) != mp.end()) {

                mp[num] = mp[_sqrt] + 1;
                res = max(res, mp[num]);

            } else

                mp[num] = 1;
        }

        return res;
      }
    };

Runtime: 172 ms, beating 12.86% of leetcode users solutions using C++.
Memory: 111.54 mb, beating 32.52% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, map, arrays, for loop, rooting, if statement, and else statement.

### Solution Oct 29, 2024 (C++, leetcode) 2684. Maximum Number of Moves in a Grid (Medium)
In .LeetcodeDailySolution folder as Oct29,2024.cpp

#### Prompt:

You are given a 0-indexed m x n matrix grid consisting of positive integers.

You can start at any cell in the first column of the matrix, and traverse the grid in the following way:

From a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell.
Return the maximum number of moves that you can perform.

#### Solution:

    class Solution {
    public:
    int maxMoves(vector<vector<int>>& grid) {

        int m = grid.size();   
        int n = grid[0].size(); 
        
        int res = 0;
        
        vector<int> dp(m);
        
        for (int j = 1; j < n; ++j) {

            int leftTop = 0;

            bool found = false;
            
            for (int i = 0; i < m; ++i) {

                int cur = -1;

                int nxtLeftTop = dp[i];
                
                if (i - 1 >= 0 && leftTop != -1 && grid[i][j] > grid[i - 1][j - 1]) {
                    cur = max(cur, leftTop + 1);
                }
                
                if (dp[i] != -1 && grid[i][j] > grid[i][j - 1]) {
                    cur = max(cur, dp[i] + 1);
                }
                
                if (i + 1 < m && dp[i + 1] != -1 && grid[i][j] > grid[i + 1][j - 1]) {
                    cur = max(cur, dp[i + 1] + 1);
                }
                
                dp[i] = cur;

                found = found || (dp[i] != -1);

                leftTop = nxtLeftTop;
            }
            
            if (!found) break;

            res = j;
        }
        
        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++. 
Memory: 67.33 mb, beating 96.80% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, grid, matrix, dynamic programming, for loops, and if statements.

### Solution Oct 30, 2024 (C++, leetcode) 1671. Minimum Number of Removals to Make Mountain Array (Hard)
In .LeetcodeDailySolution folder as Oct30,2024.cpp

#### Prompt:

You may recall that an array arr is a mountain array if and only if:

arr.length >= 3
There exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given an integer array nums​​​, return the minimum number of elements to remove to make nums​​​ a mountain array.

#### Solution:

    class Solution {
    public:
    int minimumMountainRemovals(vector<int>& nums) {

        int n = nums.size();
        vector<int> LIS(n, 1), LDS(n, 1);

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    LIS[i] = max(LIS[i], LIS[j] + 1);
                }
            }
        }
        for (int i = n - 1; i >= 0; --i) {
            for (int j = n - 1; j > i; --j) {
                if (nums[i] > nums[j]) {
                    LDS[i] = max(LDS[i], LDS[j] + 1);
                }
            }
        }
        int maxMountainLength = 0;

        for (int i = 1; i < n - 1; ++i) {
            if (LIS[i] > 1 && LDS[i] > 1) {  
                maxMountainLength = max(maxMountainLength, LIS[i] + LDS[i] - 1);
            }
        }

        return n - maxMountainLength;
      }
    };

Runtime: 51 ms, beating 66.67% of leetcode users solutions using C++.
Memory: 14.86 mb, beating 67.05% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, if statements, and max.

### Solution Oct 31, 2024 (C++, leetcode) 2463. Minimum Total Distance Traveled (Hard)
In .LeetcodeDailySolution folder as Oct31,2024.cpp

#### Prompt:

There are some robots and factories on the X-axis. You are given an integer array robot where robot[i] is the position of the ith robot. You are also given a 2D integer array factory where factory[j] = [positionj, limitj] indicates that positionj is the position of the jth factory and that the jth factory can repair at most limitj robots.

The positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.

All the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.

At any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.

Return the minimum total distance traveled by all the robots. The test cases are generated such that all the robots can be repaired.

Note that

All robots move at the same speed.
If two robots move in the same direction, they will never collide.
If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.
If a robot passes by a factory that reached its limits, it crosses it as if it does not exist.
If the robot moved from a position x to a position y, the distance it moved is |y - x|.

#### Solution:

    class Solution {
    public:
    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {

        sort(robot.begin(), robot.end());
        sort(factory.begin(), factory.end());
        
        int m = robot.size(), n = factory.size();
        vector<vector<long long>> dp(m + 1, vector<long long>(n + 1));
        
        for (int i = 0; i < m; i++) {
            dp[i][n] = LLONG_MAX;
        }
        
        for (int j = n - 1; j >= 0; j--) {

            long long prefix = 0;
            deque<pair<int, long long>> qq;
            qq.push_back({m, 0});
            
            for (int i = m - 1; i >= 0; i--) {

                prefix += abs(robot[i] - factory[j][0]);
                
                while (!qq.empty() && qq.front().first > i + factory[j][1]) {
                    qq.pop_front();
                }
                
                while (!qq.empty() && qq.back().second >= dp[i][j + 1] - prefix) {
                    qq.pop_back();
                }
                
                qq.push_back({i, dp[i][j + 1] - prefix});
                dp[i][j] = qq.front().second + prefix;
            }
        }
        
        return dp[0][0];
      }
    };

Runtime: 7 ms, beating 100% of leetcode users solutions using C++.
Memory: 15.15 mb, beating 53.37% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, for loops, deque, while loops, and dynamic programming.

### Solution Nov 1, 2024 (C++, leetcode) 1957. Delete Characters to Make Fancy String (Easy)
In .LeetcodeDailySolution folder as Nov1,2024.cpp

#### Prompt:

A fancy string is a string where no three consecutive characters are equal.

Given a string s, delete the minimum possible number of characters from s to make it fancy.

Return the final string after the deletion. It can be shown that the answer will always be unique.

#### Solution:

    class Solution {
    public:
    string makeFancyString(string s) {

        string ans = "";
        ans.push_back(s[0]);
        int n = s.size(), cnt = 1;
        
        for (int i = 1; i < n; i++) {
            if (s[i] == ans.back()) {
                cnt++;
                if (cnt < 3)
                    ans.push_back(s[i]);
            } else {
                cnt = 1;
                ans.push_back(s[i]);
            }
        }
        return ans;
      }
    };

Runtime: 33 ms, beating 38.95% of leetcode users solutions using C++.
Memory: 42.88 mb, beating 31.24% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loop, if statements, and else statement.

### Solution Nov 2, 2024 (C++, leetcode) 2490. Circular Sentence (Easy)
In .LeetcodeDailySolution folder as Nov2,2024.cpp

#### Prompt:

A sentence is a list of words that are separated by a single space with no leading or trailing spaces.

For example, "Hello World", "HELLO", "hello world hello world" are all sentences.
Words consist of only uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.

A sentence is circular if:

The last character of a word is equal to the first character of the next word.
The last character of the last word is equal to the first character of the first word.
For example, "leetcode exercises sound delightful", "eetcode", "leetcode eats soul" are all circular sentences. However, "Leetcode is cool", "happy Leetcode", "Leetcode" and "I like Leetcode" are not circular sentences.

Given a string sentence, return true if it is circular. Otherwise, return false.

#### Solution:

    class Solution {
    public:
    bool isCircularSentence(string sentence) {

        int n = sentence.size();

        if (sentence[0] != sentence[n - 1])
            return false;

        for (int i = 1; i < n - 1; i++) {
            if (sentence[i] == ' ') {
                if (sentence[i - 1] != sentence[i + 1])
                    return false;
            }
        }

        return true;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.26 mb, beating 59.38% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, if statements, and for loop.

### Solution Nov 3, 2024 (C++, leetcode) 796. Rotate String (Easy)
In .LeetcodeDailySolution folder as Nov3,2024.cpp

#### Prompt:

Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.

A shift on s consists of moving the leftmost character of s to the rightmost position.

For example, if s = "abcde", then it will be "bcdea" after one shift.

#### Solution:

    class Solution {
    public:
    bool rotateString(string s, string goal) {

        if (s.length() != goal.length()) {
            return false;
        }

        return (s + s).find(goal) != string::npos;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.68 mb, beating 55.50% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, and if statement.

### Solution Nov 4, 2024 (C++, leetcode) 3163. String Compression III (Medium)
In .LeetcodeDailySolution folder as Nov4,2024.cpp

#### Prompt:

Given a string word, compress it using the following algorithm:

Begin with an empty string comp. While word is not empty, use the following operation:
Remove a maximum length prefix of word made of a single character c repeating at most 9 times.
Append the length of the prefix followed by c to comp.
Return the string comp.

#### Solution:

    class Solution {
    public:
    static string compressedString(string& word) {

        int n = word.size(), l = 0;
        string ans;
        ans.reserve(n);

        for (int r = 0; r < n;) {
            while (r < n && word[r] == word[l])
                r++;

            auto [q, rem] = div(r - l, 9);

            for (int i = 0; i < q; i++) {
                ans.push_back('9');
                ans.push_back(word[l]);
            }
            if (rem > 0) {
                ans.push_back(rem + '0');
                ans.push_back(word[l]);
            }
            l = r;
        }

        return ans;
      }
    };

Runtime: 3 ms, beating 98.66% of leetcode users solutions using C++.
Memory: 22.83 mb, beating 100% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loops, while loop, and if statement.

### Solution Nov 5, 2024 (C++, leetcode) 2914. Minimum Number of Changes to Make Binary String Beautiful (Medium)
In .LeetcodeDailySolution folder as Nov5,2024.cpp

#### Prompt:

You are given a 0-indexed binary string s having an even length.

A string is beautiful if it's possible to partition it into one or more substrings such that:

Each substring has an even length.
Each substring contains only 1's or only 0's.
You can change any character in s to 0 or 1.

Return the minimum number of changes required to make the string s beautiful.

#### Solution:

    class Solution {
    public:
    int minChanges(string& s) {

        const int n = s.size();
        int count = 0;

        for (int i = 0; i < n; i += 2)
            count += (s[i] != s[i + 1]);
            
        return count;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.22 mb, beating 99.70% of leetcode users solutions using C++.

#### Concepts Applied:

String, and for loop.

### Solution Nov 6, 2024 (C++, leetcode) 3011. Find if Array Can Be Sorted (Medium)
In .LeetcodeDailySolution folder as Nov6,2024.cpp

#### Prompt:

You are given a 0-indexed array of positive integers nums.

In one operation, you can swap any two adjacent elements if they have the same number of 
set bits
. You are allowed to do this operation any number of times (including zero).

Return true if you can sort the array, else return false.

#### Solution:

    class Solution {
    public:
    bool canSortArray(std::vector<int>& nums) {

        int prevMax = INT_MIN;
        int currMax = nums[0];
        int currMin = nums[0];
        int setBits = countBits(nums[0]);

        for (size_t i = 1; i < nums.size(); i++) {

            if (setBits == countBits(nums[i])) {
                currMax = max(currMax, nums[i]);
                currMin = min(currMin, nums[i]);

            } else {

                if (currMin < prevMax)
                    return false;

                prevMax = currMax;
                setBits = countBits(nums[i]);
                currMin = nums[i];
                currMax = nums[i];
            }
        }

        return currMin > prevMax;
    }

    private:
    int countBits(int num) { 
        
    return bitset<32>(num).count(); }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++. 
Memory: 31.32 mb, beating 49.32% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, bit manipulation, max, min, for loop, if statements, and else statement.

### Solution Nov 7, 2024 (C++, leetcode) 2275. Largest Combination With Bitwise AND Greater Than Zero (Medium)
In .LeetcodeDailySolution folder as Nov7,2024.cpp

#### Prompt:

The bitwise AND of an array nums is the bitwise AND of all integers in nums.

For example, for nums = [1, 5, 3], the bitwise AND is equal to 1 & 5 & 3 = 1.
Also, for nums = [7], the bitwise AND is 7.
You are given an array of positive integers candidates. Evaluate the bitwise AND of every combination of numbers of candidates. Each number in candidates may only be used once in each combination.

Return the size of the largest combination of candidates with a bitwise AND greater than 0.

#### Solution:

    class Solution {
    public:
    int largestCombination(vector<int>& candidates) {

        vector<int> ans(32, 0);
        
        for (int x : candidates) {
            find(x, ans);
        }
        int res = 0;

        for (int i = 0; i < 32; i++) {
            res = max(res, ans[i]);
        }

        return res;
    }
    void find(int n, vector<int>& ans) {

        int j = 31;

        while (n > 0) {

            int a = (n & 1);

            ans[j] += a;

            n >>= 1;

            j--;
        }
      }
    };

Runtime: 15 ms, beating 84.62% of leetcode users solutions using C++.
Memory: 60.11 mb, beating 74.67% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, bit count, for loops, while loop, and max.

### Solution Nov 8, 2024 (C++, leetcode) 1829. Maximum XOR for Each Query (Medium)
In .LeetcodeDailySolution folder as Nov8,2024.cpp

#### Prompt:

You are given a sorted array nums of n non-negative integers and an integer maximumBit. You want to perform the following query n times:

Find a non-negative integer k < 2maximumBit such that nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the answer to the ith query.
Remove the last element from the current array nums.
Return an array answer, where answer[i] is the answer to the ith query.

#### Solution:

    class Solution {
    public:
    vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {

        int n = nums.size(), xorr = nums[0], maxxorr = pow(2, maximumBit) - 1;

        for (int i = 1; i < n; i++)

            xorr ^= nums[i];
        vector<int> ans(n);

        for (int i = 0; i < n; i++) {

            ans[i] = xorr ^ maxxorr;
            xorr ^= nums[n - 1 - i];
        }

        return ans;
      }
    };

Runtime: 4 ms, beating 57.14% of leetcode users solutions using C++.
Memory: 95.38 mb, beating 82.72% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, and bit manipulation.
 
### Solution Nov 9, 2024 (C++, leetcode) 3133. Minimum Array End (Medium)
In .LeetcodeDailySolution folder as Nov9,2024.cpp

#### Prompt:

You are given two integers n and x. You have to construct an array of positive integers nums of size n where for every 0 <= i < n - 1, nums[i + 1] is greater than nums[i], and the result of the bitwise AND operation between all elements of nums is x.

Return the minimum possible value of nums[n - 1].

#### Solution:

    class Solution {
    public:
    long minEnd(int n, int x) {

        long result = x;
        long remaining = n - 1;
        long position = 1;

        while (remaining) {
            if (!(x & position)) {
                result |= (remaining & 1) * position;
                remaining >>= 1;
            }
            position <<= 1;
        }

        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.51 mb, beating 52.60% of leetcode users solutions using C++.

#### Concepts Applied:

Bit manipulation, while loop, and if statement.

### Solution Nov 10, 2024 (C++, leetcode) 3097. Shortest Subarray With OR at Least K II (Medium)
In .LeetcodeDailySolution folder as Nov10,2024.cpp

#### Prompt:

You are given an array nums of non-negative integers and an integer k.

An array is called special if the bitwise OR of all of its elements is at least k.

Return the length of the shortest special non-empty 
subarray of nums, or return -1 if no special subarray exists.

#### Solution:

    class Solution {
    public:
    int minimumSubarrayLength(vector<int>& nums, int k) {

        vector<int> count(32, 0);
        int start = 0, end = 0, minLength = INT_MAX;

        while (end < nums.size()) {
            updateBits(count, nums[end], 1);
            while (start <= end && getVal(count) >= k) {
                minLength = min(minLength, end - start + 1);
                updateBits(count, nums[start], -1);
                start++;
            }
            end++;
        }

        return minLength == INT_MAX ? -1 : minLength;
    }

    private:
    void updateBits(vector<int>& count, int num, int val) {
        
        for (int i = 0; i < 32; i++) {
            if ((num >> i) & 1) {
                count[i] += val;
            }
        }
    }
    int getVal(const vector<int>& count) {
        int ans = 0;
        
        for (int i = 0; i < 32; i++) {
            if (count[i] > 0) {
                ans |= (1 << i);
            }
        }

        return ans;
      }
    };

Runtime: 63 ms, beating 58.76% of leetcode users solutions using C++.
Memory: 88.28 mb, beating 73.67% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, bit manipulation, while loops, for loops, if statements, and min.

### Solution Nov 11, 2024 (C++, leetcode) 2601. Prime Subtraction Operation (Medium)
In .LeetcodeDailySolution folder as Nov11,2024.cpp

#### Prompt:

You are given a 0-indexed integer array nums of length n.

You can perform the following operation as many times as you want:

Pick an index i that you haven’t picked before, and pick a prime p strictly less than nums[i], then subtract p from nums[i].
Return true if you can make nums a strictly increasing array using the above operation and false otherwise.

A strictly increasing array is an array whose each element is strictly greater than its preceding element.

#### Solution:

    class Solution {
    public:
    bool primeSubOperation(vector<int>& nums) {

        int maxElement = *max_element(nums.begin(), nums.end());
        vector<bool> sieve(maxElement + 1, true);
        sieve[1] = false;

        for (int i = 2; i <= sqrt(maxElement + 1); i++) {
            if (sieve[i]) {
                for (int j = i * i; j <= maxElement; j += i) {
                    sieve[j] = false;
                }
            }
        }
        int currValue = 1;
        int i = 0;

        while (i < nums.size()) {

            int difference = nums[i] - currValue;

            if (difference < 0) {
                return false;
            }

            if (sieve[difference] == true || difference == 0) {

                i++;
                currValue++;

            } else {

                currValue++;

            }
        }
        
        return true;
      }
    };

Runtime: 1 ms, beating 76.68% of leetcode users solutions using C++.
Memory: 27.23 mb, beating 80.07% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, while loop, if statements, and else statement.

### Solution Nov 12, 2024 (C++, leetcode) 2070. Most Beautiful Item for Each Query (Medium)
In .LeetcodeDailySolution folder as Nov12,2024.cpp

#### Prompt:

You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.

You are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.

Return an array answer of the same length as queries where answer[j] is the answer to the jth query.

#### Solution:

    class Solution {
    public:
    vector<int> maximumBeauty(vector<vector<int>>& items,
                              vector<int>& queries) {

        int maxI = INT_MAX;
        vector<vector<int>> res = {{0, 0, maxI}};
        sort(items.begin(), items.end());

        for (const auto& item : items) {

            int price = item[0];
            int beauty = item[1];

            if (beauty > res.back()[1]) {

                res.back()[2] = price;
                res.push_back({price, beauty, maxI});
            }
        }
        vector<int> ans;

        for (int x : queries) {
            for (int i = res.size() - 1; i >= 0; i--) {
                if (res[i][0] <= x) {
                    ans.push_back(res[i][1]);
                    break;
                }
            }
        }

        return ans;
      }
    };

Runtime: 57 ms, beating 62.79% of leetcode users solutions using C++.
Memory: 103.11 mb, beating 23.67% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, for loops, and if statements.

### Solution Nov 13, 2024 (C++, leetcode) 2563. Count the Number of Fair Pairs (Medium)
In .LeetcodeDailySolution folder as Nov13,2024.cpp

#### Prompt:

Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs.

A pair (i, j) is fair if:
0 <= i < j < n, and
lower <= nums[i] + nums[j] <= upper

#### Solution:

    class Solution {
    public:
    long long countFairPairs(vector<int>& v, int lower, int upper) {

        long long ans = 0;
        sort(v.begin(), v.end());

        for (int i = 0; i < v.size() - 1; i++) {

            auto up = upper_bound(v.begin() + i + 1, v.end(), upper - v[i]);
            auto low = lower_bound(v.begin() + i + 1, v.end(), lower - v[i]);
            ans += (up - low);
        }

        return ans;
      }
    };

Runtime: 68 ms, beating 41.04% of leetcode users solutions using C++.
Memory: 60.37 mb, beating 61.15% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, and for loop.

### Solution Nov 14, 2024 (C++, leetcode) 2064. Minimized Maximum of Products Distributed to Any Store (Medium)
In .LeetcodeDailySolution folder as Nov14,2024.cpp

#### Prompt:

You are given an integer n indicating there are n specialty retail stores. There are m product types of varying amounts, which are given as a 0-indexed integer array quantities, where quantities[i] represents the number of products of the ith product type.

You need to distribute all products to the retail stores following these rules:

A store can only be given at most one product type but can be given any amount of it.
After distribution, each store will have been given some number of products (possibly 0). Let x represent the maximum number of products given to any store. You want x to be as small as possible, i.e., you want to minimize the maximum number of products that are given to any store.
Return the minimum possible x.

#### Solution:

    class Solution {
    public:
    bool isPossible(int n, vector<int>& quantities, int mid) {

        int stores = 0;

        for (auto x : quantities) {
            stores += x / mid;
            if (x % mid)
                stores++;
            if (stores > n)
                return 0;
        }

        return stores <= n;
    }
    int minimizedMaximum(int n, vector<int>& quantities) {
        int s = 1, e = 100000, ans = -1;

        while (s <= e) {

            int mid = s + (e - s) / 2;

            if (isPossible(n, quantities, mid)) {
                ans = mid;
                e = mid - 1;
            } else {
                s = mid + 1;
            }
        }

        return ans;
      }
    };

Runtime: 31 ms, beating 79.78% of leetcode users solutions using C++.
Memory: 87.22 mb, beating 72.39% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, binary search, for loop, if statements, and while loop.

### Solution Nov 15, 2024 (C++, leetcode) 1574. Shortest Subarray to be Removed to Make Array Sorted (Medium)
In .LeetcodeDailySolution folder as Nov15,2024.cpp

#### Prompt:

Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.

Return the length of the shortest subarray to remove.

A subarray is a contiguous subsequence of the array.

#### Solution:

    class Solution {
    public:
    int findLengthOfShortestSubarray(vector<int>& arr) {

        int n = arr.size();
        int left = 0;

        while (left + 1 < n && arr[left] <= arr[left + 1]) {
            left++;
        }

        if (left == n - 1)
            return 0;

        int right = n - 1;

        while (right > 0 && arr[right - 1] <= arr[right]) {
            right--;
        }
        int result = min(n - left - 1, right);
        int i = 0, j = right;

        while (i <= left && j < n) {
            if (arr[i] <= arr[j]) {
                result = min(result, j - i - 1);
                i++;
            } else {
                j++;
            }
        }

        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 69.51 mb, beating 67.21% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, while loops, if statements, else statement, and min.

### Solution Nov 16, 2024 (C++, leetcode) 3254. Find the Power of K-Size Subarrays I (Medium)
In .LeetcodeDailySolution folder as Nov16,2024.cpp

#### Prompt:

You are given an array of integers nums of length n and a positive integer k.

The power of an array is defined as:

Its maximum element if all of its elements are consecutive and sorted in ascending order.
-1 otherwise.
You need to find the power of all 
subarrays
 of nums of size k.

Return an integer array results of size n - k + 1, where results[i] is the power of nums[i..(i + k - 1)].

#### Solution:

    class Solution {
    public:
    vector<int> resultsArray(vector<int>& nums, int k) {
        vector<int> res;

        int l = 0;
        int consec_cnt = 1;

        for (int r = 0; r < nums.size(); r++) {
            if (r > 0 && nums[r - 1] + 1 == nums[r]) {
                consec_cnt++;
            }

            if (r - l + 1 > k) {
                if (nums[l] + 1 == nums[l + 1]) {
                    consec_cnt--;
                }
                l++;
            }

            if (r - l + 1 == k) {
                res.push_back(consec_cnt == k ? nums[r] : -1);
            }
        }

        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 33.06 mb, beating 66.35% of leetcode users solutions using C++.

#### Concepts Applied:

Sliding window, arrays, for loop, and if statements.

### Solution Nov 17, 2024 (C++, leetcode) 862. Shortest Subarray with Sum at Least K (Hard)
In .LeetcodeDailySolution folder as Nov17,2024.cpp

#### Prompt:

Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1.

A subarray is a contiguous part of an array.

#### Solution:

    class Solution {
    public:
    int shortestSubarray(vector<int>& nums, int k) {
        int n = nums.size();
        vector<long long> sum(n + 1);

        for (int i = 0; i < n; i++) {
            sum[i + 1] = sum[i] + nums[i];
        }

        vector<int> q(n + 1);
        int l = 0, r = 0;
        int minLength = n + 1;

        for (int i = 0; i < sum.size(); i++) {
            while (r > l && sum[i] >= sum[q[l]] + k) {
                minLength = min(minLength, i - q[l++]);
            }

            while (r > l && sum[i] <= sum[q[r - 1]]) {
                r--;
            }

            q[r++] = i;
        }

        return minLength <= n ? minLength : -1;
      }
    };

Runtime: 38 ms, beating 66.40% of leetcode users solutions using C++.
Memory: 107.42 mb, beating 94.14% of leetcode users solutions using C++.

#### Concepts Applied:

Sliding window, arrays, for loops, while loops, and min.

### Solution Nov 18, 2024 (C++, leetcode) 1652. Defuse the Bomb (Easy)
In .LeetcodeDailySolution folder as Nov18,2024.cpp

#### Prompt:

You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.

To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.

If k > 0, replace the ith number with the sum of the next k numbers.
If k < 0, replace the ith number with the sum of the previous k numbers.
If k == 0, replace the ith number with 0.
As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].

Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!

#### Solution:

    class Solution {
    public:
    vector<int> decrypt(vector<int>& code, int k) {
        int N = code.size();
        vector<int> res(N, 0);

        for (int i = 0; i < N; i++) {
            if (k > 0) {
                for (int j = i + 1; j < i + 1 + k; j++) {
                    res[i] += code[j % N];
                }
            } else if (k < 0) {
                for (int j = i - 1; j > i - 1 - abs(k); j--) {
                    res[i] += code[((j % N) + N) % N];
                }
            }
        }

        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.39 mb, beating 60.16% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, if statement, and else-if statement.

### Solution Nov 19, 2024 (C++, leetcode) 2461. Maximum Sum of Distinct Subarrays With Length K (Medium)
In .LeetcodeDailySolution folder as Nov19,2024.cpp

#### Prompt:

You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:

The length of the subarray is k, and
All the elements of the subarray are distinct.
Return the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.

A subarray is a contiguous non-empty sequence of elements within an array.

#### Solution:

    class Solution {
    public:
    long long maximumSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        unordered_set<int> elements;
        long long current_sum = 0;
        long long max_sum = 0;
        int begin = 0;

        for (int end = 0; end < n; end++) {
            if (elements.find(nums[end]) == elements.end()) {
                current_sum += nums[end];
                elements.insert(nums[end]);

                if (end - begin + 1 == k) {
                    max_sum = max(max_sum, current_sum);
                    current_sum -= nums[begin];
                    elements.erase(nums[begin]);
                    begin++;
                }
            } else {
                while (nums[begin] != nums[end]) {
                    current_sum -= nums[begin];
                    elements.erase(nums[begin]);
                    begin++;
                }
                begin++;
            }
        }

        return max_sum;
      }
    };

Runtime: 103 ms, beating 81.93% of leetcode users solutions using C++.
Memory: 95.18 mb, beating 77.38% of leetcode users solutions using C++.

#### Concepts Applied:

Sliding window, arrays, unordered set, for loop, if statements, else statement, and while loop.

### Solution Nov 20, 2024 (C++, leetcode) 2516. Take K of Each Character From Left and Right (Medium)
In .LeetcodeDailySolution folder as Nov20,2024.cpp

#### Prompt:

You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.

Return the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.

#### Solution:

    class Solution {
    public:
    int takeCharacters(string s, int k) {

        vector<int> count(3, 0);
        for (char c : s) {
            count[c - 'a']++;
        }

        if (*min_element(count.begin(), count.end()) < k) {
            return -1;
        }
        int res = INT_MAX;
        int l = 0;
        for (int r = 0; r < s.length(); r++) {
            count[s[r] - 'a']--;

            while (*min_element(count.begin(), count.end()) < k) {
                count[s[l] - 'a']++;
                l++;
            }
            res = min(res, static_cast<int>(s.length()) - (r - l + 1));
        }
        return res;
      }
    };

Runtime: 9 ms, beating 77.82% of leetcode users solutions using C++.
Memory: 12.17 mb, beating 57.39% of leetcode users solutions using C++.

#### Concepts Applied:

Slding window, arrays, for loops, if statement, while loop, and min.

### Solution Nov 21, 2024 (C++, leetcode) 2257. Count Unguarded Cells in the Grid (Medium)
In .LeetcodeDailySolution folder as Nov21,2024.cpp

#### Prompt:

You are given two integers m and n representing a 0-indexed m x n grid. You are also given two 2D integer arrays guards and walls where guards[i] = [rowi, coli] and walls[j] = [rowj, colj] represent the positions of the ith guard and jth wall respectively.

A guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.

Return the number of unoccupied cells that are not guarded.

#### Solution:

    class Solution {
    public:
    int countUnguarded(int m, int n, vector<vector<int>>& g,
                       vector<vector<int>>& w) {
        vector<vector<int>> vis(m, vector<int>(n, 0));

        for (auto val : w) {
            vis[val[0]][val[1]] = 2;
        }

        for (auto val : g) {
            vis[val[0]][val[1]] = 3;
        }

        for (auto val : g) {
            int row = val[0], col = val[1];

            for (int i = row + 1; i < m; i++) {
                if (vis[i][col] == 2 || vis[i][col] == 3)
                    break;
                vis[i][col] = 1;
            }

            for (int i = row - 1; i >= 0; i--) {
                if (vis[i][col] == 2 || vis[i][col] == 3)
                    break;
                vis[i][col] = 1;
            }

            for (int i = col + 1; i < n; i++) {
                if (vis[row][i] == 2 || vis[row][i] == 3)
                    break;
                vis[row][i] = 1;
            }

            for (int i = col - 1; i >= 0; i--) {
                if (vis[row][i] == 2 || vis[row][i] == 3)
                    break;
                vis[row][i] = 1;
            }
        }

        int unguarded = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (vis[i][j] == 0)
                    unguarded++;
            }
        }

        return unguarded;
      }
    };

Runtime: 183 ms, beating 25.24% of leetcode users solutions using C++.
Memory: 208.34 mb, beating 24.20% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, if statements, and matrix.

### Solution Nov 22, 2024 (C++, leetcode) 1072. Flip Columns For Maximum Number of Equal Rows (Medium)
In .LeetcodeDailySolution folder as Nov22,2024.cpp

#### Prompt:

You are given an m x n binary matrix matrix.

You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from 0 to 1 or vice versa).

Return the maximum number of rows that have all values equal after some number of flips.

#### Solution:

    class Solution {
    public:
    int maxEqualRowsAfterFlips(vector<vector<int>>& mat) {
        unordered_map<string, int> patFreq;

        for (const auto& row : mat) {
            string pattern;
            if (row[0] == 0) {
                for (int bit : row)
                    pattern += to_string(bit);
            } else {
                for (int bit : row)
                    pattern += to_string(bit ^ 1);
            }
            patFreq[pattern]++;
        }
        int maxFreq = 0;

        for (const auto& pair : patFreq) {
            maxFreq = max(maxFreq, pair.second);
        }

        return maxFreq;
      }
    };

Runtime: 90 ms, beating 28.17% of leetcode users solutions using C++.
Memory: 75.68 mb, beating 57.30% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, unordered map, for loops, if statement, and else statement.

### Solution Nov 23, 2024 (C++, leetcode) 1861. Rotating the Box (Medium)
In .LeetcodeDailySolution folder as Nov23,2024.cpp

#### Prompt:

You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:

A stone '#'
A stationary obstacle '*'
Empty '.'
The box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.

It is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.

Return an n x m matrix representing the box after the rotation described above.

#### Solution:

    class Solution {
    public:
    vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {

        int m = box.size();
        int n = box[0].size();

        for (auto& row : box) {
            int dropPos = n - 1;

            for (int currPos = n - 1; currPos >= 0; currPos--) {
                if (row[currPos] == '*') {
                    dropPos = currPos - 1;
                } else if (row[currPos] == '#') {
                    swap(row[dropPos], row[currPos]);
                    dropPos--;
                }
            }
        }
        vector<vector<char>> rotatedBox(n, vector<char>(m));

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                rotatedBox[j][m - 1 - i] = box[i][j];
            }
        }

        return rotatedBox;
      }
    };

Runtime: 201 ms, beating 31.82% of leetcode users solutions using C++.
Memory: 56.41 mb, beating 25.31% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, matrix, for loops, if statement, and else-if statement.

### Solution Nov 24, 2024 (C++, leetcode) 1975. Maximum Matrix Sum (Medium)
In .LeetcodeDailySolution folder as Nov24,2024.cpp

#### Prompt:

You are given an n x n integer matrix. You can do the following operation any number of times:

Choose any two adjacent elements of matrix and multiply each of them by -1.
Two elements are considered adjacent if and only if they share a border.

Your goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above.

#### Solution:

    class Solution {
    public:
    long long maxMatrixSum(vector<vector<int>>& matrix) {
        
        long long absSum = 0;
        int negCount = 0;
        int absMin = INT_MAX;

        for (const auto& row : matrix) {
            for (int num : row) {
                absSum += abs(num);
                absMin = min(absMin, abs(num));

                if (num < 0)
                    negCount++;
            }
        }

        return (negCount % 2 == 1) ? absSum - 2 * absMin : absSum;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 38.54 mb, beating 13.99% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, matrix, for loops, absolute value, min, and if statement.

### Solution Nov 25, 2024 (C++, leetcode) 773. Sliding Puzzle (Hard)
In .LeetcodeDailySolution folder as Nov25,2024.cpp

#### Prompt:

On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.

The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].

Given the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.

#### Solution:

    class Solution {
    public:
    int slidingPuzzle(vector<vector<int>>& board) {

        vector<vector<int>> dir = {{1, 3}, {0, 2, 4}, {1, 5},
                                   {0, 4}, {1, 3, 5}, {2, 4}};
        string target = "123450";
        set<string> vis;
        queue<string> q;
        string start = "";

        for (auto row : board) {
            for (auto col : row) {
                start += col + '0';
            }
        }

        q.push(start);
        vis.insert(start);
        int step = 0;

        while (!q.empty()) {
            int size = q.size();
            while (size--) {
                string current = q.front();
                q.pop();

                if (current == target)
                    return step;

                int zero = current.find('0');
                for (auto move : dir[zero]) {
                    string next = current;
                    swap(next[move], next[zero]);
                    if (!vis.count(next)) {
                        vis.insert(next);
                        q.push(next);
                    }
                }
            }
            step++;
        }
        return -1;
      }
    };

Runtime: 10 ms, beating 43.12% of leetcode users solutions using C++.
Memory: 11.04 mb, beating 86.82% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, grid, matrix, set, queue, for loops, while loops, and if statements.

### Solution Nov 26, 2024 (C++, leetcode) 2924. Find Champion II (Medium)
In .LeetcodeDailySolution folder as Nov26,2024.cpp

#### Prompt:

There are n teams numbered from 0 to n - 1 in a tournament; each team is also a node in a DAG.

You are given the integer n and a 0-indexed 2D integer array edges of length m representing the DAG, where edges[i] = [ui, vi] indicates that there is a directed edge from team ui to team vi in the graph.

A directed edge from a to b in the graph means that team a is stronger than team b and team b is weaker than team a.

Team a will be the champion of the tournament if there is no team b that is stronger than team a.

Return the team that will be the champion of the tournament if there is a unique champion, otherwise, return -1.

Notes

A cycle is a series of nodes a1, a2, ..., an, an+1 such that node a1 is the same node as node an+1, the nodes a1, a2, ..., an are distinct, and there is a directed edge from the node ai to node ai+1 for every i in the range [1, n].
A DAG is a directed graph that does not have any cycle.

#### Solution:

    class Solution {
    public:
    static int findChampion(int n, vector<vector<int>>& edges) {
        vector<int> deg(n, 0);
        for (auto& e : edges) {
            int w = e[1];
            deg[w]++;
        }
        vector<int> deg0;
        for (int i = 0; i < n; i++) {
            if (deg[i] == 0)
                deg0.push_back(i);
        }
        if (deg0.size() != 1)
            return -1;
        else
            return deg0[0];
      }
    };

Runtime: 1 ms, beating 77.42% of leetcode users solutions using C++.
Memory: 94.01 mb, beating 65.90% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, if statements, and else statement.

### Solution Nov 27, 2024 (C++, leetcode) 3243. Shortest Distance After Road Addition Queries I (Medium)
In .LeetcodeDailySolution folder as Nov27,2024.cpp

#### Prompt:

You are given an integer n and a 2D integer array queries.

There are n cities numbered from 0 to n - 1. Initially, there is a unidirectional road from city i to city i + 1 for all 0 <= i < n - 1.

queries[i] = [ui, vi] represents the addition of a new unidirectional road from city ui to city vi. After each query, you need to find the length of the shortest path from city 0 to city n - 1.

Return an array answer where for each i in the range [0, queries.length - 1], answer[i] is the length of the shortest path from city 0 to city n - 1 after processing the first i + 1 queries.

#### Solution:

    class Solution {
    public:
    vector<int> shortestDistanceAfterQueries(int n,
                                             vector<vector<int>>& queries) {
        vector<vector<int>> adj(n);
        for (int i = 0; i < n; i++) {
            adj[i].push_back(i + 1);
        }

        auto shortest_path = [&]() {
            queue<pair<int, int>> q;
            q.push({0, 0});
            unordered_set<int> visit;
            visit.insert(0);

            while (!q.empty()) {
                auto [cur, length] = q.front();
                q.pop();

                if (cur == n - 1)
                    return length;

                for (int nei : adj[cur]) {
                    if (visit.find(nei) == visit.end()) {
                        q.push({nei, length + 1});
                        visit.insert(nei);
                    }
                }
            }
            return -1;
        };
        vector<int> res;
        for (const auto& query : queries) {
            adj[query[0]].push_back(query[1]);
            res.push_back(shortest_path());
        }
        return res;
      }
    };

Runtime: 799 ms, beating 10.99% of leetcode users solutions using C++.
Memory: 330.48 mb, beating 9.99% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, shortest path, queue, pairs, unordered set, while loop, and if statements.

### Solution Nov 28, 2024 (C++, leetcode) 2290. Minimum Obstacle Removal to Reach Corner (Hard)
In .LeetcodeDailySolution folder as Nov28,2024.cpp

#### Prompt:

You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:

0 represents an empty cell,
1 represents an obstacle that may be removed.
You can move up, down, left, or right from and to an empty cell.

Return the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).

#### Solution:

    class Solution {
    public:
    int minimumObstacles(vector<vector<int>>& grid) {

        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> distance(m, vector<int>(n, INT_MAX));
        deque<pair<int, int>> dq;

        distance[0][0] = 0;
        dq.push_front({0, 0});
        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!dq.empty()) {
            auto [x, y] = dq.front();
            dq.pop_front();
            for (auto [dx, dy] : directions) {
                int nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                    int newDist = distance[x][y] + grid[nx][ny];
                    if (newDist < distance[nx][ny]) {
                        distance[nx][ny] = newDist;
                        if (grid[nx][ny] == 0) {
                            dq.push_front({nx, ny});
                        } else {
                            dq.push_back({nx, ny});
                        }
                    }
                }
            }
        }

        return distance[m - 1][n - 1];
      }
    };

Runtime: 109 ms, beating 94.33% of leetcode users solutions using C++.
Memory: 121.78 mb, beating 58.60% of leetcode users solutions using C++.

#### Concepts Applied:

Grid, arrays, deque, pair, while loop, for loop, if statements, and else statement.

### Solution Dec 1, 2024 (C++, leetcode) 1346. Check If N and Its Double Exist (Easy)
In .LeetcodeDailySolution folder as Dec1,2024.cpp

#### Prompt:

Given an array arr of integers, check if there exist two indices i and j such that :

i != j
0 <= i, j < arr.length
arr[i] == 2 * arr[j]

#### Solution:

    class Solution {
    public:
    bool checkIfExist(vector<int>& arr) {

        unordered_set<int> seen;

        for (int num : arr) {

            if (seen.count(num * 2) || (num % 2 == 0 && seen.count(num / 2))) {
                return true;
            }

            seen.insert(num);
        }

        return false;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.89 mb, beating 16.29% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered set, array, for loop, and if statement.

### Solution Dec 2, 2024 (C++, leetcode) 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence (Easy)
In .LeetcodeDailySolution folder as Dec2,2024.cpp

#### Prompt:

Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence.

Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1.

A prefix of a string s is any leading contiguous substring of s.

#### Solution:

    class Solution {
    public:
    int isPrefixOfWord(string& sentence, string& searchWord) {

        string s = " " + sentence, t = " " + searchWord;
        int n = s.size();
        int m = s.find(t);

        if (m == -1)
            return -1;
            
        return 1 + count(s.begin(), s.begin() + m, ' ');
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.04 mb, beating 10.68% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, two pointers, and if statement.

### Solution Dec 3, 2024 (C++, leetcode) 2109. Adding Spaces to a String (Medium)
In .LeetcodeDailySolution folder as Dec3,2024.cpp

#### Prompt:

You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index.

For example, given s = "EnjoyYourCoffee" and spaces = [5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain "Enjoy Your Coffee".
Return the modified string after the spaces have been added.

#### Solution:

    class Solution {
    public:
    string addSpaces(string& s, vector<int>& spaces) {

        const int m = spaces.size(), n = s.size();
        string t(n + m, ' ');
        int j = 0;

        for (int i = 0; i < n; i++) {
            if (j < m && i == spaces[j]) {
                t[i + j] = ' ';
                j++;
            }
            t[i + j] = s[i];
        }

        return t;
      }
    };

Runtime: 15 ms, beating 80.95% of leetcode users solutions using C++.
Memory: 80.55 mb, beating 93.04% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, strings, for loop, if statement, and two pointers.

### Solution Dec 4, 2024 (C++, leetcode) 2825. Make String a Subsequence Using Cyclic Increments (Medium)
In .LeetcodeDailySolution folder as Dec4,2024.cpp

#### Prompt:

You are given two 0-indexed strings str1 and str2.

In an operation, you select a set of indices in str1, and for each index i in the set, increment str1[i] to the next character cyclically. That is 'a' becomes 'b', 'b' becomes 'c', and so on, and 'z' becomes 'a'.

Return true if it is possible to make str2 a subsequence of str1 by performing the operation at most once, and false otherwise.

Note: A subsequence of a string is a new string that is formed from the original string by deleting some (possibly none) of the characters without disturbing the relative positions of the remaining characters.

#### Solution:

    class Solution {
    public:
    bool canMakeSubsequence(string src, string tgt) {

        int tgtIndex = 0;
        int tgtLength = tgt.length();

        for (char ch : src) {
            if (tgtIndex < tgtLength && (tgt[tgtIndex] - ch + 26) % 26 <= 1) {
                tgtIndex++;
            }
        }

        return tgtIndex == tgtLength;
      }
    };

Runtime: 3 ms, beating 67.21% of leetcode users solutions using C++.
Memory: 16.98 mb, beating 18.83% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, two pointers, for loop, and if statement.

### Solution Dec 5, 2024 (C++, leetcode) 2337. Move Pieces to Obtain a String (Medium)
In .LeetcodeDailySolution folder as Dec5,2024.cpp

#### Prompt:

You are given two strings start and target, both of length n. Each string consists only of the characters 'L', 'R', and '_' where:

The characters 'L' and 'R' represent pieces, where a piece 'L' can move to the left only if there is a blank space directly to its left, and a piece 'R' can move to the right only if there is a blank space directly to its right.
The character '_' represents a blank space that can be occupied by any of the 'L' or 'R' pieces.
Return true if it is possible to obtain the string target by moving the pieces of the string start any number of times. Otherwise, return false.

#### Solution:

    class Solution {
    public:
    static bool canChange(string& s, string& t) {

        const int n = s.size();

        for (int i = 0, j = 0; i < n || j < n; i++, j++) {
            while (i < n && s[i] == '_')
                i++;
            while (j < n && t[j] == '_')
                j++;

            char c = s[i];

            if (c != t[j])
                return 0;
            if (c == 'L' && i < j)
                return 0;
            if (c == 'R' && i > j)
                return 0;
        }

        return 1;
      }
    };

Runtime: 8 ms, beating 70.26% of leetcode users solutions using C++.
Memory: 18.80 mb, beating 97.06% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loop, while loops, and if statements.

### Solution Dec 6, 2024 (C++, leetcode) 2554. Maximum Number of Integers to Choose From a Range I (Medium)
In .LeetcodeDailySolution folder as Dec6,2024.cpp

#### Prompt:

You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:

The chosen integers have to be in the range [1, n].
Each integer can be chosen at most once.
The chosen integers should not be in the array banned.
The sum of the chosen integers should not exceed maxSum.
Return the maximum number of integers you can choose following the mentioned rules.

#### Solution:

    class Solution {

    public:
    int maxCount(vector<int>& banned, int n, int maxSum) {

        unordered_set<int> bannedSet(banned.begin(), banned.end());

        long long sum = 0;
        int count = 0;

        for (int i = 1; i <= n; i++) {

            if (bannedSet.count(i))
                continue;

            sum += i;

            if (sum > maxSum)
                break;

            count++;
        }

        return count;
      }
    };

Runtime: 191 ms, beating 50.17% of leetcode users solutions using C++.
Memory: 177.96 mb, beating 44.27% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, unordered set, for loop, and if statements.

### Solution Dec 7, 2024 (C++, leetcode) 1760. Minimum Limit of Balls in a Bag (Medium)
In .LeetcodeDailySolution folder as Dec7,2024.cpp

#### Prompt:

You are given an integer array nums where the ith bag contains nums[i] balls. You are also given an integer maxOperations.

You can perform the following operation at most maxOperations times:

Take any bag of balls and divide it into two new bags with a positive number of balls.
For example, a bag of 5 balls can become two new bags of 1 and 4 balls, or two new bags of 2 and 3 balls.
Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations.

Return the minimum possible penalty after performing the operations.

#### Solution:

    class Solution {
    public:
    int minimumSize(vector<int>& nums, int maxOps) {

        int low = 1, high = *max_element(nums.begin(), nums.end());

        while (low < high) {

            int mid = low + (high - low) / 2;
            int ops = 0;

            for (int n : nums)
                if ((ops += (n - 1) / mid) > maxOps)
                    break;
                    
            ops <= maxOps ? high = mid : low = mid + 1;
        }

        return high;
      }
    };

Runtime: 15 ms, beating 99.78% of leetcode users solutions using C++.
Memory: 59.82 mb, beating 15.30% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, while loop, for loop, and if statement.

### Solution Dec 8, 2024 (C++, leetcode) 2054. Two Best Non-Overlapping Events (Medium)
In .LeetcodeDailySolution folder as Dec8,2024.cpp

#### Prompt:

You are given a 0-indexed 2D integer array of events where events[i] = [startTimei, endTimei, valuei]. The ith event starts at startTimei and ends at endTimei, and if you attend this event, you will receive a value of valuei. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized.

Return this maximum sum.

Note that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time t, the next event must start at or after t + 1.

#### Solution:

    class Solution {
    public:
    int maxTwoEvents(vector<vector<int>>& events) {
        int n = events.size();

        sort(events.begin(), events.end(),
             [](const vector<int>& a, const vector<int>& b) {
                 return a[0] < b[0];
             });

        vector<int> suffixMax(n);
        suffixMax[n - 1] = events[n - 1][2];

        for (int i = n - 2; i >= 0; --i) {
            suffixMax[i] = max(events[i][2], suffixMax[i + 1]);
        }

        int maxSum = 0;

        for (int i = 0; i < n; ++i) {
            int left = i + 1, right = n - 1;
            int nextEventIndex = -1;

            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (events[mid][0] > events[i][1]) {
                    nextEventIndex = mid;
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }

            if (nextEventIndex != -1) {
                maxSum = max(maxSum, events[i][2] + suffixMax[nextEventIndex]);
            }

            maxSum = max(maxSum, events[i][2]);
        }

        return maxSum;
      }
    };

Runtime: 56 ms, beating 81.90% of leetcode users solutions using C++.
Memory: 124.24 mb, beating 87.30% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, for loops, while loop, if statements, else statement, and binary search.

### Solution Dec 9, 2024 (C++, leetcode) 3152. Special Array II (Medium)
In .LeetcodeDailySolution folder as Dec9,2024.cpp

#### Prompt:

An array is considered special if every pair of its adjacent elements contains two numbers with different parity.

You are given an array of integer nums and a 2D integer matrix queries, where for queries[i] = [fromi, toi] your task is to check that 
subarray nums[fromi..toi] is special or not.

Return an array of booleans answer such that answer[i] is true if nums[fromi..toi] is special.

#### Solution:

    class Solution {
    public:
    vector<bool> isArraySpecial(vector<int>& nums,
                                vector<vector<int>>& queries) {

        const int n = nums.size();
        int prev = nums[0] & 1;
        vector<int> sameParity(n, 0);

        for (int i = 1, j = 0; i < n; i++) {
            bool x = nums[i] & 1;
            if (x == prev)
                j++;
            sameParity[i] = j;
            prev = x;
        }
        const int m = queries.size();
        vector<bool> ans(m, 0);

        for (int i = 0; i < m; i++) {
            int s = queries[i][0], t = queries[i][1];
            ans[i] = (sameParity[s] == sameParity[t]);
        }

        return ans;
      }
    };

Runtime: 8 ms, beating 72.22% of leetcode users solutions using C++.
Memory: 126.66 mb, beating 66.25% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, and if statement.

### Solution Dec 10, 2024 (C++, leetcode) 2981. Find Longest Special Substring That Occurs Thrice I (Medium)
In .LeetcodeDailySolution folder as Dec10,2024.cpp

#### Prompt:

You are given a string s that consists of lowercase English letters.

A string is called special if it is made up of only a single character. For example, the string "abc" is not special, whereas the strings "ddd", "zz", and "f" are special.

Return the length of the longest special substring of s which occurs at least thrice, or -1 if no special substring occurs at least thrice.

A substring is a contiguous non-empty sequence of characters within a string.

#### Solution:

    class Solution {
    public:
    int maximumLength(string s) {

        int n = s.size();
        int l = 1, r = n;

        if (!helper(s, n, l))
            return -1;

        while (l + 1 < r) {
            int mid = (l + r) / 2;
            if (helper(s, n, mid))
                l = mid;
            else
                r = mid;
        }

        return l;
    }

    private:
    bool helper(const string& s, int n, int x) {

        vector<int> cnt(26, 0);
        int p = 0;

        for (int i = 0; i < n; i++) {
            while (s[p] != s[i])
                p++;
            if (i - p + 1 >= x)
                cnt[s[i] - 'a']++;
            if (cnt[s[i] - 'a'] > 2)
                return true;
        }

        return false;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.74 mb, beating 95.16% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search, strings, array, if statements, while loops, and for loop.

### Solution Dec 11, 2024 (C++, leetcode) 2779. Maximum Beauty of an Array After Applying Operation (Medium)
In .LeetcodeDailySolution folder as Dec11,2024.cpp

#### Prompt:

You are given a 0-indexed array nums and a non-negative integer k.

In one operation, you can do the following:

Choose an index i that hasn't been chosen before from the range [0, nums.length - 1].
Replace nums[i] with any integer from the range [nums[i] - k, nums[i] + k].
The beauty of the array is the length of the longest subsequence consisting of equal elements.

Return the maximum possible beauty of the array nums after applying the operation any number of times.

Note that you can apply the operation to each index only once.

A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.

#### Solution:

    class Solution {
    public:
    static int maximumBeauty(vector<int>& nums, int k) {

        int freq[100001] = {0};
        int xMax = 0, xMin = 1e6;

        for (int x : nums) {
            freq[x]++;
            xMax = max(x, xMax);
            xMin = min(x, xMin);
        }
        int cnt = 0, maxCnt = 0;

        for (int l = xMin, r = xMin; r <= xMax; r++) {

            cnt += freq[r];

            while (r - l > 2 * k) {
                cnt -= freq[l];
                l++;
            }
            maxCnt = max(maxCnt, cnt);
        }

        return maxCnt;
      }
    };

Runtime: 4 ms, beating 99.43% of leetcode users solutions using C++.
Memory: 105.46 mb, beating 51.61% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, max, min, and while loop.

### Solution Dec 12, 2024 (C++, leetcode) 2558. Take Gifts From the Richest Pile (Easy)
In .LeetcodeDailySolution folder as Dec12,2024.cpp

#### Prompt:

You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following:

Choose the pile with the maximum number of gifts.
If there is more than one pile with the maximum number of gifts, choose any.
Leave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.
Return the number of gifts remaining after k seconds.

#### Solution:

    class Solution {
    public:
    long long pickGifts(vector<int>& gifts, int k) {

        make_heap(gifts.begin(), gifts.end());

        for (int i = 0, x = INT_MAX; i < k && x > 1; i++) {
            pop_heap(gifts.begin(), gifts.end());
            x = gifts.back();
            gifts.back() = sqrt(gifts.back());
            push_heap(gifts.begin(), gifts.end());
        }

        return accumulate(gifts.begin(), gifts.end(), 0LL);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.88 mb, beating 94.37% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, priority queue, for loop, and math.

### Solution Dec 13, 2024 (C++, leetcode) 2593. Find Score of an Array After Marking All Elements (Medium)
In .LeetcodeDailySolution folder as Dec13,2024.cpp

#### Prompt:

You are given an array nums consisting of positive integers.

Starting with score = 0, apply the following algorithm:

Choose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.
Add the value of the chosen integer to score.
Mark the chosen element and its two adjacent elements if they exist.
Repeat until all the array elements are marked.
Return the score you get after applying the above algorithm.

#### Solution:

    class Solution {
    public:
    long long findScore(vector<int>& nums) {
        const int n = nums.size();
        long long sum = 0;
        for (int l = 0, r = 0; r < n; r += 2) {
            l = r; 

            while (r + 1 < n && nums[r] > nums[r + 1])
                r++;

            for (int i = r; i >= l; i -= 2)
                sum += nums[i];
        }
        return sum;
      }
    };

Runtime: 4 ms, beating 99.31% of leetcode users solutions using C++.
Memory: 92.22 mb, beating 99.69% of leetcode users solutions using C++.

#### Concepts Applied:

Array, for loops, and while loop.

### Solution Dec 14, 2024 (C++, leetcode) 2762. Continuous Subarrays (Medium)
In .LeetcodeDailySolution folder as Dec14,2024.cpp

#### Prompt:

You are given a 0-indexed integer array nums. A subarray of nums is called continuous if:

Let i, i + 1, ..., j be the indices in the subarray. Then, for each pair of indices i <= i1, i2 <= j, 0 <= |nums[i1] - nums[i2]| <= 2.
Return the total number of continuous subarrays.

A subarray is a contiguous non-empty sequence of elements within an array.

#### Solution:

    class Solution {
    public:
    long long continuousSubarrays(vector<int>& nums) {

        int l = 0;
        long long res = 0;
        deque<int> minD, maxD;

        for (int r = 0; r < nums.size(); r++) {

            while (!minD.empty() && nums[minD.back()] >= nums[r])
                minD.pop_back();
            while (!maxD.empty() && nums[maxD.back()] <= nums[r])
                maxD.pop_back();

            minD.push_back(r);
            maxD.push_back(r);

            while (nums[maxD.front()] - nums[minD.front()] > 2) {

                l++;
                
                if (minD.front() < l)
                    minD.pop_front();
                if (maxD.front() < l)
                    maxD.pop_front();
            }

            res += r - l + 1;
        }

        return res;
      }
    };

Runtime: 96 ms, beating 75.07% of leetcode users solutions using C++.
Memory: 115.68 mb, beating 70.19% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, deque, for loop, while loops, and if statements.

### Solution Dec 15, 2024 (C++, leetcode) 1792. Maximum Average Pass Ratio (Medium)
In .LeetcodeDailySolution folder as Dec15,2024.cpp

#### Prompt:

There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.

You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.

The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.

Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.

#### Solution:

    class Solution {
    public:
    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {

        priority_queue<pair<double, pair<int, int>>> pq;

        for (int i = 0; i < classes.size(); i++) {
            int n = classes[i][0];
            int d = classes[i][1];
            double change = (double)(n + 1) / (d + 1) - (double)n / d;
            pq.push({change, {n, d}});
        }
        for (int i = 0; i < extraStudents; i++) {
            auto [change, p] = pq.top();
            pq.pop();
            int n = p.first;
            int d = p.second;
            n++;
            d++;
            double newchange = (double)(n + 1) / (d + 1) - (double)n / d;
            pq.push({newchange, {n, d}});
        }
        double passratio = 0;

        while (!pq.empty()) {
            auto [a, b] = pq.top();
            pq.pop();
            int n = b.first;
            int d = b.second;
            passratio += (double)n / d;
        }

        return passratio / classes.size();
      }
    };

Runtime: 307 ms, beating 84.30% of leetcode users solutions using C++. 
Memory: 97.73 mb, beating 58.14% of leetcode user solutions using C++.

#### Concepts Applied:

Arrays, priority queue, pair, for loops, and while loop.

### Solution Dec 16, 2024 (C++, leetcode) 3264. Final Array State After K Multiplication Operations I (Easy)
In .LeetcodeDailySolution folder as Dec16,2024.cpp

#### Prompt:

You are given an integer array nums, an integer k, and an integer multiplier.

You need to perform k operations on nums. In each operation:

Find the minimum value x in nums. If there are multiple occurrences of the minimum value, select the one that appears first.
Replace the selected minimum value x with x * multiplier.
Return an integer array denoting the final state of nums after performing all k operations.

#### Solution:

    class Solution {
    public:
    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {

        for (int i = 0; i < k; ++i) {
            auto minIt = min_element(nums.begin(), nums.end());
            *minIt *= multiplier;
        }

        return nums;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 27.08 mb, beating 52.48% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, and for loop.

### Solution Dec 17, 2024 (C++, leetcode) 2182. Construct String With Repeat Limit (Medium)
In .LeetcodeDailySolution folder as Dec17,2024.cpp

#### Prompt:

You are given a string s and an integer repeatLimit. Construct a new string repeatLimitedString using the characters of s such that no letter appears more than repeatLimit times in a row. You do not have to use all characters from s.

Return the lexicographically largest repeatLimitedString possible.

A string a is lexicographically larger than a string b if in the first position where a and b differ, string a has a letter that appears later in the alphabet than the corresponding letter in b. If the first min(a.length, b.length) characters do not differ, then the longer string is the lexicographically larger one.

#### Solution:

    class Solution {
    public:
    string repeatLimitedString(string s, int repeatLimit) {

        sort(s.rbegin(), s.rend());
        string result;
        int freq = 1;
        int pointer = 0;

        for (int i = 0; i < s.size(); ++i) {
            if (!result.empty() && result.back() == s[i]) {
                if (freq < repeatLimit) {
                    result += s[i];
                    freq++;
                } else {
                    pointer = max(pointer, i + 1);
                    while (pointer < s.size() && s[pointer] == s[i]) {
                        pointer++;
                    }

                    if (pointer < s.size()) {
                        result += s[pointer];
                        swap(s[i], s[pointer]);
                        freq = 1;
                    } else {
                        break;
                    }
                }
            } else {
                result += s[i];
                freq = 1;
            }
        }

        return result;
      }
    };

Runtime: 108 ms, beating 8.52% of leetcode users solutions using C++.
Memory: 30.08 mb, beating 7.62% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, for loop, if statements, else statements, and while loop.

### Solution Dec 18, 2024 (C++, leetcode) 1475. Final Prices With a Special Discount in a Shop (Easy)
In .LeetcodeDailySolution folder as Dec18,2024.cpp

#### Prompt:

You are given an integer array prices where prices[i] is the price of the ith item in a shop.

There is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i]. Otherwise, you will not receive any discount at all.

Return an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.

#### Solution:

    class Solution {
    public:
    vector<int> finalPrices(vector<int>& prices) {

        for (int i = 0; i < prices.size(); i++) {
            for (int j = i + 1; j < prices.size(); j++) {
                if (prices[j] <= prices[i]) {
                    prices[i] -= prices[j];
                    break;
                }
            }
        }
        
        return prices;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 14.17 mb, beating 18.80% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, and if statement.

### Solution Dec 19, 2024 (C++, leetcode) 769. Max Chunks To Make Sorted (Medium)
In .LeetcodeDailySolution folder as Dec19,2024.cpp

#### Prompt:

You are given an integer array arr of length n that represents a permutation of the integers in the range [0, n - 1].

We split arr into some number of chunks (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.

Return the largest number of chunks we can make to sort the array.

#### Solution:

    class Solution {
    public:
    int maxChunksToSorted(vector<int>& arr) {

        const int n = arr.size();
        int cnt = 0, diff = 0;
        
        for (int i = 0; i < n; i++) {
            diff += arr[i] - i;
            cnt += (diff == 0);
        }

        return cnt;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.21 mb, beating 21.11% of leetcode user solutions using C++.

#### Concepts Applied:

Arrays, and for loop.

### Solution Dec 20, 2024 (C++, leetcode) 2415. Reverse Odd Levels of Binary Tree (Medium)
In .LeetcodeDailySolution folder as Dec20,2024.cpp

#### Prompt:

Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.

For example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].
Return the root of the reversed tree.

A binary tree is perfect if all parent nodes have two children and all leaves are on the same level.

The level of a node is the number of edges along the path between it and the root node.

#### Solution:

    class Solution {
    public:
    TreeNode* reverseOddLevels(TreeNode* root) {

        dfs(root->left, root->right, 0);

        return root;
    }

    private:
    void dfs(TreeNode* leftChild, TreeNode* rightChild, int level) {

        if (leftChild == nullptr || rightChild == nullptr) {
            return;
        }
        if (level % 2 == 0) {
            int temp = leftChild->val;
            leftChild->val = rightChild->val;
            rightChild->val = temp;
        }

        dfs(leftChild->left, rightChild->right, level + 1);
        dfs(leftChild->right, rightChild->left, level + 1);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 76.98 mb, beating 77.63% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, and if statements.

### Solution Dec 21, 2024 (C++, leetcode) 2872. Maximum Number of K-Divisible Components (Hard)
In .LeetcodeDailySolution folder as Dec21,2024.cpp

#### Prompt:

There is an undirected tree with n nodes labeled from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

You are also given a 0-indexed integer array values of length n, where values[i] is the value associated with the ith node, and an integer k.

A valid split of the tree is obtained by removing any set of edges, possibly empty, from the tree such that the resulting components all have values that are divisible by k, where the value of a connected component is the sum of the values of its nodes.

Return the maximum number of components in any valid split.

#### Solution:

    class Solution {
    public:
    int maxKDivisibleComponents(int n, vector<vector<int>>& edges,
                                vector<int>& values, int k) {

        unordered_map<int, unordered_set<int>> g;

        for (auto& edge : edges) {
            g[edge[0]].insert(edge[1]);
            g[edge[1]].insert(edge[0]);
        }
        int res = 1;

        function<int(int)> dfs = [&](int node) {
            int total = values[node];

            for (int next_node : g[node]) {

                g[next_node].erase(node);
                int next_total = dfs(next_node);

                if (next_total % k == 0) {
                    res++;
                } else {
                    total += next_total;
                }
            }

            return total % k;
        };
        dfs(0);

        return res;
      }
    };

Runtime: 450 ms, beating 5.52% of leetcode users solutions using C++.
Memory: 270.26 mb, beating 7.36% of leetcode user solutions using C++.

#### Concepts Applied:

Arrays, depth-first search, unordered maps, for loops, if statement, and else statement.

### Solution Dec 22, 2024 (C++, leetcode) 2940. Find Building Where Alice and Bob Can Meet (Hard)
In .LeetcodeDailySolution folder as Dec22,2024.cpp

#### Prompt:

You are given a 0-indexed array heights of positive integers, where heights[i] represents the height of the ith building.

If a person is in building i, they can move to any other building j if and only if i < j and heights[i] < heights[j].

You are also given another array queries where queries[i] = [ai, bi]. On the ith query, Alice is in building ai while Bob is in building bi.

Return an array ans where ans[i] is the index of the leftmost building where Alice and Bob can meet on the ith query. If Alice and Bob cannot move to a common building on query i, set ans[i] to -1.

#### Solution:

    class Solution {
    public:
    vector<int> leftmostBuildingQueries(vector<int>& heights,
                                        vector<vector<int>>& queries) {
        int n = heights.size();
        int queryCount = queries.size();

        vector<int> result(queryCount, -1);
        vector<vector<pair<int, int>>> deferredQueries(n);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>>
            minHeap;

        for (int queryIndex = 0; queryIndex < queryCount; ++queryIndex) {

            int aliceStart = queries[queryIndex][0];
            int bobStart = queries[queryIndex][1];

            if (aliceStart == bobStart) {
                result[queryIndex] = aliceStart;
            } else if (aliceStart < bobStart &&
                       heights[aliceStart] < heights[bobStart]) {
                result[queryIndex] = bobStart;
            } else if (aliceStart > bobStart &&
                       heights[aliceStart] > heights[bobStart]) {
                result[queryIndex] = aliceStart;
            } else {
                int maxHeight = max(heights[aliceStart], heights[bobStart]);
                int maxIndex = max(aliceStart, bobStart);
                deferredQueries[maxIndex].emplace_back(maxHeight, queryIndex);
            }
        }
        for (int currentBuilding = 0; currentBuilding < n; ++currentBuilding) {

            while (!minHeap.empty() &&
                   minHeap.top().first < heights[currentBuilding]) {
                int queryIndex = minHeap.top().second;
                minHeap.pop();
                result[queryIndex] = currentBuilding;
            }
            for (auto& query : deferredQueries[currentBuilding]) {
                minHeap.emplace(query.first, query.second);
            }
        }

        return result;
      }
    };

Runtime: 79 ms, beating 77.56% of leetcode users solutions using C++.
Memory: 264.84 mb, beating 57.69% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, priority queue, pairs, for loops, while loop, if statements, else-if statements, and max.

### Solution Dec 23, 2024 (C++, leetcode) 2471. Minimum Number of Operations to Sort a Binary Tree by Level (Medium)
In .LeetcodeDailySolution folder as Dec23,2024.cpp

#### Prompt:

You are given the root of a binary tree with unique values.

In one operation, you can choose any two nodes at the same level and swap their values.

Return the minimum number of operations needed to make the values at each level sorted in a strictly increasing order.

The level of a node is the number of edges along the path between it and the root node.

#### Solution:

    class Solution {
    public:
    int minimumOperations(TreeNode* root) {

        if (!root)
            return 0;

        queue<TreeNode*> q;
        q.push(root);
        int operations = 0;

        while (!q.empty()) {

            int size = q.size();
            vector<int> level;

            for (int i = 0; i < size; ++i) {

                TreeNode* node = q.front();
                q.pop();
                level.push_back(node->val);

                if (node->left)
                    q.push(node->left);

                if (node->right)
                    q.push(node->right);
            }
            vector<int> sort_level = level;
            sort(sort_level.begin(), sort_level.end());
            unordered_map<int, int> mp;

            for (int i = 0; i < level.size(); ++i) {
                mp[level[i]] = i;
            }
            for (int i = 0; i < level.size(); ++i) {

                while (level[i] != sort_level[i]) {

                    ++operations;
                    int cur = mp[sort_level[i]];
                    mp[level[i]] = cur;
                    swap(level[i], level[cur]);
                }
            }
        }

        return operations;
      }
    };

Runtime: 174 ms, beating 36.36% of leetcode users solutions using C++.
Memory: 217.21 mb, beating 15.83% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, if statements, queue, while loops, for loops, arrays, sorting, and urordered map.

### Solution Dec 24, 2024 (C++, leetcode) 3203. Find Minimum Diameter After Merging Two Trees (Hard)
In .LeetcodeDailySolution folder as Dec24,2024.cpp

#### Prompt:

There exist two undirected trees with n and m nodes, numbered from 0 to n - 1 and from 0 to m - 1, respectively. You are given two 2D integer arrays edges1 and edges2 of lengths n - 1 and m - 1, respectively, where edges1[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the first tree and edges2[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the second tree.

You must connect one node from the first tree with another node from the second tree with an edge.

Return the minimum possible diameter of the resulting tree.

The diameter of a tree is the length of the longest path between any two nodes in the tree.

#### Solution:

    class Solution {
    public:
    static int diameter(vector<vector<int>>& edges) {

        int n = edges.size() + 1;
        vector<int> deg(n, 0);
        vector<vector<int>> adj(n);

        for (auto& e : edges) {

            const int v = e[0], w = e[1];
            adj[v].push_back(w);
            adj[w].push_back(v);
            deg[v]++, deg[w]++;
        }
        queue<int> q;

        for (int i = 0; i < n; i++)

            if (deg[i] == 1)
                q.push(i);

        int level = 0, left = n;

        for (; left > 2; level++) {

            int qz = q.size();
            left -= qz;

            for (int i = 0; i < qz; i++) {

                int v = q.front();
                q.pop();

                for (int w : adj[v]) {

                    if (--deg[w] == 1)
                        q.push(w);
                }
            }
        }

        return (left == 2) ? 2 * level + 1 : 2 * level;
    }
    static int minimumDiameterAfterMerge(vector<vector<int>>& edges1,
                                         vector<vector<int>>& edges2) {

        int d1 = diameter(edges1), d2 = diameter(edges2);

        return max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});
      }
    };

Runtime: 257 ms, beating 82.91% of leetcode users solutions using C++.
Memory: 295.94 mb, beating 93.67% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, queue, if statements, and max. 

### Solution Dec 26, 2024 (C++, leetcode) 494. Target Sum (Medium)
In .LeetcodeDailySolution folder as Dec26,2024.cpp

#### Prompt:

You are given an integer array nums and an integer target.

You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.

For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression "+2-1".
Return the number of different expressions that you can build, which evaluates to target.

#### Solution:

    class Solution {
    public:
    int findTargetSumWays(vector<int>& nums, int target) {

        return cal(nums, target, 0, 0);
    }
    int cal(vector<int>& nums, int tar, int idx, int currSum) {

        if (idx == nums.size()) {
            return (currSum == tar) ? 1 : 0;
        }

        int add = cal(nums, tar, idx + 1, currSum + nums[idx]);
        int sub = cal(nums, tar, idx + 1, currSum - nums[idx]);

        return add + sub;
      }
    };

Runtime: 927 ms, beating 10.71% of leetcode users solutions using C++.
Memory: 11.66 mb, beating 72.39% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, if statement, and math.

### Solution Dec 27, 2024 (C++, leetcode) 1014. Best Sightseeing Pair (Medium)
In .LeetcodeDailySolution folder as Dec27,2024.cpp

#### Prompt:

You are given an integer array values where values[i] represents the value of the ith sightseeing spot. Two sightseeing spots i and j have a distance j - i between them.

The score of a pair (i < j) of sightseeing spots is values[i] + values[j] + i - j: the sum of the values of the sightseeing spots, minus the distance between them.

Return the maximum score of a pair of sightseeing spots.

#### Solution:

    class Solution {
    public:
    int maxScoreSightseeingPair(vector<int>& values) {

        int ans = 0;
        int Prev = values[0];

        for (int j = 1; j < values.size(); j++) {
            ans = max(ans, Prev + values[j] - j);
            Prev = max(Prev, values[j] + j);
        }

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 45.51 mb, beating 55.63% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, and max.

### Solution Dec 28, 2024 (C++, leetcode) 689. Maximum Sum of 3 Non-Overlapping Subarrays (Hard)
In .LeetcodeDailySolution folder as Dec28,2024.cpp

#### Prompt:

Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with maximum sum and return them.

Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.

#### Solution:

    class Solution {
    public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {

        int n = nums.size(), sum1 = 0, sum2 = 0, sum3 = 0;
        int max1 = 0, max12 = 0, max123 = 0;
        int index1 = 0, index12_1 = 0, index12_2 = k;

        vector<int> ans = {0, k, 2 * k};

        for (int i = 0; i < k; i++) {
            sum1 += nums[i];
            sum2 += nums[i + k];
            sum3 += nums[i + 2 * k];
        }
        max1 = sum1;
        max12 = sum1 + sum2;
        max123 = sum1 + sum2 + sum3;

        for (int i = 0; i <= n - 3 * k; i++) {
            if (i > 0) {
                sum1 = sum1 - nums[i - 1] + nums[i + k - 1];
                sum2 = sum2 - nums[i + k - 1] + nums[i + 2 * k - 1];
                sum3 = sum3 - nums[i + 2 * k - 1] + nums[i + 3 * k - 1];
            }

            if (sum1 > max1) {
                max1 = sum1;
                index1 = i;
            }

            if (max1 + sum2 > max12) {
                max12 = max1 + sum2;
                index12_1 = index1;
                index12_2 = i + k;
            }

            if (max12 + sum3 > max123) {
                max123 = max12 + sum3;
                ans = {index12_1, index12_2, i + 2 * k};
            }
        }

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 23.98 mb, beating 92.72% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, max, if statements, and sliding window technique.

### Solution Dec 29, 2024 (C++, leetcode) 1639. Number of Ways to Form a Target String Given a Dictionary (Hard)
In .LeetcodeDailySolution folder as Dec29,2024.cpp

#### Prompt:

You are given a list of strings of the same length words and a string target.

Your task is to form target using the given words under the following rules:

target should be formed from left to right.
To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].
Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.
Repeat the process until you form the string target.
Notice that you can use multiple characters from the same string in words provided the conditions above are met.

Return the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    const int MOD = 1e9 + 7;

    int numWays(vector<string>& words, string target) {
        int n = words[0].size();
        int m = target.size();

        vector<unordered_map<char, int>> freq(n);

        for (const string& word : words) {
            for (int i = 0; i < n; i++) {
                freq[i][word[i]]++;
            }
        }

        vector<vector<int>> memo(n + 1, vector<int>(m + 1, -1));

        function<int(int, int)> traverse = [&](int level, int index) -> int {
            if (index == m)
                return 1;
            if (level == n)
                return 0;

            if (memo[level][index] != -1)
                return memo[level][index];

            int ways = traverse(level + 1, index);

            if (freq[level].count(target[index])) {
                long long count = freq[level][target[index]];
                ways = (ways + count * traverse(level + 1, index + 1)) % MOD;
            }

            return memo[level][index] = ways;
        };

        return traverse(0, 0);
      }
    };

Runtime: 208 ms, beating 14.36% of leetcode users solutions using C++.
Memory: 61.40 mb, beating 36.50% of leetcode users solutions using C++.

#### Concepts Applied:

Modulo, arrays, unordered map, for loops, functions, if statements, and traversals.

### Solution Dec 30, 2024 (C++, leetcode) 2466. Count Ways To Build Good Strings (Medium)
In .LeetcodeDailySolution folder as Dec30,2024.cpp

#### Prompt:

Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:

Append the character '0' zero times.
Append the character '1' one times.
This can be performed any number of times.

A good string is a string constructed by the above process having a length between low and high (inclusive).

Return the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    private:
    const int mod = 1e9 + 7;

    public:
    int countGoodStrings(int low, int high, int zero, int one) {
        
        if (zero > one)
            return countGoodStrings(low, high, one, zero);

        vector<int> dp(high + 1, 0);
        dp[0] = 1;
        int res = 0;

        for (int i = 1; i <= high; i++) {
            if (i >= zero)
                dp[i] = (dp[i] + dp[i - zero]) % mod;
            if (i >= one)
                dp[i] = (dp[i] + dp[i - one]) % mod;
            if (i >= low)
                res = (res + dp[i]) % mod;
        }

        return res;
      }
    };

Runtime: 6 ms, beating 63.35% of leetcode users solutions using C++.
Memory: 11.56 mb, beating 75.63% of leetcode users solutions using C++.

#### Concepts Applied:

Modulo, if statements, for loop, array, and dynamic programming.

### Solution Dec 31, 2024 (C++, leetcode) 983. Minimum Cost For Tickets (Medium)
In .LeetcodeDailySolution folder as Dec31,2024.cpp

#### Prompt:

You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.

Train tickets are sold in three different ways:

a 1-day pass is sold for costs[0] dollars,
a 7-day pass is sold for costs[1] dollars, and
a 30-day pass is sold for costs[2] dollars.
The passes allow that many days of consecutive travel.

For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.
Return the minimum number of dollars you need to travel every day in the given list of days.

#### Solution:

    class Solution {
    public:

    int n;
    vector<int> dp; 
    
    int solve(int in, vector<int>& A, vector<int>& B) {

        if (in >= n) {
            return 0;
        }
        if (dp[in] != -1) {
            return dp[in];
        }
        int ans = INT_MAX;
        ans = min(ans, B[0] + solve(in + 1, A, B));
        int num = in;

        while (num < n && A[num] <= A[in] + 6) {
            num++;
        }
        ans = min(ans, B[1] + solve(num, A, B));
        int ij = in;

        while (ij < n && A[ij] <= A[in] + 29) {
            ij++;
        }
        ans = min(ans, B[2] + solve(ij, A, B));
        
        return dp[in] = ans;
    }
    
    int mincostTickets(vector<int>& days, vector<int>& costs) {

        n = days.size();
        dp.assign(n, -1);
        
        return solve(0, days, costs);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.18 mb, beating 47.97% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, dynamic programming, if statements, while loops, and min.

### Solution Jan 1, 2025 (C++, leetcode) 1422. Maximum Score After Splitting a String (Easy)
In .LeetcodeDailySolution folder as Jan1,2025.cpp

#### Prompt:

Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).

The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.

#### Solution:

    class Solution {
    public:
    int maxScore(string s) {

        int totalZeros = 0;

        for (char c : s) {
            if (c == '0')
                totalZeros++;
        }
        int ans = -1;
        int zeros = 0;
        int L = s.length();

        for (int i = 1; i < L; i++) {
            if (s.at(i - 1) == '0') {
                zeros++;
                totalZeros--;
            }
            ans = max(ans, (zeros + (L - totalZeros - (i))));
        }
        
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.65 mb, beating 53.68% of leetcode users solutions using C++.

#### Concepts Applied:

For loops, strings, if statements, and max.

### Solution Jan 2, 2025 (C++, leetcode) 2559. Count Vowel Strings in Ranges (Medium)
In .LeetcodeDailySolution folder as Jan2,2025.cpp

#### Prompt:

You are given a 0-indexed array of strings words and a 2D array of integers queries.

Each query queries[i] = [li, ri] asks us to find the number of strings present in the range li to ri (both inclusive) of words that start and end with a vowel.

Return an array ans of size queries.length, where ans[i] is the answer to the ith query.

Note that the vowel letters are 'a', 'e', 'i', 'o', and 'u'.

#### Solution:

    class Solution {
    public:
    static vector<int> vowelStrings(vector<string>& words,
                                    vector<vector<int>>& queries) {

        const bitset<26> isVowel = 1 + (1 << ('e' - 'a')) + (1 << ('i' - 'a')) +
                                   (1 << ('o' - 'a')) + (1 << ('u' - 'a'));
        const int n = words.size(), qz = queries.size();
        vector<int> cnt(n + 1, 0);

        for (int i = 0; i < n; i++) {
            string& w = words[i];
            cnt[i + 1] =
                cnt[i] + (isVowel[w[0] - 'a'] && isVowel[w.back() - 'a']);
        }
        vector<int> ans(qz, 0);
        int i = 0;

        for (auto& q : queries) {
            ans[i++] = cnt[q[1] + 1] - cnt[q[0]];
        }

        return ans;
      }
    };

Runtime: 4 ms, beating 81.15% of leetcode users solutions using C++.
Memory: 69.32 mb, beating 70.68% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, strings, for loops, and bitset.

### Solution Jan 3, 2025 (C++, leetcode) 2270. Number of Ways to Split Array (Medium)
In .LeetcodeDailySolution folder as Jan3,2025.cpp

#### Prompt:

You are given a 0-indexed integer array nums of length n.

nums contains a valid split at index i if the following are true:

The sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.
There is at least one element to the right of i. That is, 0 <= i < n - 1.
Return the number of valid splits in nums.

#### Solution:

    class Solution {
    public:
    int waysToSplitArray(vector<int>& nums) {

        int N = nums.size();
        vector<long long> Prefix(N + 1, 0);

        for (int i = 0; i < N; i++) {
            Prefix[i + 1] = Prefix[i] + nums[i];
        }
        int ans = 0;

        for (int i = 1; i < N; i++) {
            if (Prefix[i] >= Prefix[N] - Prefix[i]) {
                ans++;
            }
        }
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 97.04 mb, beating 26.46% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, splitting, for loops, and if statement.

### Solution Jan 4, 2025 (C++, leetcode) 1930. Unique Length-3 Palindromic Subsequences (Medium)
In .LeetcodeDailySolution folder as Jan4,2025.cpp

#### Prompt:

Given a string s, return the number of unique palindromes of length three that are a subsequence of s.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

A palindrome is a string that reads the same forwards and backwards.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".

#### Solution:

    class Solution {
    public:
    int countPalindromicSubsequence(string s) {

        vector<int> R(26, 0);

        for (auto& u : s) {
            R[u - 'a']++;
        }
        vector<int> L(26, 0);
        unordered_set<int> S;

        for (int i = 0; i < s.length(); i++) {

            int t = s[i] - 'a';
            R[t]--;

            for (int j = 0; j < 26; j++) {
                if (L[j] > 0 && R[j] > 0) {
                    S.insert(26 * t + j);
                }
            }
            L[t]++;
        }

        return S.size();
      }
    };

Runtime: 158 ms, beating 70.90% of leetcode users solutions using C++.
Memory: 16.27 mb, beating 38.39% of leetcode users solutions using C++.

#### Concepts Applied:

Palindrome, arrays, unordered set, for loops, and if statement.

### Solution Jan 6, 2025 (C++, leetcode) 1769. Minimum Number of Operations to Move All Balls to Each Box (Medium)
In .LeetcodeDailySolution folder as Jan6,2025.cpp

#### Prompt:

You have n boxes. You are given a binary string boxes of length n, where boxes[i] is '0' if the ith box is empty, and '1' if it contains one ball.

In one operation, you can move one ball from a box to an adjacent box. Box i is adjacent to box j if abs(i - j) == 1. Note that after doing so, there may be more than one ball in some boxes.

Return an array answer of size n, where answer[i] is the minimum number of operations needed to move all the balls to the ith box.

Each answer[i] is calculated considering the initial state of the boxes.

#### Solution:

    class Solution {
    public:
    vector<int> minOperations(string boxes) {

        int n = boxes.length();
        vector<int> prefix(n, 0);
        vector<int> suffix(n, 0);
        int x = 0;
        int y = 0;

        for (int i = 0; i < n; i++) {
            x += y;
            prefix[i] += x;
            if (boxes[i] == '1')
                y++;
        }
        for (int i = 0; i < n; i++)
            cout << prefix[i] << " ";

        x = 0;
        y = 0;

        for (int i = n - 1; i >= 0; i--) {
            x += y;
            suffix[i] += x;
            if (boxes[i] == '1')
                y++;
        }
        for (int i = n - 1; i >= 0; i--)
            cout << suffix[i] << " ";

        vector<int> ans(n, 0);

        for (int i = 0; i < n; i++) {
            ans[i] = prefix[i] + suffix[i];
        }

        return ans;
      }
    };

Runtime: 175 ms, beating 5.07% of leetcode users solutions using C++.
Memory: 12.66 mb, beating 15.34% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, prefix, suffix, strings, for loops, and if statement.

### Solution Jan 7, 2025 (C++, leetcode) 1408. String Matching in an Array (Easy)
In .LeetcodeDailySolution folder as Jan7,2025.cpp

#### Prompt:

Given an array of string words, return all strings in words that is a substring of another word. You can return the answer in any order.

A substring is a contiguous sequence of characters within a string

#### Solution:

    class Solution {
    public:
    vector<string> stringMatching(vector<string>& words) {

        int n = words.size();
        vector<string> ans;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i != j && words[j].find(words[i]) != string::npos) {
                    ans.push_back(words[i]);
                    break;
                }
            }
        }

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.29 mb, beating 71.96% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, strings, for loops, and if statement.

### Solution Jan 8, 2025 (C++, leetcode) 3042. Count Prefix and Suffix Pairs I (Easy)
In .LeetcodeDailySolution folder as Jan8,2025.cpp

#### Prompt:

You are given a 0-indexed string array words.

Let's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:

isPrefixAndSuffix(str1, str2) returns true if str1 is both a prefix and a suffix of str2, and false otherwise.
For example, isPrefixAndSuffix("aba", "ababa") is true because "aba" is a prefix of "ababa" and also a suffix, but isPrefixAndSuffix("abc", "abcd") is false.

Return an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.

#### Solution:

    class Solution {
    public:
    int countPrefixSuffixPairs(vector<string>& words) {
        int n = words.size();
        int ans = 0;

        for (int i = 0; i < n; i++) {
            string s1 = words[i];

            for (int j = i + 1; j < n; j++) {
                string s2 = words[j];

                if (s2.length() < s1.length()) 
                    continue;

                string pre = s2.substr(0, s1.length());
                string suf = s2.substr(s2.length() - s1.length());

                if (pre == s1 && suf == s1) {
                    ans++;
                }
            }
        }
        return ans;
      }
    };

Runtime: 3 ms, beating 67.94% of leetcode users solutions using C++.
Memory: 23.36 mb, beating 90.45% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loops, if statements, and substrings.

### Solution Jan 9, 2025 (C++, leetcode) 2185. Counting Words With a Given Prefix (Easy)
In .LeetcodeDailySolution folder as Jan9,2025.cpp

#### Prompt:

You are given an array of strings words and a string pref.

Return the number of strings in words that contain pref as a prefix.

A prefix of a string s is any leading contiguous substring of s.

#### Solution:

    class Solution {
    public:
    int prefixCount(vector<string>& words, string pref) {

        int count = 0;

        for (const string& word : words) {
            if (word.find(pref) == 0) {
                count++;
            }
        }

        return count;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.86 mb, beating 98.98% of leetcode users solutions using C++.

#### Concepts Applied:

Prefix, strings, for loop, and if statement.

### Solution Jan 10, 2025 (C++, leetcode) 916. Word Subsets (Medium)
In .LeetcodeDailySolution folder as Jan10,2025.cpp

#### Prompt:

You are given two string arrays words1 and words2.

A string b is a subset of string a if every letter in b occurs in a including multiplicity.

For example, "wrr" is a subset of "warrior" but is not a subset of "world".
A string a from words1 is universal if for every string b in words2, b is a subset of a.

Return an array of all the universal strings in words1. You may return the answer in any order.

#### Solution:

    class Solution {
    public:
    vector<string> wordSubsets(vector<string>& mainWords, vector<string>& requiredWords) {

        int maxCharFreq[26] = {0};
        int tempCharFreq[26];
        
        for (const auto& word : requiredWords) {

            memset(tempCharFreq, 0, sizeof tempCharFreq);

            for (char ch : word) {
                tempCharFreq[ch - 'a']++;
            }
            for (int i = 0; i < 26; ++i) {
                maxCharFreq[i] = max(maxCharFreq[i], tempCharFreq[i]);
            }
        }
        vector<string> universalWords;
        
        for (const auto& word : mainWords) {

            memset(tempCharFreq, 0, sizeof tempCharFreq);

            for (char ch : word) {
                tempCharFreq[ch - 'a']++;
            }
            bool isUniversal = true;
            
            for (int i = 0; i < 26; ++i) {
                if (maxCharFreq[i] > tempCharFreq[i]) {
                    isUniversal = false;
                    break;
                }
            }
            if (isUniversal) {
                universalWords.emplace_back(word);
            }
        }
        
        return universalWords;
      }
    };

Runtime: 18 ms, beating 78.34% of leetcode users solutions using C++.
Memory: 61.84 mb, beating 84.33% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, if statements, memset, and frequencies.

### Solution Jan 11, 2025 (C++, leetcode) 1400. Construct K Palindrome Strings (Medium)
In .LeetcodeDailySolution folder as Jan11,2025.cpp

#### Prompt:

Given a string s and an integer k, return true if you can use all the characters in s to construct k palindrome strings or false otherwise.

#### Solution:

    class Solution {
    public:
    bool canConstruct(string s, int k) {

        if (s.length() < k)
            return false;

        sort(s.begin(), s.end());
        int oddCount = 0;

        for (int i = 0; i < s.length();) {

            char current = s[i];
            int count = 0;

            while (i < s.length() && s[i] == current) {
                count++;
                i++;
            }
            if (count % 2 != 0)
                oddCount++;
        }

        return oddCount <= k;
      }
    };

Runtime: 32 ms, beating 5.54% of leetcode users solutions using C++.
Memory: 14.85 mb, beating 67.38% of leetcode users solutions using C++.

#### Concepts Applied:

Palindromes, if statements, for loop, and while loop.

### Solution Jan 12, 2025 (C++, leetcode) 2116. Check if a Parentheses String Can Be Valid (Medium)
In .LeetcodeDailySolution folder as Jan12,2025.cpp

#### Prompt:

A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true:

It is ().
It can be written as AB (A concatenated with B), where A and B are valid parentheses strings.
It can be written as (A), where A is a valid parentheses string.
You are given a parentheses string s and a string locked, both of length n. locked is a binary string consisting only of '0's and '1's. For each index i of locked,

If locked[i] is '1', you cannot change s[i].
But if locked[i] is '0', you can change s[i] to either '(' or ')'.
Return true if you can make s a valid parentheses string. Otherwise, return false.

#### Solution:

    class Solution {
    public:
    bool canBeValid(string str, string lockStatus) {

        if (str.size() % 2 != 0)
            return false;

        int openCount = 0;

        for (int i = 0; i < str.size(); ++i) {
            if (lockStatus[i] == '0' || str[i] == '(')
                openCount++;
            else
                openCount--;
            if (openCount < 0)
                return false;
        }
        openCount = 0;

        for (int i = str.size() - 1; i >= 0; --i) {
            if (lockStatus[i] == '0' || str[i] == ')')
                openCount++;
            else
                openCount--;
            if (openCount < 0)
                return false;
        }

        return true;
      }
    };

Runtime: 7 ms, beating 95.48% of leetcode users solutions using C++.
Memory: 30.26 mb, beating 34.17% of leetcode users solutions using C++.

#### Concepts Applied:

If statements, for loops, else statements, and strings.

### Solution Jan 13, 2025 (C++, leetcode) 3223. Minimum Length of String After Operations (Medium)
In .LeetcodeDailySolution folder as Jan13,2025.cpp

#### Prompt:

You are given a string s.

You can perform the following process on s any number of times:

Choose an index i in the string such that there is at least one character to the left of index i that is equal to s[i], and at least one character to the right that is also equal to s[i].
Delete the closest character to the left of index i that is equal to s[i].
Delete the closest character to the right of index i that is equal to s[i].
Return the minimum length of the final string s that you can achieve.

#### Solution:

    class Solution {
    public:
    int minimumLength(string s) {

        vector<int> charFrequency(26, 0);
        int totalLength = 0;

        for (char currentChar : s) {
            charFrequency[currentChar - 'a']++;
        }
        for (int frequency : charFrequency) {

            if (frequency == 0)
                continue;

            if (frequency % 2 == 0) {
                totalLength += 2;

            } else {
                totalLength += 1;
            }
        }

        return totalLength;
      }
    };

Runtime: 4 ms, beating 98.08% of leetcode users solutions using C++.
Memory: 31.98 mb, beating 87.31% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, arrays, for loops, if statements, and else statement.

### Solution Jan 14, 2025 (C++, leetcode) 2657. Find the Prefix Common Array of Two Arrays (Medium)
In .LeetcodeDailySolution folder as Jan14,2025.cpp

#### Prompt:

You are given two 0-indexed integer permutations A and B of length n.

A prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.

Return the prefix common array of A and B.

A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.

#### Solution:

    class Solution {
    public:
    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {

        int n = A.size();
        vector<int> freq(n + 1, 0);
        vector<int> ans;
        int common = 0;

        for (int i = 0; i < n; i++) {
            if (++freq[A[i]] == 2)
                common++;
            if (++freq[B[i]] == 2)
                common++;
            ans.push_back(common);
        }

        return ans;
      }
    };

Runtime: 1 ms, beating 81.33% of leetcode users solutions using C++.
Memory: 86.36 mb, beating 65.88% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, and if statements.

### Solution Jan 15, 2025 (C++, leetcode) 2429. Minimize XOR (Medium)
In .LeetcodeDailySolution folder as Jan15,2025.cpp

#### Prompt:

Given two positive integers num1 and num2, find the positive integer x such that:

x has the same number of set bits as num2, and
The value x XOR num1 is minimal.
Note that XOR is the bitwise XOR operation.

Return the integer x. The test cases are generated such that x is uniquely determined.

The number of set bits of an integer is the number of 1's in its binary representation.

#### Solution:

    class Solution {
    public:
    int minimizeXor(int num1, int num2) {

        int a = __builtin_popcount(num1);
        int b = __builtin_popcount(num2);
        int res = num1;

        for (int i = 0; i < 32; ++i) {
            if (a > b && (1 << i) & num1) {
                res ^= 1 << i;
                --a;
            }
            if (a < b && !((1 << i) & num1)) {
                res ^= 1 << i;
                ++a;
            }
        }

        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.10 mb, beating 40.55% of leetcode users solutions using C++.

#### Concepts Applied:

XOR, for loop, and if statements.

### Solution Jan 16, 2025 (C++, leetcode) 2425. Bitwise XOR of All Pairings (Medium)
In .LeetcodeDailySolution folder as Jan16,2025.cpp

#### Prompt:

You are given two 0-indexed arrays, nums1 and nums2, consisting of non-negative integers. There exists another array, nums3, which contains the bitwise XOR of all pairings of integers between nums1 and nums2 (every integer in nums1 is paired with every integer in nums2 exactly once).

Return the bitwise XOR of all integers in nums3.

#### Solution:

    class Solution {
    public:
    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {

        int c1 = nums1.size();
        int c2 = nums2.size();
        int x1 = 0, x2 = 0;

        if (c1 % 2 != 0) {
            for (int num : nums2) {
                x2 ^= num;
            }
        }
        if (c2 % 2 != 0) {
            for (int num : nums1) {
                x1 ^= num;
            }
        }

        return x1 ^ x2;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 64.29 mb, beating 64.43% of leetcode users solutions using C++.

#### Concepts Applied:

Bitwise, arrays, if statements, and for loop.

### Solution Jan 17, 2025 (C++, leetcode) 2683. Neighboring Bitwise XOR (Medium)
In .LeetcodeDailySolution folder as Jan17,2025.cpp

#### Prompt:

A 0-indexed array derived with length n is derived by computing the bitwise XOR (⊕) of adjacent values in a binary array original of length n.

Specifically, for each index i in the range [0, n - 1]:

If i = n - 1, then derived[i] = original[i] ⊕ original[0].
Otherwise, derived[i] = original[i] ⊕ original[i + 1].
Given an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.

Return true if such an array exists or false otherwise.

A binary array is an array containing only 0's and 1's

#### Solution:

    class Solution {
    public:
    static bool doesValidArrayExist(vector<int>& derived) {
        return (reduce(derived.begin(), derived.end(), 0) & 1) == 0;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 263.99 mb, beating 50.63% of leetcode users solutions using C++.

#### Concepts Applied:

Bit manipulation.

### Solution Jan 18, 2025 (C++, leetcode) 1368. Minimum Cost to Make at Least One Valid Path in a Grid (Hard)
In .LeetcodeDailySolution folder as Jan18,2025.cpp

#### Prompt:

Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:

1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])
2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])
3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])
4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])
Notice that there could be some signs on the cells of the grid that point outside the grid.

You will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.

You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.

Return the minimum cost to make the grid have at least one valid path.

#### Solution:

    class Solution {
    public:
    int minCost(vector<vector<int>>& grid) {

        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
        deque<pair<int, int>> dq;
        int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};

        dq.push_front({0, 0});
        dist[0][0] = 0;

        while (!dq.empty()) {

            auto [x, y] = dq.front();
            dq.pop_front();
            int curDir = grid[x][y] - 1;

            for (int dir = 0; dir < 4; dir++) {

                int nx = x + dx[dir], ny = y + dy[dir];

                if (nx < 0 || ny < 0 || nx >= m || ny >= n)
                    continue;

                int cost = dist[x][y] + (dir == curDir ? 0 : 1);

                if (cost < dist[nx][ny]) {
                    dist[nx][ny] = cost;

                    if (dir == curDir)
                        dq.push_front({nx, ny});

                    else
                        dq.push_back({nx, ny});
                }
            }
        }

        return dist[m - 1][n - 1];
      }
    };

Runtime: 16 ms, beating 73.56% of leetcode users solutions using C++.
Memory: 26.21 mb, beating 36.15% of leetcode users solutions using C++.
 
#### Concepts Applied:

Grid, arrays, deque, while loop, for loop, if statements, and else statement.

### Solution Jan 20, 2025 (C++, leetcode) 2661. First Completely Painted Row or Column (Medium)
In .LeetcodeDailySolution folder as Jan20,2025.cpp

#### Prompt:

You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n].

Go through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i].

Return the smallest index i at which either a row or a column will be completely painted in mat.

#### Solution:

    class Solution {
    public:
    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {
        
        int rows = mat.size(), cols = mat[0].size();
        unordered_map<int, pair<int, int>> positionMap;
        vector<int> rowCount(rows, cols), colCount(cols, rows);

        for (int r = 0; r < rows; ++r) {
            for (int c = 0; c < cols; ++c) {
                positionMap[mat[r][c]] = {r, c};
            }
        }

        for (int idx = 0; idx < arr.size(); ++idx) {
            int val = arr[idx];
            auto [row, col] = positionMap[val];

            if (--rowCount[row] == 0 || --colCount[col] == 0) {
                return idx;
            }
        }

        return -1;
      }
    };

Runtime: 93 ms, beating 69.28% of leetcode users solutions using C++.
Memory: 171.11 mb, beating 22.89% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, unordered map, matrcies, for loops, and if statement.

### Solution Jan 22, 2025 (C++, leetcode) 1765. Map of Highest Peak (Medium)
In .LeetcodeDailySolution folder as Jan22,2025.cpp

#### Prompt:

You are given an integer matrix isWater of size m x n that represents a map of land and water cells.

If isWater[i][j] == 0, cell (i, j) is a land cell.
If isWater[i][j] == 1, cell (i, j) is a water cell.
You must assign each cell a height in a way that follows these rules:

The height of each cell must be non-negative.
If the cell is a water cell, its height must be 0.
Any two adjacent cells must have an absolute height difference of at most 1. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).
Find an assignment of heights such that the maximum height in the matrix is maximized.

Return an integer matrix height of size m x n where height[i][j] is cell (i, j)'s height. If there are multiple solutions, return any of them.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {

        int R = isWater.size();
        int C = isWater[0].size();
        vector<vector<int>> height(R, vector<int>(C, R + C));

        for (int i = 0; i < R; i++) {

            for (int j = 0; j < C; j++) {

                if (isWater[i][j] == 1) {
                    height[i][j] = 0;

                } else {

                    if (i > 0)
                        height[i][j] = min(height[i][j], height[i - 1][j] + 1);

                    if (j > 0)
                        height[i][j] = min(height[i][j], height[i][j - 1] + 1);
                }
            }
        }
        for (int i = R - 1; i >= 0; i--) {

            for (int j = C - 1; j >= 0; j--) {

                if (i < R - 1)
                    height[i][j] = min(height[i][j], height[i + 1][j] + 1);

                if (j < C - 1)
                    height[i][j] = min(height[i][j], height[i][j + 1] + 1);
            }
        }

        return height;
      }
    };

Runtime: 24 ms, beating 98.56% of leetcode users solutions using C++. 
Memory: 97.75 mb, beating 98.67% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, matrix, for loop, if statements, else statement, and min.

### Solution Jan 24, 2025 (C++, leetcode) 802. Find Eventual Safe States (Medium)
In .LeetcodeDailySolution folder as Jan24,2025.cpp

#### Prompt:

There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].

A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).

Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.

#### Solution:

    class Solution {
    public:
    int n;
    vector<int> degreein;
    vector<vector<int>> rGraph;
    vector<int> ans;

    void init(vector<vector<int>>& G) {

        n = G.size();
        degreein = vector<int>(n, 0);
        rGraph.resize(n, vector<int>(0));

        for (int u = 0; u < n; u++) {
            for (int v : G[u]) {
                rGraph[v].push_back(u);
                degreein[u]++;
            }
        }
    }
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {

        init(graph);
        queue<int> que;

        for (int i = 0; i < n; i++) {
            
            if (degreein[i] == 0)
                que.push(i);
        }
        while (que.size()) {

            int u = que.front();
            que.pop();
            ans.push_back(u);

            for (int v : rGraph[u]) {
                degreein[v]--;

                if (degreein[v] == 0)
                    que.push(v);
            }
        }
        sort(ans.begin(), ans.end());

        return ans;
      }
    };

Runtime: 56 ms, beating 26.13% of leetcode users solutions using C++.
Memory: 66.64 mb, beating 11.93% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, graph, queue, for loops, while loop, if statements, and sorting.

### Solution Jan 25, 2025 (C++, leetcode) 2948. Make Lexicographically Smallest Array by Swapping Elements (Medium)
In .LeetcodeDailySolution folder as Jan25,2025.cpp

#### Prompt:

You are given a 0-indexed array of positive integers nums and a positive integer limit.

In one operation, you can choose any two indices i and j and swap nums[i] and nums[j] if |nums[i] - nums[j]| <= limit.

Return the lexicographically smallest array that can be obtained by performing the operation any number of times.

An array a is lexicographically smaller than an array b if in the first position where a and b differ, array a has an element that is less than the corresponding element in b. For example, the array [2,10,3] is lexicographically smaller than the array [10,2,3] because they differ at index 0 and 2 < 10.

#### Solution:

    class Solution {
    public:
    static vector<int> lexicographicallySmallestArray(vector<int>& nums, int limit) {

        const int n = nums.size();
        vector<int> idx(n, 0);
        iota(idx.begin(), idx.end(), 0);  
        stable_sort(idx.begin(), idx.end(), [&](int i, int j) {

            return nums[i] < nums[j];
        });
        vector<vector<int>> group = {{idx[0]}};
        int prev = nums[idx[0]];

        for (int i = 1; i < n; i++) {

            int I = idx[i], x = nums[I];

            if (x - prev <= limit) 
                group.back().push_back(I);

             else 
                group.push_back({I});

            prev = x;
        }
        for (auto& seq : group) {

            vector<int> values;

            for (int index : seq) 
                values.push_back(nums[index]);

            sort(seq.begin(), seq.end());  
            
            for (int i = 0; i < seq.size(); i++) {
                nums[seq[i]] = values[i];
            }
        }

        return nums;
      }
    };

Runtime: 188 ms, beating 63.51% of leetcode users solutions using C++.
Memory: 169.27 mb, beating 65.54% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, for loops, if statement, and else statement.

### Solution Jan 27, 2025 (C++, leetcode) 1462. Course Schedule IV (Medium)
In .LeetcodeDailySolution folder as Jan27,2025.cpp

#### Prompt:

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course ai first if you want to take course bi.

For example, the pair [0, 1] indicates that you have to take course 0 before you can take course 1.
Prerequisites can also be indirect. If course a is a prerequisite of course b, and course b is a prerequisite of course c, then course a is a prerequisite of course c.

You are also given an array queries where queries[j] = [uj, vj]. For the jth query, you should answer whether course uj is a prerequisite of course vj or not.

Return a boolean array answer, where answer[j] is the answer to the jth query.

#### Solution:

    class Solution {
    public:
    vector<bool> checkIfPrerequisite(int numCourses,
                                     vector<vector<int>>& prerequisites,
                                     vector<vector<int>>& queries) {

        unordered_map<int, unordered_set<int>> reachable;

        for (auto& prereq : prerequisites) {
            reachable[prereq[1]].insert(prereq[0]);
        }

        for (int i = 0; i < numCourses; ++i) {
            for (int j = 0; j < numCourses; ++j) {
                if (reachable[j].count(i)) {
                    reachable[j].insert(reachable[i].begin(),
                                        reachable[i].end());
                }
            }
        }
        vector<bool> result;

        for (auto& query : queries) {
            result.push_back(reachable[query[1]].count(query[0]) > 0);
        }

        return result;
      }
    };

Runtime: 48 ms, beating 62.20% of leetcode users solutions using C++.
Memory: 71.10 mb, beating 56.03% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, unordered map and set, for loops, and if statement.

### Solution Jan 28, 2025 (C++, leetcode) 2658. Maximum Number of Fish in a Grid (Medium)
In .LeetcodeDailySolution folder as Jan28,2025.cpp

#### Prompt:

You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:

A land cell if grid[r][c] = 0, or
A water cell containing grid[r][c] fish, if grid[r][c] > 0.
A fisher can start at any water cell (r, c) and can do the following operations any number of times:

Catch all the fish at cell (r, c), or
Move to any adjacent water cell.
Return the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.

An adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.

#### Solution:

    class Solution {
    public:
    int m, n, dir[5] = {-1, 0, 1, 0, -1};

    int dfs(vector<vector<int>>& grid, int i, int j) {

        if (i < 0 || i >= m || j < 0 || j >= n || !grid[i][j])
            return 0;

        int sum = grid[i][j];
        grid[i][j] = 0;

        for (int k = 0; k < 4; k++)
            sum += dfs(grid, i + dir[k], j + dir[k + 1]);

        return sum;
    }

    int findMaxFish(vector<vector<int>>& grid) {

        m = grid.size(), n = grid[0].size();
        int maxFish = 0;

        for (int i = 0; i < m; i++)

            for (int j = 0; j < n; j++)

                if (grid[i][j])

                    maxFish = max(maxFish, dfs(grid, i, j));

        return maxFish;
      }
    };

Runtime: 4 ms, beating 78.58% of leetcode users solutions using C++.
Memory: 93.99 mb, beating 94.30% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, arrays, if statements, for loops, grid, and max.

### Solution Jan 29, 2025 (C++, leetcode) 684. Redundant Connection (Medium)
In .LeetcodeDailySolution folder as Jan29,2025.cpp

#### Prompt:

In this problem, a tree is an undirected graph that is connected and has no cycles.

You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.

Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.

#### Solution:

    class Solution {
    public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {

        unordered_map<int, vector<int>> graph;

        auto isConnected = [&](int u, int v) {

            unordered_set<int> visited;
            stack<int> stack;
            stack.push(u);

            while (!stack.empty()) {
                int node = stack.top();
                stack.pop();

                if (visited.count(node)) continue;
                visited.insert(node);

                if (node == v) return true;

                for (int neighbor : graph[node]) {
                    stack.push(neighbor);
                }
            }

            return false;
        };
        for (const auto& edge : edges) {

            int u = edge[0], v = edge[1];

            if (graph.count(u) && graph.count(v) && isConnected(u, v)) {
                return edge;
            }

            graph[u].push_back(v);
            graph[v].push_back(u);
        }

        return {};
      }
    };

Runtime: 7 ms, beating 18.82% of leetcode users solutions using C++.
Memory: 17.91 mb, beating 9.59% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, unordered maps, graph, stack, while loop, for loops, and if statements.

### Solution Jan 30, 2025 (C++, leetcode) 2493. Divide Nodes Into the Maximum Number of Groups (Hard)
In .LeetcodeDailySolution folder as Jan30,2025.cpp

#### Prompt:

You are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.

You are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected.

Divide the nodes of the graph into m groups (1-indexed) such that:

Each node in the graph belongs to exactly one group.
For every pair of nodes in the graph that are connected by an edge [ai, bi], if ai belongs to the group with index x, and bi belongs to the group with index y, then |y - x| = 1.
Return the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.

#### Solution:

    class Solution {
    public:
    int magnificentSets(int n, vector<vector<int>>& edges) {

        vector<int> g[n];

        for (auto& e : edges) {

            int a = e[0] - 1, b = e[1] - 1;
            g[a].push_back(b);
            g[b].push_back(a);
        }
        vector<int> d(n);

        for (int i = 0; i < n; ++i) {

            queue<int> q{{i}};
            vector<int> dist(n);
            dist[i] = 1;
            int mx = 1;
            int root = i;

            while (q.size()) {

                int a = q.front();
                q.pop();
                root = min(root, a);

                for (int b : g[a]) {

                    if (dist[b] == 0) {

                        dist[b] = dist[a] + 1;
                        mx = max(mx, dist[b]);
                        q.push(b);
                    } else if (abs(dist[b] - dist[a]) != 1) {

                        return -1;
                    }
                }
            }
            d[root] = max(d[root], mx);
        }

        return accumulate(d.begin(), d.end(), 0);
      }
    };

Runtime: 169 ms, beating 38.91% of leetcode users solutions using C++.
Memory: 58.84 mb, beating 25.11% of leetcode users solutions using C++.

#### Concepts Applied:

For loops, while loop, arrays, queue, min, max, absolute value, and if statements.

### Solution Jan 31, 2025 (C++, leetcode) 827. Making A Large Island (Hard)
In .LeetcodeDailySolution folder as Jan31,2025.cpp

#### Prompt:

You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.

Return the size of the largest island in grid after applying this operation.

An island is a 4-directionally connected group of 1s.

#### Solution:

    class Solution {

    int d[5] = {1, 0, -1, 0, 1};
    int n;

    int dfs(int row, int col, int id, vector<vector<int>>& grid) {

        grid[row][col] = id;
        int cnt = 1;

        for (int i = 0; i < 4; i++) {

            int nr = row + d[i];
            int nc = col + d[i + 1];

            if (nr >= 0 && nc >= 0 && nr < n && nc < n && grid[nr][nc] == 1)
                cnt += dfs(nr, nc, id, grid);
        }

        return cnt;
    }

    public:
    int largestIsland(vector<vector<int>>& grid) {

        n = grid.size();
        vector<int> key;
        int id = 2;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1)
                    key.push_back(dfs(i, j, id++, grid));
            }
        }

        if (key.empty())
            return 1;

        int ans = 1;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    int cnt = 1;

                    for (int k = 0; k < 4; k++) {
                        int nr = i + d[k];
                        int nc = j + d[k + 1];

                        if (nr >= 0 && nc >= 0 && nr < n && nc < n &&
                            grid[nr][nc] != 0 && key[grid[nr][nc] - 2] > 0)
                            cnt += key[grid[nr][nc] - 2],
                                key[grid[nr][nc] - 2] *= -1;
                    }
                    for (int k = 0; k < 4; k++) {
                        int nr = i + d[k];
                        int nc = j + d[k + 1];

                        if (nr >= 0 && nc >= 0 && nr < n && nc < n &&
                            grid[nr][nc] != 0 && key[grid[nr][nc] - 2] < 0)
                            key[grid[nr][nc] - 2] *= -1;
                    }

                    ans = max(ans, cnt);
                }
            }
        }

        return ans == 1 ? n * n : ans;
      }
    };

Runtime: 29 ms, beating 99.77% of leetcode users solutions using C++.
Memory: 57.33 mb, beating 99.66% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, grid, arrays, for loops, if statements, and max.

### Solution Feb 1, 2025 (C++, leetcode) 3151. Special Array I (Easy)
In .LeetcodeDailySolution folder as Feb1,2025.cpp

#### Prompt:

An array is considered special if every pair of its adjacent elements contains two numbers with different parity.

You are given an array of integers nums. Return true if nums is a special array, otherwise, return false.

#### Solution:

    class Solution {
    public:
    bool isArraySpecial(vector<int>& nums) {

        for (int i = 0; i < nums.size() - 1; i++) {
            
            if (nums[i] % 2 == nums[i + 1] % 2) {
                return false;
            }
        }

        return true;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 27.62 mb, beating 61.84% of leetcode users solutions using C++.

#### Concepts Applied:

For loop, array, and if statement.

### Solution Feb 2, 2025 (C++, leetcode) 1752. Check if Array Is Sorted and Rotated (Easy)
In .LeetcodeDailySolution folder as Feb2,2025.cpp

#### Prompt:

Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.

There may be duplicates in the original array.

Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation.

#### Solution:

    class Solution {
    public:
    bool check(vector<int>& nums) {

        int count = 0, n = nums.size();

        for (int i = 0; i < n; i++)

            if (nums[i] > nums[(i + 1) % n] && ++count > 1)
                return false;

        return true;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.26 mb, beating 23% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean, array, for loop, and if statement.

### Solution Feb 3, 2025 (C++, leetcode) 3105. Longest Strictly Increasing or Strictly Decreasing Subarray (Easy)
In .LeetcodeDailySolution folder as Feb3,2025.cpp

#### Prompt:

You are given an array of integers nums. Return the length of the longest subarray of nums which is either strictly increasing or strictly decreasing.

#### Solution:

    class Solution {
    public:
    int longestMonotonicSubarray(vector<int>& nums) {

        int n = nums.size(), i = 0, ans = 0;
        int inc = 1, dec = 1;

        if (n == 1)
            return 1;

        for (i = 1; i < n; i++) {

            if (nums[i] > nums[i - 1])
                inc++, dec = 1;

            else if (nums[i] < nums[i - 1])
                inc = 1, dec++;

            else
                inc = dec = 1;

            ans = max({ans, dec, inc});
        }

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 27.91 mb, beating 27.25% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, if statements, for loop, else statements, else-if statement, and max.

### Solution Feb 4, 2025 (C++, leetcode) 1800. Maximum Ascending Subarray Sum (Easy)
In .LeetcodeDailySolution folder as Feb4,2025.cpp

#### Prompt:

Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums.

A subarray is defined as a contiguous sequence of numbers in an array.

A subarray [numsl, numsl+1, ..., numsr-1, numsr] is ascending if for all i where l <= i < r, numsi  < numsi+1. Note that a subarray of size 1 is ascending.

#### Solution:

    class Solution {
    public:
    int maxAscendingSum(vector<int>& nums) {

        int curr = nums[0], ans = nums[0];

        for (int i = 1; i < nums.size(); ++i) {
            curr = nums[i] > nums[i - 1] ? curr + nums[i] : nums[i];
            ans = max(ans, curr);
        }
        
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.07 mb, beating 77.91% of leetcode users solutions using C++.

#### Concepts Applied:

Array, for loop, and max.

### Solution Feb 5, 2025 (C++, leetcode) 1790. Check if One String Swap Can Make Strings Equal (Easy)
In .LeetcodeDailySolution folder as Feb5,2025.cpp

#### Prompt:

You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.

Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.

#### Solution:

    class Solution {
    public:
    bool areAlmostEqual(string s1, string s2) {
        int i = -1, j = -1;
        int cnt = 0;

        for (int k = 0; k < s1.length(); k++) {
            if (s1[k] != s2[k]) {
                cnt++;
                if (i == -1) {
                    i = k;
                } else if (j == -1) {
                    j = k;
                }
            }
        }

        if (cnt == 0) {
            return true;
        } else if (cnt == 2 && s1[i] == s2[j] && s1[j] == s2[i]) {
            return true;
        }

        return false;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.46 mb, beating 36.36% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loop, if statements, and else-if statements.

### Solution Feb 7, 2025 (C++, leetcode) 1726. Tuple with Same Product (Medium)
In .LeetcodeDailySolution folder as Feb7,2025.cpp

#### Prompt:

Given an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.

#### Solution:

    class Solution {
    public:
    int tupleSameProduct(vector<int>& nums) {

        unordered_map<int, int> mp;
        int ans = 0, n = nums.size();

        for (int i = 0; i < n; i++)

            for (int j = i + 1; j < n; j++) {
                int product = nums[i] * nums[j];
                ans += 8 * mp[product];
                mp[product]++;
            }

        return ans;
      }
    };

Runtime: 315 ms, beating 60.99% of leetcode users solutions using C++.
Memory: 85 mb, beating 45.82% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, unorderd map, and for loops.

### Solution Feb 7, 2025 (C++, leetcode) 3160. Find the Number of Distinct Colors Among the Balls (Medium)
In .LeetcodeDailySolution folder as Feb7,2025.cpp

#### Prompt:

You are given an integer limit and a 2D array queries of size n x 2.

There are limit + 1 balls with distinct labels in the range [0, limit]. Initially, all balls are uncolored. For every query in queries that is of the form [x, y], you mark ball x with the color y. After each query, you need to find the number of distinct colors among the balls.

Return an array result of length n, where result[i] denotes the number of distinct colors after ith query.

Note that when answering a query, lack of a color will not be considered as a color.

#### Solution:

    class Solution {
    public:
    vector<int> queryResults(int limit, vector<vector<int>>& queries) {

        unordered_map<int, int> ball, color;
        vector<int> ans;
        ans.reserve(queries.size());
        int distinct = 0;

        for (auto& q : queries) {

            int pos = q[0], c = q[1];

            if (ball.count(pos))

                if (--color[ball[pos]] == 0)
                    distinct--;

            ball[pos] = c;

            if (++color[c] == 1)
                distinct++;

            ans.push_back(distinct);
        }

        return ans;
      }
    };

Runtime: 112 ms, beating 64.89% of leetcode users solutions using C++.
Memory: 155.82 mb, beating 60.81% of leetcode user solutions using C++.

#### Concepts Applied:

Arrays, unordered map, for loop, and if statements.

### Solution Feb 8, 2025 (C++, leetcode) 2349. Design a Number Container System (Medium)
In .LeetcodeDailySolution folder as Feb8,2025.cpp

#### Prompt:

Design a number container system that can do the following:

Insert or Replace a number at the given index in the system.
Return the smallest index for the given number in the system.
Implement the NumberContainers class:

NumberContainers() Initializes the number container system.
void change(int index, int number) Fills the container at index with the number. If there is already a number at that index, replace it.
int find(int number) Returns the smallest index for the given number, or -1 if there is no index that is filled by number in the system.

#### Solution:

    class NumberContainers {
    public:

    unordered_map<int, priority_queue<int, vector<int>, greater<int>>> res;
    unordered_map<int, int> index_val;

    void change(int index, int number) {

        if (index_val.count(index)) {
            int prevNum = index_val[index];

            if (prevNum == number)
                return;

            res[prevNum].push(INT_MAX);
        }
        res[number].push(index);
        index_val[index] = number;
    }
    int find(int number) {

        while (!res[number].empty() && index_val[res[number].top()] != number) {
            res[number].pop();
        }

        return res[number].empty() ? -1 : res[number].top();
      }
    };

Runtime: 109 ms, beating 69.55% of leetcode users solutions using C++.
Memory: 185.75 mb, beating 89.85% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered map, priority queue, if statements, and while loop.

### Solution Feb 9, 2025 (C++, leetcode) 2364. Count Number of Bad Pairs (Medium)
In .LeetcodeDailySolution folder as Feb9,2025.cpp

#### Prompt:

You are given a 0-indexed integer array nums. A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].

Return the total number of bad pairs in nums.

#### Solution:

    class Solution {
    public:
    long long countBadPairs(vector<int>& nums) {

        int n = nums.size();
        long long totalPairs = (long long)n * (n - 1) / 2;

        unordered_map<int, long long> diffCount;

        for (int i = 0; i < n; i++) {

            int diff = nums[i] - i;
            totalPairs -= diffCount[diff];
            diffCount[diff]++;
        }

        return totalPairs;
      }
    };

Runtime: 69 ms, beating 56.15% of leetcode users solutions using C++.
Memory: 92.60 mb, beating 19.82% of leetcode users solutions using C++.

#### Concepts Applied:

Array, unordered map, and for loop.

### Solution Feb 10, 2025 (C++, leetcode) 3174. Clear Digits (Easy)
In .LeetcodeDailySolution folder as Feb10,2025.cpp

#### Prompt:

You are given a string s.

Your task is to remove all digits by doing this operation repeatedly:

Delete the first digit and the closest non-digit character to its left.
Return the resulting string after removing all digits.

#### Solution:

    class Solution {
    public:
    string clearDigits(string s) {

        string stack;

        for (char c : s) {

            if (isdigit(c)) {

                if (!stack.empty())
                    stack.pop_back();
                    
            } else {
                stack.push_back(c);
            }
        }

        return stack;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.39 mb, beating 87.07% of leetcode users solutions using C++.

#### Concepts Applied:

Stack, strings, for loop, and if statements.

### Solution Feb 11, 2025 (C++, leetcode) 1910. Remove All Occurrences of a Substring (Medium)
In .LeetcodeDailySolution folder as Feb11,2025.cpp

#### Prompt:

Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed:

Find the leftmost occurrence of the substring part and remove it from s.
Return s after removing all occurrences of part.

A substring is a contiguous sequence of characters in a string.

#### Solution:

    class Solution {
    public:
    string removeOccurrences(string s, string part) {

        string resultStack;
        int targetLength = part.size();
        char targetEndChar = part.back();

        for (char currentChar : s) {

            resultStack.push_back(currentChar);

            if (currentChar == targetEndChar &&

                resultStack.size() >= targetLength) {

                if (resultStack.substr(resultStack.size() - targetLength) ==
                    part) {
                    resultStack.erase(resultStack.size() - targetLength);
                }
            }
        }

        return resultStack;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.80 mb, beating 12.46% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loop, and if statements.

### Solution Feb 12, 2025 (C++, leetcode) 2342. Max Sum of a Pair With Equal Sum of Digits (Medium)
In .LeetcodeDailySolution folder as Feb12,2025.cpp

#### Prompt:

You are given a 0-indexed array nums consisting of positive integers. You can choose two indices i and j, such that i != j, and the sum of digits of the number nums[i] is equal to that of nums[j].

Return the maximum value of nums[i] + nums[j] that you can obtain over all possible indices i and j that satisfy the conditions.

#### Solution:

    class Solution {
    public:
    int maximumSum(vector<int>& nums) {

        unordered_map<int, priority_queue<int>> mp;

        for (int i : nums) {

            int sum = 0, n = i;

            while (n) {

                sum += n % 10;
                n /= 10;
            }

            mp[sum].push(i);
        }
        int ans = -1;

        for (auto& i : mp) {

            if (i.second.size() > 1) {

                int sum = i.second.top();
                i.second.pop();
                sum += i.second.top();
                ans = max(ans, sum);
            }
        }

        return ans;
      }
    };

Runtime: 23 ms, beating 66.41% of leetcode users solutions using C++.
Memory: 71.62 mb, beating 36.47% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered map, priority queue, array, for loops, while loop, if statement, and max.

### Solution Feb 13, 2025 (C++, leetcode) 3066. Minimum Operations to Exceed Threshold Value II (Medium)
In .LeetcodeDailySolution folder as Feb13,2025.cpp

#### Prompt:

You are given a 0-indexed integer array nums, and an integer k.

You are allowed to perform some operations on nums, where in a single operation, you can:

Select the two smallest integers x and y from nums.
Remove x and y from nums.
Insert (min(x, y) * 2 + max(x, y)) at any position in the array.
Note that you can only apply the described operation if nums contains at least two elements.

Return the minimum number of operations needed so that all elements of the array are greater than or equal to k.

#### Solution:

    class Solution {
    public:
    int minOperations(vector<int>& a, int k) {

        sort(a.begin(), a.end());
        vector<int> b;

        for (int i = 0, j = 0, count = 0, x, y;; ++count) {

            if (i < a.size() && (j >= b.size() || a[i] <= b[j]))
                x = a[i++];

            else
                x = b[j++];

            if (x >= k)
                return count;

            if (i < a.size() && (j >= b.size() || a[i] <= b[j]))
                y = a[i++];

            else
                y = b[j++];

            long t = 2L * x + y;
            b.push_back(t < k ? (int)t : k);
        }

        return -1;
      }
    };

Runtime: 31 ms, beating 100% of leetcode users solutions using C++.
Memory: 89.37 mb, beating 96.28% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, arrays, for loop, if statements, and else statement.

### Solution Feb 14, 2025 (C++, leetcode) 1352. Product of the Last K Numbers (Medium)
In .LeetcodeDailySolution folder as Feb14,2025.cpp

#### Prompt:

Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream.

Implement the ProductOfNumbers class:

ProductOfNumbers() Initializes the object with an empty stream.
void add(int num) Appends the integer num to the stream.
int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers.
The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.

#### Solution:

    class ProductOfNumbers {
    public:

    int product[40000];
    int n = 1;

    ProductOfNumbers() { product[0] = 1; }

    void add(int num) {

        if (num == 0) {
            n = 1;

        } else {
            product[n] = product[n - 1] * num;
            n++;
        }
    }
    int getProduct(int k) {

        if (n <= k)
            return 0;

        return product[n - 1] / product[n - k - 1];
      }
    };

Runtime: 8 ms, beating 97.88% of leetcode users solutions using C++.
Memory: 78.61 mb, beating 11.51% of leetcode users solutions using C++.

#### Concepts Applied:

Product, if statements, and else statement.

### Solution Feb 15, 2025 (C++, leetcode) 2698. Find the Punishment Number of an Integer (Medium)
In .LeetcodeDailySolution folder as Feb15,2025.cpp

#### Prompt:

Given a positive integer n, return the punishment number of n.

The punishment number of n is defined as the sum of the squares of all integers i such that:

1 <= i <= n
The decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.

#### Solution:

    class Solution {
    public:
    int punishmentNumber(int n) {

        vector<int> arr = {1,   9,   10,  36,  45,  55,  82,  91,  99,  100,
                           235, 297, 369, 370, 379, 414, 657, 675, 703, 756,
                           792, 909, 918, 945, 964, 990, 991, 999, 1000};
        int sum = 0;

        for (int i = 0; i < arr.size(); i++) {

            if (arr[i] <= n)
                sum += arr[i] * arr[i];

            else
                break;
        }

        return sum;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.17 mb, beating 67.92% of leetcode users solutions using C++.

#### Concepts Applied:

Array, for loop, and if statement.

### Solution Feb 16, 2025 (C++, leetcode) 1718. Construct the Lexicographically Largest Valid Sequence (Medium)
In .LeetcodeDailySolution folder as Feb16,2025.cpp

#### Prompt:

Given an integer n, find a sequence with elements in the range [1, n] that satisfies all of the following:

The integer 1 occurs once in the sequence.
Each integer between 2 and n occurs twice in the sequence.
For every integer i between 2 and n, the distance between the two occurrences of i is exactly i.
The distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|.

Return the lexicographically largest sequence. It is guaranteed that under the given constraints, there is always a solution.

A sequence a is lexicographically larger than a sequence b (of the same length) if in the first position where a and b differ, sequence a has a number greater than the corresponding number in b. For example, [0,1,9,0] is lexicographically larger than [0,1,5,6] because the first position they differ is at the third number, and 9 is greater than 5.

#### Solution:

    class Solution {
    public:
    int n, az;
    bitset<21> viz = 0;
    vector<int> ans;

    bool dfs(int pos) {

        if (pos == az)
            return viz.count() == n;

        if (ans[pos] != 0)
            return dfs(pos + 1);

        for (int j = n; j >= 1; j--) {

            if (viz[j])
                continue;
                
            int next_pos = (j > 1) ? pos + j : pos;

            if (next_pos >= az || ans[next_pos] != 0)
                continue;

            ans[pos] = ans[next_pos] = j;
            viz[j] = 1;

            if (dfs(pos + 1))
                return 1;

            ans[pos] = ans[next_pos] = viz[j] = 0;
        }

        return 0;
    }
    vector<int> constructDistancedSequence(int n) {

        this->n = n;
        az = 2 * n - 1;
        ans.assign(az, 0);
        dfs(0);

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.64 mb, beating 26% of leetcode users solutions using C++.

#### Concepts Applied:

Bitset, arrays, if statements, for loop, and depth-first search.

### Solution Feb 17, 2025 (C++, leetcode) 1079. Letter Tile Possibilities (Medium)
In .LeetcodeDailySolution folder as Feb17,2025.cpp

#### Prompt:

You have n  tiles, where each tile has one letter tiles[i] printed on it.

Return the number of possible non-empty sequences of letters you can make using the letters printed on those tiles.

#### Solution:

    class Solution {
    public:
    int Perm(int n, vector<int>& freq, int fz) {

        if (n == 1)
            return fz - count(freq.begin(), freq.end(), 0);

        int ans = 0;

        for (int i = 0; i < fz; i++) {

            if (freq[i] > 0) {
                freq[i]--;
                ans += Perm(n - 1, freq, fz);
                freq[i]++;
            }
        }

        return ans;
    }
    int numTilePossibilities(string& tiles) {
        int sz = 0, tz = tiles.size();
        vector<int> freq(26, 0);

        for (char c : tiles)

            if (++freq[c - 'A'] == 1)
                sz++;

        sort(freq.begin(), freq.end(), greater<int>());
        freq.resize(sz);

        int cnt = 0;

        for (int len = 1; len <= tz; len++)
            cnt += Perm(len, freq, sz);

        return cnt;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.88 mb, beating 87.48% of leetcode users solutions using C++.

#### Concepts Applied:

If statements, counting, for loops, sorting, and arrays.

### Solution Feb 18, 2025 (C++, leetcode) 2375. Construct Smallest Number From DI String (Medium)
In .LeetcodeDailySolution folder as Feb18,2025.cpp

#### Prompt:

You are given a 0-indexed string pattern of length n consisting of the characters 'I' meaning increasing and 'D' meaning decreasing.

A 0-indexed string num of length n + 1 is created using the following conditions:

num consists of the digits '1' to '9', where each digit is used at most once.
If pattern[i] == 'I', then num[i] < num[i + 1].
If pattern[i] == 'D', then num[i] > num[i + 1].
Return the lexicographically smallest possible string num that meets the conditions.

#### Solution:

    class Solution {
    public:
    string smallestNumber(string pattern) {

        int n = pattern.length();
        string result = "";
        int stack[n + 1];
        int index = 0;

        for (int i = 0; i <= n; i++) {

            stack[index++] = i + 1;

            if (i == n || pattern[i] == 'I') {

                while (index > 0) {
                    result += to_string(stack[--index]);
                }
            }
        }

        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.12 mb, beating 44.86% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loop, if statement, and while loop.

### Solution Feb 19, 2025 (C++, leetcode) 1415. The k-th Lexicographical String of All Happy Strings of Length n (Medium)
In .LeetcodeDailySolution folder as Feb19,2025.cpp

#### Prompt:

A happy string is a string that:

consists only of letters of the set ['a', 'b', 'c'].
s[i] != s[i + 1] for all values of i from 1 to s.length - 1 (string is 1-indexed).
For example, strings "abc", "ac", "b" and "abcbabcbcb" are all happy strings and strings "aa", "baa" and "ababbc" are not happy strings.

Given two integers n and k, consider a list of all happy strings of length n sorted in lexicographical order.

Return the kth string of this list or return an empty string if there are less than k happy strings of length n.

#### Solution:

    class Solution {

    int n2;

    string dfs(string prefix, int n, int k) {

        if (n == 0)
            return prefix;

        for (char c = 'a'; c <= 'c'; c++) {

            if (!prefix.empty() && c == prefix.back())
                continue;

            int cnt = (1 << (n2 - prefix.length() - 1));

            if (cnt >= k)
                return dfs(prefix + c, n - 1, k);

            else
                k -= cnt;
        }

        return "";
    }

    public:
    string getHappyString(int n, int k) {

        n2 = n;

        return dfs("", n, k);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.30 mb, beating 69.41% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, if statements, for loop, and depth-first search.

### Solution Feb 20, 2025 (C++, leetcode) 1980. Find Unique Binary String (Medium)
In .LeetcodeDailySolution folder as Feb20,2025.cpp

#### Prompt:

Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.

#### Solution:

    class Solution {
    public:
    string findDifferentBinaryString(vector<string>& nums) {
        
        string result;

        for (int i = 0; i < nums.size(); ++i) {
            result += (nums[i][i] == '0' ? '1' : '0');
        }

        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.68 mb, beating 66.89% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, and for loop. 

### Solution Feb 21, 2025 (C++, leetcode) 1261. Find Elements in a Contaminated Binary Tree (Medium)
In .LeetcodeDailySolution folder as Feb21,2025.cpp

#### Prompt:

Given a binary tree with the following rules:

root.val == 0
For any treeNode:
If treeNode.val has a value x and treeNode.left != null, then treeNode.left.val == 2 * x + 1
If treeNode.val has a value x and treeNode.right != null, then treeNode.right.val == 2 * x + 2
Now the binary tree is contaminated, which means all treeNode.val have been changed to -1.

Implement the FindElements class:

FindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.
bool find(int target) Returns true if the target value exists in the recovered binary tree.

#### Solution:

    class FindElements {
    public:
    unordered_map<int, bool> mp;

    void recover(TreeNode* root) {

        if (!root)
            return;

        if (root->left) {
            root->left->val = root->val * 2 + 1;
            mp[root->left->val] = true;
            recover(root->left);
        }
        if (root->right) {
            root->right->val = root->val * 2 + 2;
            mp[root->right->val] = true;
            recover(root->right);
        }
    }
    FindElements(TreeNode* root) {

        root->val = 0;
        mp[0] = true;
        recover(root);
    }
    bool find(int target) { 
        
      return mp.find(target) != mp.end(); }
    };

Runtime: 1 ms, beating 96.58% of leetcode users solutions using C++.
Memory: 27.36 mb, beating 77.76% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered map, if statements, and binary tree.

### Solution Feb 22, 2025 (C++, leetcode) 1028. Recover a Tree From Preorder Traversal (Hard)
In .LeetcodeDailySolution folder as Feb22,2025.cpp

#### Prompt:

We run a preorder depth-first search (DFS) on the root of a binary tree.

At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node.  If the depth of a node is D, the depth of its immediate child is D + 1.  The depth of the root node is 0.

If a node has only one child, that child is guaranteed to be the left child.

Given the output traversal of this traversal, recover the tree and return its root.

#### Solution:

    class Solution {
    public:
    int i = 0;

    TreeNode* recoverFromPreorder(string& T, int depth = 0) {

        if (i >= T.size())
            return NULL;

        int D = 0;

        while (T[i] == '-')
            D++, i++;

        if (D < depth) {
            i -= D;

            return NULL;
        }
        int x = 0;

        while (isdigit(T[i])) {
            x = x * 10 + T[i] - '0';
            i++;
        }
        TreeNode* node = new TreeNode(x);

        node->left = recoverFromPreorder(T, depth + 1);
        node->right = recoverFromPreorder(T, depth + 1);

        return node;
      }
    };

Runtime: 3 ms, beating 57.11% of leetcode users solutions using C++.
Memory: 21.44 mb, beating 49.60% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, tree, if statements, while loops, and depth-first search.

### Solution Feb 23, 2025 (C++, leetcode) 889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)
In .LeetcodeDailySolution folder as Feb23,2025.cpp

#### Prompt:

Given two integer arrays, preorder and postorder where preorder is the preorder traversal of a binary tree of distinct values and postorder is the postorder traversal of the same tree, reconstruct and return the binary tree.

If there exist multiple answers, you can return any of them.

#### Solution:

    class Solution {
    public:
    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post) {

        int index = 0;

        return construct(pre, post, index, 0, pre.size() - 1);
    }

    private:
    TreeNode* construct(vector<int>& pre, vector<int>& post, int& index, int l,
                        int h) {

        if (index >= pre.size() || l > h)
            return nullptr;

        TreeNode* root = new TreeNode(pre[index++]);

        if (l == h)
            return root;

        int i = l;

        while (i <= h && post[i] != pre[index])
            i++;

        if (i <= h) {
            root->left = construct(pre, post, index, l, i);
            root->right = construct(pre, post, index, i + 1, h - 1);
        }

        return root;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 28.15 mb, beating 68.76% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, arrays, if statements, and while loop.

### Solution Feb 24, 2025 (C++, leetcode) 2467. Most Profitable Path in a Tree (Medium)
In .LeetcodeDailySolution folder as Feb24,2025.cpp

#### Prompt:

There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:

the price needed to open the gate at node i, if amount[i] is negative, or,
the cash reward obtained on opening the gate at node i, otherwise.
The game goes on as follows:

Initially, Alice is at node 0 and Bob is at node bob.
At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.
For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:
If the gate is already open, no price will be required, nor will there be any cash reward.
If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is c, then both Alice and Bob pay c / 2 each. Similarly, if the reward at the gate is c, both of them receive c / 2 each.
If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node 0, he stops moving. Note that these events are independent of each other.
Return the maximum net income Alice can have if she travels towards the optimal leaf node.

#### Solution:

    class Solution {
    public:
    int mostProfitablePath(vector<vector<int>>& edges, int bob,
                           vector<int>& amount) {

        int n = amount.size();
        vector<vector<int>> graph(n);

        for (auto& edge : edges) {

            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }

        vector<int> bobPath(n, -1);
        vector<int> path;

        function<bool(int, int)> fillBobPath = [&](int node, int parent) {

            if (node == 0)
                return true;

            for (int neighbor : graph[node]) {

                if (neighbor != parent) {
                    path.push_back(node);

                    if (fillBobPath(neighbor, node))
                        return true;

                    path.pop_back();
                }
            }
            return false;
        };
        fillBobPath(bob, -1);

        for (int i = 0; i < path.size(); i++) {
            bobPath[path[i]] = i;
        }

        function<int(int, int, int, int)> getAliceMaxScore =
            [&](int node, int parent, int currScore, int timestamp) {

                if (bobPath[node] == -1 || bobPath[node] > timestamp) {
                    currScore += amount[node];

                } else if (bobPath[node] == timestamp) {
                    currScore += amount[node] / 2;
                }

                if (graph[node].size() == 1 && node != 0)
                    return currScore;

                int maxScore = INT_MIN;

                for (int neighbor : graph[node]) {

                    if (neighbor != parent) {
                        maxScore =
                            max(maxScore,
                                getAliceMaxScore(neighbor, node, currScore,
                                                 timestamp + 1));
                    }
                }
                
                return maxScore;
            };

        return getAliceMaxScore(0, -1, 0, 0);
      }
    };

Runtime: 544 ms, beating 11.06% of leetcode users solutions using C++.
Memory: 160.05 mb, beating 54.03% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, tree, max, for loops, if statements, and else-if statement.

### Solution Feb 25, 2025 (C++, leetcode) 1524. Number of Sub-arrays With Odd Sum (Medium)
In .LeetcodeDailySolution folder as Feb25,2025.cpp

#### Prompt:

Given an array of integers arr, return the number of subarrays with an odd sum.

Since the answer can be very large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    int numOfSubarrays(vector<int>& arr) {

        long long oddCount = 0, prefixSum = 0;

        for (int a : arr) {
            prefixSum += a;
            oddCount += prefixSum % 2;
        }
        oddCount += (arr.size() - oddCount) * oddCount;

        return oddCount % 1'000'000'007;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 112.02 mb, beating 51.51% of leetcode users solutions using C++.

#### Concepts Applied:

Array, for loop, and prefix sum.

### Solution Feb 26, 2025 (C++, leetcode) 1749. Maximum Absolute Sum of Any Subarray (Medium)
In .LeetcodeDailySolution folder as Feb26,2025.cpp

#### Prompt:

You are given an integer array nums. The absolute sum of a subarray [numsl, numsl+1, ..., numsr-1, numsr] is abs(numsl + numsl+1 + ... + numsr-1 + numsr).

Return the maximum absolute sum of any (possibly empty) subarray of nums.

Note that abs(x) is defined as follows:

If x is a negative integer, then abs(x) = -x.
If x is a non-negative integer, then abs(x) = x.

#### Solution:

    class Solution {
    public:
    int maxAbsoluteSum(vector<int>& nums) {

        int sum = 0, minSum = 0, maxSum = 0;

        for (int num : nums) {
            sum += num;

            if (sum > maxSum)
                maxSum = sum;
                
            if (sum < minSum)
                minSum = sum;
        }

        return abs(maxSum - minSum);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 45.16 mb, beating 50.37% of leetcode users solutions using C++.

#### Concepts Applied:

Array, for loop, if statements, min, max, and absolute value.

### Solution Feb 27, 2025 (C++, leetcode) 873. Length of Longest Fibonacci Subsequence (Medium)
In .LeetcodeDailySolution folder as Feb27,2025.cpp

#### Prompt:

A sequence x1, x2, ..., xn is Fibonacci-like if:

n >= 3
xi + xi+1 == xi+2 for all i + 2 <= n
Given a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.

A subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].

#### Solution:

    class Solution {
    public:
    int lenLongestFibSubseq(vector<int>& arr) {

        int n = arr.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        int maxLen = 0;

        for (int curr = 2; curr < n; curr++) {

            int start = 0, end = curr - 1;

            while (start < end) {

                int pairSum = arr[start] + arr[end];

                if (pairSum > arr[curr]) {
                    end--;

                } else if (pairSum < arr[curr]) {
                    start++;

                } else {

                    dp[end][curr] = dp[start][end] + 1;
                    maxLen = max(dp[end][curr], maxLen);
                    end--;
                    start++;
                }
            }
        }

        return maxLen == 0 ? 0 : maxLen + 2;
      }
    };

Runtime: 109 ms, beating 88.83% of leetcode users solutions using C++.
Memory: 147.78 mb, beating 39.03% of leetcode users solutions using C++.

#### Concepts Applied:

Sequence, arrays, dynamic programming, for loop, while loop, if statement, else-if statement, else statement, and max.

### Solution Feb 28, 2025 (C++, leetcode) 1092. Shortest Common Supersequence (Hard)
In .LeetcodeDailySolution folder as Feb28,2025.cpp

#### Prompt:

Given two strings str1 and str2, return the shortest string that has both str1 and str2 as subsequences. If there are multiple valid strings, return any of them.

A string s is a subsequence of string t if deleting some number of characters from t (possibly 0) results in the string s.

#### Solution:

    class Solution {
    public:
    string shortestCommonSupersequence(string str1, string str2) {

        int m = str1.length();
        int n = str2.length();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (str1[i - 1] == str2[j - 1]) {
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        int i = m, j = n;
        string result = "";
        
        while (i > 0 && j > 0) {
            if (str1[i - 1] == str2[j - 1]) {
                result.push_back(str1[i - 1]);
                i--;
                j--;
            } else if (dp[i - 1][j] > dp[i][j - 1]) {
                result.push_back(str1[i - 1]);
                i--;
            } else {
                result.push_back(str2[j - 1]);
                j--;
            }
        }
        
        while (i > 0) {
            result.push_back(str1[i - 1]);
            i--;
        }
        
        while (j > 0) {
            result.push_back(str2[j - 1]);
            j--;
        }
        
        reverse(result.begin(), result.end());
        
        return result;
      }
    };

Runtime: 26 ms, beating 48.84% of leetcode users solutions using C++.
Memory: 26.94 mb, beating 17.32% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, arrays, dynamic programming, for loops, if statements, while loops, else-if statement, else statement, max, and reverse.

### Solution Mar 1, 2025 (C++, leetcode) 2460. Apply Operations to an Array (Easy)
In .LeetcodeDailySolution folder as Mar1,2025.cpp

#### Prompt:

You are given a 0-indexed array nums of size n consisting of non-negative integers.

You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:

If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.
After performing all the operations, shift all the 0's to the end of the array.

For example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].
Return the resulting array.

Note that the operations are applied sequentially, not all at once.

#### Solution:

    class Solution {
    public:
    vector<int> applyOperations(vector<int>& nums) {
      
        int n = nums.size();

        for (int i = 0; i < n - 1; i++) {

            if (nums[i] == nums[i + 1]) {
                nums[i] *= 2;
                nums[i + 1] = 0;
            }
        }
        int nonZeroIdx = 0;

        for (int i = 0; i < n; i++) {
            
            if (nums[i] != 0) {
                nums[nonZeroIdx++] = nums[i];
            }
        }
        while (nonZeroIdx < n) {
            nums[nonZeroIdx++] = 0;
        }

        return nums;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.19 mb, beating 61.13% of leetcode users solutions using C++.

#### Concepts Applied:

Array, for loops, if statements, and while loop.

### Solution Mar 2, 2025 (C++, leetcode) 2570. Merge Two 2D Arrays by Summing Values (Easy)
In .LeetcodeDailySolution folder as Mar2,2025.cpp

#### Prompt:

You are given two 2D integer arrays nums1 and nums2.

nums1[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.
nums2[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.
Each array contains unique ids and is sorted in ascending order by id.

Merge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:

Only ids that appear in at least one of the two arrays should be included in the resulting array.
Each id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays, then assume its value in that array to be 0.
Return the resulting array. The returned array must be sorted in ascending order by id.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {

        int i = 0, j = 0;
        vector<vector<int>> result;
        
        while (i < nums1.size() && j < nums2.size()) {

            int id1 = nums1[i][0], val1 = nums1[i][1];
            int id2 = nums2[j][0], val2 = nums2[j][1];
            
            if (id1 < id2) {
                result.push_back({id1, val1});
                i++;
            } else if (id2 < id1) {
                result.push_back({id2, val2});
                j++;
            } else {
                result.push_back({id1, val1 + val2});
                i++;
                j++;
            }
        }
        while (i < nums1.size()) {
            result.push_back(nums1[i]);
            i++;
        }        
        while (j < nums2.size()) {
            result.push_back(nums2[j]);
            j++;
        }
        
        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 14.86 mb, beating 42.90% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, while loops, if statement, else-if statement, and else statement.

### Solution Mar 3, 2025 (C++, leetcode) 2161. Partition Array According to Given Pivot (Medium)
In .LeetcodeDailySolution folder as Mar3,2025.cpp

#### Prompt:

You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:

Every element less than pivot appears before every element greater than pivot.
Every element equal to pivot appears in between the elements less than and greater than pivot.
The relative order of the elements less than pivot and the elements greater than pivot is maintained.
More formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. If i < j and both elements are smaller (or larger) than pivot, then pi < pj.
Return nums after the rearrangement.

#### Solution:

    class Solution {
    public:
    vector<int> pivotArray(vector<int>& nums, int pivot) {

        vector<int> result(nums.size(), 0);
        int left = 0, right = nums.size() - 1;

        for (int i = 0, j = nums.size() - 1; i < nums.size(); ++i, --j) {
            
            if (nums[i] < pivot) {
                result[left] = nums[i];
                left++;
            }

            if (nums[j] > pivot) {
                result[right] = nums[j];
                right--;
            }
        }

        while (left <= right) {
            result[left] = pivot;
            left++;
        }

        return result;
      }
    };

Runtime: 5 ms, beating 66.34% of leetcode users solutions using C++.
Memory: 127.61 mb, beating 83.06% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, if statements, and while loop.

### Solution Mar 4, 2025 (C++, leetcode) 1780. Check if Number is a Sum of Powers of Three (Medium)
In .LeetcodeDailySolution folder as Mar4,2025.cpp

#### Prompt:

Given an integer n, return true if it is possible to represent n as the sum of distinct powers of three. Otherwise, return false.

An integer y is a power of three if there exists an integer x such that y == 3x.

#### Solution:

    class Solution {
    public:
    bool checkPowersOfThree(int n) {

        while (n > 0) {

            if (n % 3 == 2) {
                return false;
            }
            n /= 3;
        }

        return true;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.88 mb, beating 44.69% of leetcode users solutions using C++.

#### Concepts Applied:

While loop, if statement, and math.

### Solution Mar 5, 2025 (C++, leetcode) 2579. Count Total Number of Colored Cells (Medium)
In .LeetcodeDailySolution folder as Mar5,2025.cpp

#### Prompt:

There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer n, indicating that you must do the following routine for n minutes:

At the first minute, color any arbitrary unit cell blue.
Every minute thereafter, color blue every uncolored cell that touches a blue cell.
Below is a pictorial representation of the state of the grid after minutes 1, 2, and 3.

Return the number of colored cells at the end of n minutes.

#### Solution:

    class Solution {
    public:
    long long coloredCells(int n) { 
        
        return 1 + 4LL * n * (n - 1) / 2; }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.88 mb, beating 63.52% of leetcode users solutions using C++.

#### Concepts Applied:

Math.

### Solution Mar 6, 2025 (C++, leetcode) 2965. Find Missing and Repeated Values (Easy)
In .LeetcodeDailySolution folder as Mar6,2025.cpp

#### Prompt:

You are given a 0-indexed 2D integer matrix grid of size n * n with values in the range [1, n2]. Each integer appears exactly once except a which appears twice and b which is missing. The task is to find the repeating and missing numbers a and b.

Return a 0-indexed integer array ans of size 2 where ans[0] equals to a and ans[1] equals to b.

#### Solution:

    class Solution {
    public:
    vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {

        int n = grid.size();
        int size = n * n;
        vector<int> count(size + 1, 0);

        for (int i = 0; i < n; i++) {

            for (int j = 0; j < n; j++) {
                count[grid[i][j]]++;
            }
        }

        int a = -1, b = -1;

        for (int num = 1; num <= size; num++) {

            if (count[num] == 2) {
                a = num;

            } else if (count[num] == 0) {
                b = num;
            }
        }

        return {a, b};
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 26.90 mb, beating 48.81% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, if statement, and else-if statement.

### Solution Mar 7, 2025 (C++, leetcode) 2523. Closest Prime Numbers in Range (Medium)
In .LeetcodeDailySolution folder as Mar7,2025.cpp

#### Prompt:

Given two positive integers left and right, find the two integers num1 and num2 such that:

left <= num1 < num2 <= right .
Both num1 and num2 are prime numbers.
num2 - num1 is the minimum amongst all other pairs satisfying the above conditions.
Return the positive integer array ans = [num1, num2]. If there are multiple pairs satisfying these conditions, return the one with the smallest num1 value. If no such numbers exist, return [-1, -1].

#### Solution:

    class Solution {
    public:
    vector<int> closestPrimes(int left, int right) {

        if (left > right)
            return {-1, -1};

        vector<bool> isPrime(right + 1, true);
        isPrime[0] = isPrime[1] = false;

        for (int i = 2; i * i <= right; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= right; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        vector<int> primes;

        for (int i = left; i <= right; i++) {
            if (isPrime[i])
                primes.push_back(i);
        }
        if (primes.size() < 2)
            return {-1, -1};

        int minDiff = INT_MAX, num1 = -1, num2 = -1;

        for (size_t i = 1; i < primes.size(); i++) {

            int diff = primes[i] - primes[i - 1];

            if (diff < minDiff) {
                minDiff = diff;
                num1 = primes[i - 1];
                num2 = primes[i];
            }
        }

        return {num1, num2};
      }
    };

Runtime: 183 ms, beating 68.84% of leetcode users solutions using C++.
Memory: 23.48 mb, beating 24.15% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, primes, if statements, and for loops.

### Solution Mar 8, 2025 (C++, leetcode) 2379. Minimum Recolors to Get K Consecutive Black Blocks (Easy)
In .LeetcodeDailySolution folder as Mar8,2025.cpp

#### Prompt:

You are given a 0-indexed string blocks of length n, where blocks[i] is either 'W' or 'B', representing the color of the ith block. The characters 'W' and 'B' denote the colors white and black, respectively.

You are also given an integer k, which is the desired number of consecutive black blocks.

In one operation, you can recolor a white block such that it becomes a black block.

Return the minimum number of operations needed such that there is at least one occurrence of k consecutive black blocks.

#### Solution:

    class Solution {
    public:
    int minimumRecolors(string blocks, int k) {

        int n = blocks.length();
        int w = 0;

        for (int i = 0; i < k; i++) {

            if (blocks[i] == 'W')
                w++;
        }

        int ans = w;

        for (int i = k; i < n; i++) {

            if (blocks[i] == 'W')
                w++;

            if (blocks[i - k] == 'W')
                w--;

            ans = min(ans, w);
        }

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.41 mb, beating 29.28% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loops, if statements, and min.

### Solution Mar 9, 2025 (C++, leetcode) 3208. Alternating Groups II (Medium)
In .LeetcodeDailySolution folder as Mar9,2025.cpp

#### Prompt:

There is a circle of red and blue tiles. You are given an array of integers colors and an integer k. The color of tile i is represented by colors[i]:

colors[i] == 0 means that tile i is red.
colors[i] == 1 means that tile i is blue.
An alternating group is every k contiguous tiles in the circle with alternating colors (each tile in the group except the first and last one has a different color from its left and right tiles).

Return the number of alternating groups.

Note that since colors represents a circle, the first and the last tiles are considered to be next to each other.

#### Solution:

    class Solution {
    public:
    int numberOfAlternatingGroups(vector<int>& colors, int k) {

        int maxLen = 1, ans = 0, n = colors.size();

        for (int i = 1; i <= n + k - 2; i++) {

            if (colors[i % n] != colors[(i - 1 + n) % n]) {
                maxLen++;

            } else {
                maxLen = 1;
            }
            if (maxLen >= k)
                ans++;
        }

        return ans;
      }
    };

Runtime: 62 ms, beating 85.11% of leetcode users solutions using C++.
Memory: 102.83 mb, beating 47.10% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, if statements, and else statement.

### Solution Mar 10, 2025 (C++, leetcode) 3306. Count of Substrings Containing Every Vowel and K Consonants II (Medium)
In .LeetcodeDailySolution folder as Mar10,2025.cpp

#### Prompt:

You are given a string word and a non-negative integer k.

Return the total number of substrings of word that contain every vowel ('a', 'e', 'i', 'o', and 'u') at least once and exactly k consonants.

#### Solution:

    class Solution {
    public:
    long long countOfSubstrings(string word, int k) {

        vector<int> isVowel(128, 0), freq(128, 0);
        string vowels = "aeiou";

        for (char v : vowels) {
            isVowel[v] = 1;
        }
        long long response = 0;
        int currentK = 0, vowelCount = 0, extraLeft = 0, left = 0;

        for (int right = 0; right < word.size(); right++) {

            char rightChar = word[right];

            if (isVowel[rightChar]) {
                if (++freq[rightChar] == 1) vowelCount++;
            } else {
                currentK++;
            }
            while (currentK > k) {

                char leftChar = word[left];

                if (isVowel[leftChar]) {
                    if (--freq[leftChar] == 0) vowelCount--;
                } else {
                    currentK--;
                }
                left++;
                extraLeft = 0;
            }
            while (vowelCount == 5 && currentK == k && left < right && isVowel[word[left]] && freq[word[left]] > 1) {
                extraLeft++;
                freq[word[left]]--;
                left++;
            }
            if (currentK == k && vowelCount == 5) {
                response += (1 + extraLeft);
            }
        }

        return response;
      }
    };

Runtime: 36 ms, beating 95.12% of leetcode users solutions using C++.
Memory: 31.49 mb, beating 85.10% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, arrays, for loops, while loops, and if statements.

### Solution Mar 11, 2025 (C++, leetcode) 1358. Number of Substrings Containing All Three Characters (Medium)
In .LeetcodeDailySolution folder as Mar11,2025.cpp

#### Prompt:

Given a string s consisting only of characters a, b and c.

Return the number of substrings containing at least one occurrence of all these characters a, b and c.

#### Solution:

    class Solution {
    public:
    int numberOfSubstrings(string s) {

        int count = 0;
        int left = 0;
        unordered_map<char, int> char_count = {{'a', 0}, {'b', 0}, {'c', 0}};

        for (int right = 0; right < s.length(); ++right) {

            char_count[s[right]]++;

            while (char_count['a'] > 0 && char_count['b'] > 0 &&
                   char_count['c'] > 0) {

                count += s.length() - right;
                char_count[s[left]]--;
                left++;
            }
        }

        return count;
      }
    };

Runtime: 10 ms, beating 55.53% of leetcode users solutions using C++.
Memory: 11.11 mb, beating 41.49% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, unordered map, for loop, and while loop.

### Solution Mar 12, 2025 (C++, leetcode) 2529. Maximum Count of Positive Integer and Negative Integer (Easy)
In .LeetcodeDailySolution folder as Mar12,2025.cpp

#### Prompt:

Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.

In other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg.
Note that 0 is neither positive nor negative.

#### Solution:

    class Solution {
    public:
    int maximumCount(std::vector<int>& nums) {

        int n = nums.size();
        int left = 0;
        int right = n - 1;

        while (left <= right) {

            int mid = left + (right - left) / 2;

            if (nums[mid] > 0) {
                right = mid - 1;

            } else {
                left = mid + 1;
            }
        }
        int positiveCount = n - left;
        left = 0;
        right = n - 1;

        while (left <= right) {

            int mid = left + (right - left) / 2;

            if (nums[mid] < 0) {
                left = mid + 1;

            } else {
                right = mid - 1;
            }
        }
        int negativeCount = right + 1;

        return max(positiveCount, negativeCount);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 21.30 mb, beating 95.52% of leetcode users solutions using C++.

#### Concepts Applied:

Array, binary search, while loops, if statements, else statements, and max.
