# Leetcode

Repository of my Leetcode journey, starting September 23, 2023. 

Including my solutions for daily challenges, problems and contests. 

Leetcode is a website for technical interview preparation that offers coding problems, challenges, contests, enhancement of problem-solving skills, algorithms and data structures. 

My profile is linked below:

https://leetcode.com/Sshahryar/

Below will be updates on the Daily Challenge Solutions**. Info on other folders in the repository such as courses, challenges, etc. can be found in the wiki. 

**The daily challenge updates are based on this title format: Solution (date) (language, leetcode) (name of challenge) (difficulty). 

**The daily challenge solutions are designed to work on the leetcode, and may or may not work on ide's outside of 
leetcode, because of test cases and specific parameters. 

## Leetcode Daily Challenge Solutions (From .LeetcodeDailySolution)

### Solution Sept 23, 2023 (Java, leetcode) 1048. LongestStrChain (Medium) 

In .LeetcodeDailySolution folder as Sept23,2023.java

#### Prompt:

You are given an array of words where each word consists of lowercase English letters.

wordA is a predecessor of wordB if and only if we can insert exactly one letter anywhere in wordA without changing the order of the other characters to make it equal to wordB.

For example, "abc" is a predecessor of "abac", while "cba" is not a predecessor of "bcad".
A word chain is a sequence of words [word1, word2, ..., wordk] with k >= 1, where word1 is a predecessor of word2, word2 is a predecessor of word3, and so on. A single word is trivially a word chain with k == 1.

Return the length of the longest possible word chain with words chosen from the given list of words.

#### Solution:

    class Solution {
        public int longestStrChain(String[] words) {
            int ans = 0;
            Arrays.sort(words, (a, b) -> Integer.compare(a.length(), b.length()));
        
        Map<String, Integer> dp = new HashMap<String, Integer>();
        
        for (String w: words) {
            int best = 0;
            for (int i = 0; i < w.length(); i++) {
                String prev = w.substring(0, i) + w.substring(i + 1);
                best = Math.max(best, dp.getOrDefault(prev, 0) + 1);
            }
            dp.put(w, best);
            ans = Math.max(ans, best);
        }
        return ans;
    }
    }

Runtime: 41 ms, beating 31.27% of leetcode users solutions using java.
Memory: 43.9 mb, beating 34.67% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming, arrays, map, and hashmap.
    
### Solution Sept 25, 2023 (Java, leetcode) 389. Find the Difference (Easy)
In .LeetcodeDailySolution folder as Sept25,2023.java

#### Prompt:

You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.

Return the letter that was added to t.

#### Solution:

    class Solution {
        public char findTheDifference(String s, String t) {
            int[] charCount = new int[26];
        
        for (char c : s.toCharArray()) {
            charCount[c - 'a']++;
        }
        
        for (char c : t.toCharArray()) {
            charCount[c - 'a']--;
        }
        
        for (int i = 0; i < 26; i++) {
            if (charCount[i] < 0) {
                return (char) (i + 'a');
            }
        }
        
        return ' ';
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String s = "abcd";
        String t = "abcde";
        char addedLetter = solution.findTheDifference(s, t);
        System.out.println("The added letter is: " + addedLetter);
    }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java.
Memory: 40.9 mb, beating 20.52% of leetcode users solutions using java.

#### Concepts Applied:

Character arrays and for loop. 

### Solution Sept 26, 2023 (Java, leetcode) 316. Remove Duplicate Letters (Medium) 
In .LeetcodeDailySolution folder as Sept26,2023.java

#### Prompt:

Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is 
the smallest in lexicographical order among all possible results.
 
#### Solution:

    import java.util.Stack;

    class Solution {
    public String removeDuplicateLetters(String s) {
        int[] count = new int[26];
        boolean[] used = new boolean[26];
        Stack<Character> stack = new Stack<>();

        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }

        for (char c : s.toCharArray()) {
            count[c - 'a']--;
            if (used[c - 'a']) {
                continue;
            }

            while (!stack.isEmpty() && c < stack.peek() && count[stack.peek() - 'a'] > 0) {
                used[stack.pop() - 'a'] = false;
            }

            stack.push(c);
            used[c - 'a'] = true;
        }

        StringBuilder result = new StringBuilder();
        for (char c : stack) {
            result.append(c);
        }

        return result.toString();
    }
    }
    
Runtime: 2 ms, beating 96.27% of leetcode users solutions using java.
Memory: 41.1 mb, beating 62.98% of leetcode users solutions using java.

#### Concepts Applied:

CharacterArray and stack. 

### Solution Sept 27, 2023 (Java, leetcode) 880. Decoded String at Index (Medium)
In .LeetcodeDailySolution folder as Sept27,2023.java

#### Prompt:

You are given an encoded string s. To decode the string to a tape, the encoded string is read one character at a time and the following steps are taken:

If the character read is a letter, that letter is written onto the tape.
If the character read is a digit d, the entire current tape is repeatedly written d - 1 more times in total.
Given an integer k, return the kth letter (1-indexed) in the decoded string.

#### Solution:

    class Solution {
    public String decodeAtIndex(String encodedString, int k) {
       Stack<Long> characterLengths = new Stack<>();

        characterLengths.push(0L); 

        for (int i = 0; i < encodedString.length(); i++) {
            char c = encodedString.charAt(i);
            if (Character.isDigit(c)) {

                long length = characterLengths.peek() * (c - '0');
                characterLengths.push(length);
            } else {

                long length = characterLengths.peek() + 1;
                characterLengths.push(length);
            }
        }

        int ln = characterLengths.size();
        while (!characterLengths.isEmpty()) {
            k %= characterLengths.peek(); 
            ln--;

            if (k == 0 && Character.isLetter(encodedString.charAt(ln - 1))) {
                return String.valueOf(encodedString.charAt(ln - 1));
            }


            characterLengths.pop();
        }

        return ""; 
    }
    }

Runtime: 1 ms, beating 13.46% of leetcode users solutions using java.
Memory: 40.8 mb, beating 8.48% of leetcode users solutions using java.

#### Concepts Applied:

Strings, stack, character lengths, e.t.c

### Solution Sept 28, 2023 (Java, leetcode) 905. Sort Array by Parity (Easy)
In .LeetcodeDailySolution folder as Sept28,2023.java

#### Prompt:

Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.

Return any array that satisfies this condition.

#### Solution:

    class Solution {
      public int[] sortArrayByParity(int[] nums) {
        int left = 0;
        int right = nums.length - 1;

        while (left < right) {
            if (nums[left] % 2 == 0) {
                left++;  

            } else if (nums[right] % 2 == 1) {
                right--;  

            } else {
                
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++;
                right--;
            }
        }

        return nums;
     }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 44.1 mb, beating 40.77% of leetcode users solutions using java.

#### Concepts Applied:

While loop, if and else-if. 

### Solution Sept 29, 2023 (Java, leetcode) 896. Monotonic Array (Easy)
In .LeetcodeDailySolution folder as Sept29,2023.java

#### Prompt: 

An array is monotonic if it is either monotone increasing or monotone decreasing.

An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].

Given an integer array nums, return true if the given array is monotonic, or false otherwise.

#### Solution:

    class Solution {
       public boolean isMonotonic(int[] nums) {
        boolean increasing = true;
        boolean decreasing = true;

        for (int i = 1; i < nums.length; i++) {
            if (nums[i - 1] > nums[i]) {
                increasing = false; 
            } else if (nums[i - 1] < nums[i]) {
                decreasing = false; 
            }
            
            if (!increasing && !decreasing) {
                return false;
            }
        }

        return true; 
      }
    }

Runtime: 2 ms, beating 58.97% of leetcode users solutions using java.
Memory: 54.4 mb, beating 73.26% of leetcode users solutions using java.

#### Concepts Applied:

Booleans, for loop, if, and else-if. 

### Solution Sept 30, 2023 (Java, leetcode) 456. 132 Pattern (Medium)
In .LeetcodeDailySolution folder as Sept30,2023.java

#### Prompt:

Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].

Return true if there is a 132 pattern in nums, otherwise, return false.

Example 1:

Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.
Example 2:

Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
Example 3:

Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
 
Constraints:

n == nums.length
1 <= n <= 2 * 105
-109 <= nums[i] <= 109

#### Solution:

    import java.util.Stack;

    class Solution {
       public boolean find132pattern(int[] nums) {
        int n = nums.length;
        int[] minLeft = new int[n];
        minLeft[0] = nums[0];
        
        for (int i = 1; i < n; i++) {
            minLeft[i] = Math.min(minLeft[i - 1], nums[i]);
        }
        
        Stack<Integer> stack = new Stack<>();
        
        for (int j = n - 1; j >= 0; j--) {
            if (nums[j] > minLeft[j]) {
                while (!stack.isEmpty() && stack.peek() <= minLeft[j]) {
                    stack.pop();
                }
                if (!stack.isEmpty() && stack.peek() < nums[j]) {
                    return true;
                }
                stack.push(nums[j]);
            }
        }
        
        return false;
      }
    }

Runtime: 15 ms, beating 68.8% of leetcode users solutions using java.
Memory: 64.1 mb, beating 8.57% of leetcode users solutions using java.

#### Concepts Applied:

Stack, for and while loop. 

### Solution Oct 1, 2023 (Java, leetcode) 557. Reverse Words In a String III (Easy) 
In .LeetcodeDailySolution folder as Oct1,2023.java

#### Prompt:

Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

Example 1:

Input: s = "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
Example 2:

Input: s = "God Ding"
Output: "doG gniD"

Constraints:

1 <= s.length <= 5 * 104
s contains printable ASCII characters.
s does not contain any leading or trailing spaces.
There is at least one word in s.
All the words in s are separated by a single space.

#### Solution:

    class Solution {
       public String reverseWords(String s) {
          String[] words = s.split(" "); 

        StringBuilder result = new StringBuilder();

        for (String word : words) {
            
            result.append(reverseWord(word)).append(" ");
        }

        return result.toString().trim(); 

    }

    private String reverseWord(String word) {
        char[] chars = word.toCharArray(); 
        int left = 0;
        int right = chars.length - 1;

        while (left < right) {

            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;

            left++;
            right--;
        }

        return new String(chars); 
      }
    }

Runtime: 4 ms, beating 87.77% of leetcode users solutions using java.
Memory: 43.9 mb, beating 85.88% of leetcode users solutions using java.

#### Concepts Applied:

Character arrays, for and while loop. 

### Solution Oct 2, 2023 (Java, leetcode) 2038. Remove Colored Pieces if Both Neighbors are the Same (Medium) 
In .LeetcodeDailySolution folder as Oct2,2023.java

#### Prompt:

There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece.

Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.

Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'.
Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'.
Alice and Bob cannot remove pieces from the edge of the line.
If a player cannot make a move on their turn, that player loses and the other player wins.
Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins.

#### Solution:

    class Solution {
      public boolean winnerOfGame(String colors) {
        int n = colors.length();
        int aliceCount = 0;
        int bobCount = 0;
        
        for (int i = 1; i < n - 1; i++) {
            if (colors.charAt(i) == 'A' && colors.charAt(i - 1) == 'A' && colors.charAt(i +         1) == 'A') {
                aliceCount++;
            } else if (colors.charAt(i) == 'B' && colors.charAt(i - 1) == 'B' && colors.    charAt(i + 1) == 'B') {
                bobCount++;
            }
        }
        
        return aliceCount > bobCount;
      }
    }

Runtime: 16 ms, beating 52.45% of leetcode users solutions using java.
Memory: 44.2 mb, beating 55.98% of leetcode users solutions using java. 

#### Concepts Applied:

Strings, for loop, if, else-if, and charAt. 

### Solution Oct 3, 2023 (Java, leetcode) 1512. Number of Good Pairs (Easy) 
In .LeetcodeDailySolution folder as Oct3,2023.java

#### Prompt:

Given an array of integers nums, return the number of good pairs.

A pair (i, j) is called good if nums[i] == nums[j] and i < j.

#### Solution:

    class Solution {
       public int numIdenticalPairs(int[] nums) {
           int[] count = new int[101]; 

        for (int num : nums) {
            count[num]++;
        }
        
        int goodPairs = 0;
        
        for (int c : count) {
            if (c > 1) {
                goodPairs += (c * (c - 1)) / 2;
            }
        }
        
        return goodPairs;
      }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40 mb, beating 34.61% of leetcode users solutions using java. 

#### Concepts Applied:

For loop.

### Solution Oct 4, 2023 (Java, leetcode) 706. Design HashMap (Easy)
In .LeetcodeDailySolution folder as Oct4,2023.java

#### Prompt:

Design a HashMap without using any built-in hash table libraries.

Implement the MyHashMap class:

MyHashMap() initializes the object with an empty map.
void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.

#### Solution

    import java.util.ArrayList;
    import java.util.List;
  
    class MyHashMap {

    private static final int SIZE = 1000;
    private List<List<int[]>> data;

    public MyHashMap() {
        data = new ArrayList<>(SIZE);
        for (int i = 0; i < SIZE; i++) {
            data.add(new ArrayList<>());
        }
    }

    private int getIndex(int key) {
        return Integer.hashCode(key) % SIZE;
    }

    public void put(int key, int value) {
        int index = getIndex(key);
        for (int[] entry : data.get(index)) {
            if (entry[0] == key) {
                entry[1] = value;
                return;
            }
        }
        data.get(index).add(new int[]{key, value});
    }

    public int get(int key) {
        int index = getIndex(key);
        for (int[] entry : data.get(index)) {
            if (entry[0] == key) {
                return entry[1];
            }
        }
        return -1;
    }

    public void remove(int key) {
        int index = getIndex(key);
        List<int[]> entries = data.get(index);
        for (int i = 0; i < entries.size(); i++) {
            if (entries.get(i)[0] == key) {
                entries.remove(i);
                return;
            }
        }
      }
    }

    public class Main {
      public static void main(String[] args) {
        MyHashMap myHashMap = new MyHashMap();
        myHashMap.put(1, 1);
        myHashMap.put(2, 2);
        System.out.println(myHashMap.get(1)); 
        System.out.println(myHashMap.get(3)); 
        myHashMap.put(2, 1);
        System.out.println(myHashMap.get(2)); 
        myHashMap.remove(2);
        System.out.println(myHashMap.get(2)); 
      }
    }

Runtime: 17 ms, beating 65.77% of leetcode users using java.
Memory: 47.6 mb, beating 69.68% of leetcode users using java.

#### Concepts Applied:

Array, hash table, linked list, design, and hash function.

### Soluton Oct 5, 2023 (Java, leetcode) 229. Majorty Element II (Medium)
In .LeetcodeDailySolution folder as Oct5,2023.java

#### Prompt:

Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.

#### Solution:

    import java.util.ArrayList;
    import java.util.List;

    class Solution {
      public List<Integer> majorityElement(int[] nums) {
        List<Integer> result = new ArrayList<>();
        int n = nums.length;

        if (n == 0) return result;

        int candidate1 = 0, candidate2 = 0, count1 = 0, count2 = 0;

        for (int num : nums) {
            if (num == candidate1) {
                count1++;
            } else if (num == candidate2) {
                count2++;
            } else if (count1 == 0) {
                candidate1 = num;
                count1 = 1;
            } else if (count2 == 0) {
                candidate2 = num;
                count2 = 1;
            } else {
                count1--;
                count2--;
            }
        }

        count1 = 0;
        count2 = 0;
        for (int num : nums) {
            if (num == candidate1) {
                count1++;
            } else if (num == candidate2) {
                count2++;
            }
        }

        if (count1 > n / 3) {
            result.add(candidate1);
        }
        if (count2 > n / 3) {
            result.add(candidate2);
        }

        return result;
      }
    }

Runtime: 1 ms, beating 99.94% of leetcode users solutions using java. 
Memory: 47.2 mb, beating 10.66% of leetcode users solutions using java.

#### Concepts Applied:

Array, hash table, sorting, and counting.

### Solution Oct 6, 2023 (Java, leetcode) 343. Integer Break (Medium)
In .LeetcodeDailySolution folder as Oct6,2023.java

#### Prompt:

Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.

Return the maximum product you can get.

#### Solution:

    class Solution {
        public int integerBreak(int n) {
                if(n == 1) return 1;
                        int[] dp = new int[n + 1];
                                dp[1] = 1;
                                        for(int i = 2; i <= n; i++){
                                                    for(int j = 1; j < i; j++){
                                                                    dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));
                                                                                }
                                                                                        }
                                                                                                return dp[n];
                                                                                                    }
                                                                                                    }
                                                                                                    
Runtime: 1 ms, beating 33.22% of leetcode users solutions using java.
Memory: 39.9 mb, beating 6.52% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming and for loop.

### Solution Oct 7, 2023 (Java, leetcode) 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons (Hard)
Im .LeetcodeDailySolution folder as Oct7,2023.java

#### Prompt:

You are given three integers n, m and k. Consider the following algorithm to find the maximum element of an array of positive integers:

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/213847ce-4a27-441a-9b8a-06910e1736ce)

You should build the array arr which has the following properties:

arr has exactly n integers.
1 <= arr[i] <= m where (0 <= i < n).
After applying the mentioned algorithm to arr, the value search_cost is equal to k.
Return the number of ways to build the array arr under the mentioned conditions. As the answer may grow large, the answer must be computed modulo 109 + 7.

#### Solution:

    class Solution {
        public int numOfArrays(int n, int m, int k) {
        long[][][] dp = new long[n][k][m];
        long mod = 1000000007;
        Arrays.fill(dp[0][0], 1);
        
        for (int i = 1; i < n; i++) {
            for (int cost = 0; cost < Math.min(i + 1, k); cost++) {
                for (int max = 0; max < m; max++) {
                    dp[i][cost][max] = (dp[i][cost][max] + (max + 1) * dp[i - 1][cost][max]) % mod;
                    if (cost != 0) {
                        long sum = 0;
                        for (int prevMax = 0; prevMax < max; prevMax++) {
                            sum += dp[i - 1][cost - 1][prevMax];
                            sum %= mod;
                        }
                        dp[i][cost][max] = (dp[i][cost][max] + sum) % mod;
                    }
                }
            }
        }
        long ans = 0;
        for (int max = 0; max < m; max++) {
            ans += dp[n - 1][k - 1][max];
            ans %= mod;
        }
        return (int) ans;
      }
    }

Runtime: 27 ms, beating 85.37% of leetcode users solutions using java.
Memory: 43.6 mb, beating 24.29% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loop, dynamic programming, and if statements.

### Solution Oct 8, 2023 (Java, leetcode) 1458. Max Dot Product of Two Subtances (Hard)
In .LeetcodeDailySolutions folder as Oct8,2023.java

#### Prompt:

Given two arrays nums1 and nums2.

Return the maximum dot product between non-empty subsequences of nums1 and nums2 with the same length.

A subsequence of a array is a new array which is formed from the original array by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, [2,3,5] is a subsequence of [1,2,3,4,5] while [1,5,3] is not).

#### Solution:

    class Solution {
        public int maxDotProduct(int[] nums1, int[] nums2) {
        int[][] marks = new int[nums1.length][nums2.length];
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < nums2.length; j++) {
                int max = nums1[i] * nums2[j];
                if (i > 0 && j > 0) {
                    max = Math.max(max, max + marks[i - 1][j - 1]);
                }
                if (i > 0) {
                    max = Math.max(max, marks[i - 1][j]);
                }
                if (j > 0) {
                    max = Math.max(max, marks[i][j - 1]);
                }
                marks[i][j] = max;
            }
        }
        return marks[nums1.length - 1][nums2.length - 1];
      }
    }
    
Runtime: 10 ms, beating 81.94% of leetcode users solutions using java.
Memory: 42.9 mb, beating 80.56% of leetcode users solutions using java.

#### Concepts Applied:

Math, for-loop and if statements.

### Solution Oct 9, 2023 (Java, leetcode) 34. Find First and Last Position of Element in Sorted Array (Medium)
In .LeetcodeDailySolution folder as Oct9,2023.java

#### Prompt:

Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

#### Solution:

    class Solution {
    public int[] searchRange(int[] nums, int target) {
        int first = -1, last = -1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                if (first == -1) {
                    first = i;
                }
                last = i;
            }
        }
        return new int[]{first, last};
      }
    }

Runtime: 1 ms, beating 20.94% of leetcode users solutions using java.
Memory: 44.1 mb, beating 82.90% of leetcode users solutions using java. 

#### Concepts Applied:

If statements.

### Solution Oct 10, 2023 (Java, leetcode) 2009. Minimum Number of Operation to Make Array Continuous
In .LeetcodeDailySolution folder as Oct10,2023.java

#### Prompt:

You are given an integer array nums. In one operation, you can replace any element in nums with any integer.

nums is considered continuous if both of the following conditions are fulfilled:

All elements in nums are unique.
The difference between the maximum element and the minimum element in nums equals nums.length - 1.
For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous.

Return the minimum number of operations to make nums continuous.

#### Solution:

    class Solution {
      public int minOperations(int[] nums) {
        Arrays.sort(nums);
        int uniqueLen = 1;
        for (int i = 1; i < nums.length; ++i) {
            if (nums[i] != nums[i - 1]) {
                nums[uniqueLen++] = nums[i];
            }
        }
        
        int ans = nums.length;
        for (int i = 0, j = 0; i < uniqueLen; ++i) {
            while (j < uniqueLen && nums[j] - nums[i] <= nums.length - 1) {
                ++j;
            }
            ans = Math.min(ans, nums.length - (j - i));
        }
        
        return ans;
      }
    }

Runtime: 36 ms, beating 99.3% of leetcode users solutions using java.
Memory: 58 mb, beating 43.69% of leetcode users solutons using java.

#### Concepts Applied:

Arrays, for loop, while loop, and if statements.

### Solution Oct 11, 2023 (Java, leetcode) 2251. Numbers of Flowers in Full Bloom (Hard)
In .LeetcodeDailySolution folder as Oct11,2023.java

#### Prompt: 

You are given a 0-indexed 2D integer array flowers, where flowers[i] = [starti, endi] means the ith flower will be in full bloom from starti to endi (inclusive). You are also given a 0-indexed integer array people of size n, where people[i] is the time that the ith person will arrive to see the flowers.

Return an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the ith person arrives.

Example 1:

Input: flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]
Output: [1,2,2,2]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.

Example 2:

Input: flowers = [[1,10],[3,3]], people = [3,3,2]
Output: [2,2,1]
Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.
For each person, we return the number of flowers in full bloom during their arrival.

#### Solution:

    class Solution {
    public int[] fullBloomFlowers(int[][] flowers, int[] persons) {
        int n = persons.length;
        int[] result = new int[n];

        TreeMap<Integer, Integer> treeMap = new TreeMap<>();
        for (int i = 0; i < flowers.length; i++) {
        
            treeMap.put(flowers[i][0], treeMap.getOrDefault(flowers[i][0], 0) + 1);

            treeMap.put(flowers[i][1] + 1, treeMap.getOrDefault(flowers[i][1] + 1, 0) - 1);
        }
        
        TreeMap<Integer, Integer> sum = new TreeMap<>();
        int prev = 0;
        for (Map.Entry<Integer, Integer> entry : treeMap.entrySet()) {
            prev += entry.getValue();
            sum.put(entry.getKey(), prev);
        }

        for (int i = 0; i < n; i++) {

            Map.Entry<Integer, Integer> entry = sum.floorEntry(persons[i]);
            if (entry != null) {
                result[i] = entry.getValue(); 
            }
        }
        return result;
        }
    }

Runtime: 102 ms, beating 19.78% of leetcode users using java.
Memory: 73.5 mb, beating 22.1% of leetcode users using java.

#### Concepts Applied:

Treemap, for loop, and if statements. 

### Solution Oct 12, 2023 (Java, leetcode) 1095. Find in Mountain Array (Hard)
In .LeetcodeDailySolution folder as Oct12,2023.java

#### Prompt:

(This problem is an interactive problem.)

You may recall that an array arr is a mountain array if and only if:

arr.length >= 3
There exists some i with 0 < i < arr.length - 1 such that:
arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
arr[i] > arr[i + 1] > ... > arr[arr.length - 1]
Given a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target. If such an index does not exist, return -1.

You cannot access the mountain array directly. You may only access the array using a MountainArray interface:

MountainArray.get(k) returns the element of the array at index k (0-indexed).
MountainArray.length() returns the length of the array.
Submissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.

#### Solution:
     
    class Solution {
    public int findInMountainArray(int target, MountainArray mountainArr) {
        int length = mountainArr.length();
        int peakIndex = findPeak(mountainArr, length);

        int result = findTarget(mountainArr, 0, peakIndex, target, true);
        if (result != -1) {
            return result;
        }

        return findTarget(mountainArr, peakIndex + 1, length - 1, target, false);
    }

    private int findTarget(MountainArray mountainArr, int left, int right, int target, boolean isUpside) {
        while (left <= right) {
            int mid = (left + right) / 2;
            int midVal = mountainArr.get(mid);

            if (midVal == target) {
                return mid;
            }

            if (isUpside) {
                if (target > midVal) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            } else {
                if (target > midVal) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }

        return -1;
    }

    private int findPeak(MountainArray mountainArr, int length) {
        int left = 0;
        int right = length - 1;

        while (left < right) {
            int mid = (left + right) / 2;
            if (mountainArr.get(mid) < mountainArr.get(mid + 1)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
        }    
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 42.9 mb, beating 85.75% of leetcode users solutions using java.

#### Concepts Applied: 

Dynamic programming, math and for loop.

### Solution Oct 13, 2023 (Java, leetcode) 746. Min Cost Climbing Stairs (Easy)
In .LeetcodeDailySolution folder as Oct13,2023.java

#### Prompt:

You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index 0, or the step with index 1.

Return the minimum cost to reach the top of the floor.

#### Solution:

    class Solution {

    public int minCostClimbingStairs(int[] cost) {

        int n = cost.length;

        int[] dp = new int[n];

        dp[0] = cost[0];

        dp[1] = cost[1];

        

        for (int i = 2; i < n; i++) {

            dp[i] = cost[i] + Math.min(dp[i-1], dp[i-2]);

        }

        

        return Math.min(dp[n-1], dp[n-2]);

        }

    }
    
Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.1 mb, beating 24.85% of leetcode users solutions using java.

#### Concepts Applied:

Dyanmic programming, math and for loop.

### Solution Oct 14, 2023 (Java, leetcode) 2742. Painting the Walls (Hard)
In .LeetcodeDailySolution folder as Oct14,2023.java

#### Prompt:

You are given two 0-indexed integer arrays, cost and time, of size n representing the costs and the time taken to paint n different walls respectively. There are two painters available:

A paid painter that paints the ith wall in time[i] units of time and takes cost[i] units of money.
A free painter that paints any wall in 1 unit of time at a cost of 0. But the free painter can only be used if the paid painter is already occupied.
Return the minimum amount of money required to paint the n walls.

#### Solution:

    class Solution {
    public int paintWalls(int[] cost, int[] time) {
        int n = cost.length;
        int[] money = new int[n+1];
        Arrays.fill(money,(int)1e9);
        money[0]=0;
        for(int i=0;i<n;i++)
        {
            for(int j=n;j>0;j--)
            {
                money[j]=Math.min(money[j],money[Math.max(j-time[i]-1,0)]+cost[i]);
            }
        }
        return money[n];
        }
    }

Runtime: 8 ms, beating 98.47% of leetcode users solutions using java.
Memory: 43.3 mb, beating 95.41% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, math and for loop. 

### Solution Oct 15, 2023 (Java, leetcode) 1269. Number of Ways to Stay in the Same Place After Some Steps (Hard)
In .LeetcodeDailySolution as Oct15,2023.java

#### Prompts:

You have a pointer at index 0 in an array of size arrLen. At each step, you can move 1 position to the left, 1 position to the right in the array, or stay in the same place (The pointer should not be placed outside the array at any time).

Given two integers steps and arrLen, return the number of ways such that your pointer is still at index 0 after exactly steps steps. Since the answer may be too large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public int numWays(int steps, int arrLen) {
        int m = steps;
        int n = Math.min(steps / 2 + 1, arrLen);
        
        int[][] dp = new int[m + 1][n];
        dp[0][0] = 1;
        
        int mod = 1000000007;
        
        for (int i = 1; i <= m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j > 0) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % mod;
                }
                if (j < n - 1) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % mod;
                }
            }
        }
        
        return dp[m][0];
        }
    }

Runtime: 9 ms, beating 67.90% of leetcode users solutions using java.
Memory: 42.1 mb, beating 89.20% of leetcode users solutions using java.

#### Concepts Applied:

Math, dynamic programming, for loops, and if statements.

### Solution Oct 16, 2023 (Java, leetcode) 119. Pascals Triangle II (Easy) 
In .LeetcodeDailySolution folder as Oct16,2023.java

#### Prompt:

Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.

In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/4de7c43b-3fb2-43b2-8d4f-806d74ff3e22)

#### Solution:

    class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> res = new ArrayList<>();

        res.add(1);
        long prev = 1;

        for (int k = 1; k<= rowIndex; k++) {
            long next_val = prev * (rowIndex - k+1) / k;
            res.add((int) next_val);
            prev = next_val;

        }
        return res;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.9 mb, beating 78.30% of leetcode users solutions using java.

#### Concepts Applied:

Lists and for loop.

### Solution Oct 17, 2023 (Java, leetcode) 1361. Validate Binary Tree Nodes (Medium)
In. LeetcodeDailySolution folder as Oct17,2023.java

#### Prompt:

You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.

If node i has no left child then leftChild[i] will equal -1, similarly for the right child.

Note that the nodes have no values and that we only use the node numbers in this problem.

#### Solution:

    class Solution {
    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
        int[] indegree = new int[n];
        for (int i = 0; i < n; i++) {
            if (leftChild[i] != -1) indegree[leftChild[i]]++;
            if (rightChild[i] != -1) indegree[rightChild[i]]++;
        }
        int root = -1;
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                if (root == -1) root = i;
                else return false;
            }
        }
        if (root == -1) return false;
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int node = queue.poll();
            if (visited[node]) return false;
            visited[node] = true;
            if (leftChild[node] != -1) queue.offer(leftChild[node]);
            if (rightChild[node] != -1) queue.offer(rightChild[node]);
        }
                int trueCount = 0;
        for (boolean b : visited) {
            if (b) trueCount++;
        }
        return trueCount == n;

        }
    }

Runtime: 5 ms, beating 76.45% of leetcode users solutions using java.
Memory: 44.2 mb, beating 91.61% of leetcode users solutions using java.

#### Concepts Applied:

For loop, if statements, linked lists, and while loop.

### Solution Oct 18, 2023 (Java, leetcode) 2050, Parallel Courses III (Hard)
In .LeetcodeDailySolution folder as Oct18,2023.java

#### Prompt:

You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course.

You must find the minimum number of months needed to complete all the courses following these rules:

You may start taking a course at any time if the prerequisites are met.
Any number of courses can be taken at the same time.
Return the minimum number of months needed to complete all the courses.

Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).

#### Solution:

    class Solution {
    private int[] startNodes;
    private int[][] graph;
    private int[] time;
    private boolean[] visited;
    private int[] ans;

    private void toGraph(int[][] edges, int n) {
        int[] incoming = new int[n], outgoing = new int[n];
        for(int[] e : edges) {
            outgoing[e[0] - 1]++;
            incoming[e[1] - 1]++;
        }
        int startCnt = 0;
        for(int i : incoming) {
            if (i == 0) {
                startCnt++;
            }
        }
        startNodes = new int[startCnt];
        for(int sni = 0, i = 0; sni < startNodes.length; i++) {
            if (incoming[i] == 0) {
                startNodes[sni++] = i;
            }
        }
        graph = new int[n][];
        for(int i = 0; i < n; i++) {
            graph[i] = new int[outgoing[i]];
        }
        for(int[] e : edges) {
            graph[e[0] - 1][--outgoing[e[0] - 1]] = e[1] - 1;
        }
    }

    private int calculate(int node) {
        if (ans[node] > 0) {
            return ans[node];
        }

        int worstPrereq = 0;
        visited[node] = true;
        for(int child : graph[node]) {
            if (!visited[child]){
                worstPrereq = Math.max(calculate(child), worstPrereq);
            }
        }
        visited[node] = false;
        return ans[node] = worstPrereq + time[node];
    }

    public int minimumTime(int n, int[][] relations, int[] time) {
        toGraph(relations, n);
        this.time = time;
        ans = new int[n];
        visited = new boolean[n];
        int longest = 0;
        for(int node : startNodes) {
            longest = Math.max(longest, calculate(node));
        }
        return longest;
        }
    }

Runtime: 13 ms, beating 99.56% of leetcode users solutions using java.
Memory: 68 mb, beating 56.45% of leetcode users solutions using java.

#### Concepts Applied:

Graphs, boolean, and for loops.

### Solution Oct 19, 2023 (Java, leetcode) 844. Backspace String Compare (Easy)
In .LeetcodeDailySolution folder as Oct19,2023.java

#### Prompt:

Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.

Note that after backspacing an empty text, the text will continue empty.

#### Solution:

    class Solution {
    public boolean backspaceCompare(String s, String t) {
        int ps = s.length() - 1;
        int pt = t.length() - 1;

        while (ps >= 0 || pt >= 0) {
            ps = get_next_valid_char_index(s, ps);
            pt = get_next_valid_char_index(t, pt);

            if (ps < 0 && pt < 0) {
                return true;
            }
            if (ps < 0 || pt < 0) {
                return false;
            } else if (s.charAt(ps) != t.charAt(pt)) {
                return false;
            }

            ps--;
            pt--;
        }

        return true;        
    }

    private int get_next_valid_char_index(String str, int end) {
        int backspace_count = 0;
        while (end >= 0) {
            if (str.charAt(end) == '#') {
                backspace_count++;
            } else if (backspace_count > 0) {
                backspace_count--;
            } else {
                break;
            }
            end--;
        }
        return end;
        }    
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.5 mb, beating 67.63% of leetcode users solutions using java.

#### Concepts Applied:

CharAt, while loop, if, else and else-if statements.

### Solution Oct 20, 2023 (Java, leetcode) 341. Flatten Nested List Iterator
In .LeetcodeDailySolution folder as Oct20,2023.java

#### Prompt:

You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.

Implement the NestedIterator class:

NestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList.
int next() Returns the next integer in the nested list.
boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.
Your code will be tested with the following pseudocode:

initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
If res matches the expected flattened list, then your code will be judged as correct.

#### Solution:

    class NestedIterator implements Iterator<Integer> {
    private Stack<NestedInteger> stack;

    public NestedIterator(List<NestedInteger> nestedList) {
        stack = new Stack<>();
        for (int i = nestedList.size() - 1; i >= 0; i--) {
            stack.push(nestedList.get(i));
        }
    }

    @Override
    public Integer next() {
        return stack.pop().getInteger();
    }

    @Override
    public boolean hasNext() {
        while (!stack.isEmpty()) {
            if (stack.peek().isInteger()) {
                return true;
            }
            List<NestedInteger> nestedList = stack.pop().getList();
            for (int i = nestedList.size() - 1; i >= 0; i--) {
                stack.push(nestedList.get(i));
            }
        }
        return false;
        }
    }

Runtime: 4 ms, beating 25.17% of leetcode users solutions using java.
Memory: 44.26 mb, beating 74.13% of leetcode users solutions using java.

#### Concepts Applied:

NestedIterator, Iterators, Stack, nestedList, boolean, and list.

### Solution Oct 21, 2023 (Java, leetcode) 1425. Constrained Subsequence Sum (Hard)
In .LeetcodeDailySolution folder as Oct21,2023.java

#### Prompt:

Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.

A subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.

#### Solution:

    class Solution {
    public int constrainedSubsetSum(int[] nums, int k) {
        Deque<Integer> queue = new ArrayDeque<>();
        int dp[] = new int[nums.length];
        
        for (int i = 0; i < nums.length; i++) {
            if (!queue.isEmpty() && i - queue.peek() > k) {
                queue.poll();
            }
            
            dp[i] = (!queue.isEmpty() ? dp[queue.peek()] : 0) + nums[i];
            while (!queue.isEmpty() && dp[queue.peekLast()] < dp[i]) {
                queue.pollLast();
            }
            
            if (dp[i] > 0) {
                queue.offer(i);
            }
        }
        
        int ans = Integer.MIN_VALUE;
        for (int num : dp) {
            ans = Math.max(ans, num);
        }
        
        return ans;
        }
    }

Runtime: 33 ms, beating 94.49% of leetcode users solutions using java.
Memory: 56.2 mb, beating 85.83% of leetcode users solutions using java.

#### Concepts Applied:

Deque, dynamic programming, for loop, and if statement.

### Solution Oct 22, 2023 (Java, leetcode) 1793. Maximum Score of a Good Subarray (Hard)
In .LeetcodeDailySolution folder as Oct22,2023.java

#### Prompt:

You are given an array of integers nums (0-indexed) and an integer k.

The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.

Return the maximum possible score of a good subarray.

#### Solution:

    class Solution {
    public int maximumScore(int[] nums, int k) {
        int n = nums.length;
        int left = k;
        int right = k;
        int ans = nums[k];
        int currMin = nums[k];
        
        while (left > 0 || right < n - 1) {
            if ((left > 0 ? nums[left - 1]: 0) < (right < n - 1 ? nums[right + 1] : 0)) {
                right++;
                currMin = Math.min(currMin, nums[right]);
            } else {
                left--;
                currMin = Math.min(currMin, nums[left]);
            }
            
            ans = Math.max(ans, currMin * (right - left + 1));
        }
        
        return ans;
        }
    }    

Runtime: 7 ms, beating 88.29% of leetcode users solutions using java.
Memory: 59.22 mb, beating 39.39% of leetcode users solutions using java. 

#### Concepts Applied:

While loop, if-statement, else-statement, and math.

### Solution Oct 23, 2023 (Java, leetcode) 342. Power of Four (Easy)
In .LeetcodeDailySolution folder as Oct23,2023.java

#### Prompt:

Given an integer n, return true if it is a power of four. Otherwise, return false.

An integer n is a power of four, if there exists an integer x such that n == 4x.

#### Solution:

    class Solution {
       public boolean isPowerOfFour(int n) {
       for(int i = 2 ;i<=32;i+=2){
           if((1<<i) == n) return true;
       }
       return false;
       }
    }
    
Runtime: 1 ms, beating 76.50% of leetcode users solutions using java.
Memory: 39.00 mb, beating 93.98% of leetcode users solutions using java.

#### Concepts Applied:

For loop and if-statement.

### Solution Oct 24, 2023 (Java, leetcode) 515. Find Largest Value in Each Tree Row (Medium)
In .LeetcodeDailySolution folder as Oct24,2023.java

#### Prompt:

Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).

Example 1:

Input: root = [1,3,2,5,3,null,9]
Output: [1,3,9]
Example 2:

Input: root = [1,2,3]
Output: [1,3]
 
Constraints:

The number of nodes in the tree will be in the range [0, 104].
-231 <= Node.val <= 231 - 1

#### Solution:

    class Solution {
    public List<Integer> largestValues(TreeNode root) {
       Map <Integer , Integer> map = new HashMap(); 
       dfs(root, 0, map);
       return new ArrayList(map.values());
    }

    private void dfs(TreeNode root, int level, Map<Integer , Integer> map){
        if(root==null) return;

        map.put(level, Math.max(root.val, map.getOrDefault(level, Integer.MIN_VALUE)));
        dfs(root.left, level+1, map);
        dfs(root.right, level+1, map);
        }
    }

Runtime: 1 ms, beating 98.02% of leetcode users solutions using java.
Memory: 43.94 mb, beating 61.09% of leetcode users solutions using java.

#### Concepts Applied:

Lists, HashMap, ArrayList, TreeNode, Map, Math, if-statement, and dfs. 

### Solution Oct 25, 2023 (Java, leetcode) 779. K-th Symbol in Grammar (Medium)
In .LeetcodeDailySolution folder as Oct25,2023.java

#### Prompt:

We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.

For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.
Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.

#### Solution:

    class Solution {
    public int kthGrammar(int n, int k) {
        if (n == 1) {
            return 0;
        }
        
        int parent = kthGrammar(n - 1, (int) Math.ceil(k / 2.0));
        boolean isOdd = k % 2 == 1;

        if (parent == 0) {
            return isOdd ? 0 : 1;
        } else {
            return isOdd ? 1 : 0;
            }  
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.04 mb, beating 49.27% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, Math, and if-statements.

### Solution Oct 26, 2023 (Java, leetcode) 823. Binary Trees With Factors (Medium)
In .LeetcodeDailySolution folder as Oct26,2023.java

#### Prompt:

Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.

We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.

Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.

#### Solution:

    class Solution {
    private static final int MOD = 1000000007;

    public int numFactoredBinaryTrees(int[] arr) {
        Arrays.sort(arr);
        Set<Integer> s = new HashSet<>();
        for (int x : arr) s.add(x);

        Map<Integer, Integer> dp = new HashMap<>();
        for (int x : arr) dp.put(x, 1);
        
        for (int i : arr) {
            for (int j : arr) {
                if (j > Math.sqrt(i)) break;
                if (i % j == 0 && s.contains(i / j)) {
                    long temp = (long) dp.get(j) * dp.get(i / j);
                    dp.put(i, (int) ((dp.get(i) + (i / j == j ? temp : temp * 2)) % MOD));
                }
            }
        }
        
        int result = 0;
        for (int val : dp.values()) {
            result = (result + val) % MOD;
        }
        return result;
        }
    }

Runtime: 14 ms, beating 82.51% of leetcode users solutions using java.
Memory: 43.46 mb, beating 36.41% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, Set, HashSet, for-loops, Map, HashMap, if statements, and dp.

### Solution Oct 27, 2023 (Java, leetcode) 5. Longest Palindromic String (Medium)
In .LeetcodeDailySolution folder as Oct27,2023.java

#### Prompt:

Given a string s, return the longest palindromic substring in s.

#### Solution:

    class Solution {
    public String longestPalindrome(String s) {
        StringBuilder sPrime = new StringBuilder("#");
        for (char c: s.toCharArray()) {
            sPrime.append(c).append("#");
        }
        
        int n = sPrime.length();
        int[] palindromeRadii = new int[n];
        int center = 0;
        int radius = 0;
        
        for (int i = 0; i < n; i++) {
            int mirror = 2 * center - i;
            
            if (i < radius) {
                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);
            }
            
            while (i + 1 + palindromeRadii[i] < n &&
                   i - 1 - palindromeRadii[i] >= 0 &&
                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {
                palindromeRadii[i]++;
            }
            
            if (i + palindromeRadii[i] > radius) {
                center = i;
                radius = i + palindromeRadii[i];
            }
        }
        
        int maxLength = 0;
        int centerIndex = 0;
        for (int i = 0; i < n; i++) {
            if (palindromeRadii[i] > maxLength) {
                maxLength = palindromeRadii[i];
                centerIndex = i;
            }
        }
        
        int startIndex = (centerIndex - maxLength) / 2;
        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);
        
        return longestPalindrome;
        }
    }

Runtime: 11 ms, beating 88.50% of leetcode users solutions using java.
Memory: 43.47 mb, beating 53.35% of leetcode users solutions using java.

#### Concepts Applied:

Char, charArray, for loops, if-statments, while loops, Math, charAt, strings.

### Solution Oct 28, 2023 (Java, leetcode) 1220. Count Vowels Permutation (Hard)
In .LeetcodeDailySolution folder as Oct28,2023.java

#### Prompt:

Given an integer n, your task is to count how many strings of length n can be formed under the following rules:

Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u')
Each vowel 'a' may only be followed by an 'e'.
Each vowel 'e' may only be followed by an 'a' or an 'i'.
Each vowel 'i' may not be followed by another 'i'.
Each vowel 'o' may only be followed by an 'i' or a 'u'.
Each vowel 'u' may only be followed by an 'a'.
Since the answer may be too large, return it modulo 10^9 + 7.

#### Solution:

    class Solution {
    public int countVowelPermutation(int n) {
        final int MOD = 1000000007;

        long a = 1, e = 1, i = 1, o = 1, u = 1;

        for (int j = 1; j < n; j++) {
            long a_next = e;
            long e_next = (a + i) % MOD;
            long i_next = (a + e + o + u) % MOD;
            long o_next = (i + u) % MOD;
            long u_next = a;
            a = a_next;
            e = e_next;
            i = i_next;
            o = o_next;
            u = u_next;
            
        }
        return (int)((a + e + i + o + u) % MOD);
        }
    }

Runtime: 5 ms, beating 99.02% of leetcode users solutions using java.
Memory: 39.30 mb, beating 84.92% of leetcode users solutions using java.

#### Concepts Applied:

Long and for loop.

### Solution Oct 29, 2023 (Java, leetcode) 458. Poor Pigs (Hard)
In .LeetcodeDailySolution folder as Oct29,2023.java

#### Prompt:

There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.

You can feed the pigs according to these steps:

Choose some live pigs to feed.
For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.
Wait for minutesToDie minutes. You may not feed any other pigs during this time.
After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.
Repeat this process until you run out of time.
Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.

#### Solution:

    class Solution{
    public int poorPigs(int buckets, int tdie, int ttest){
        int test = ttest/tdie;
        int i=0;
        
        while(Math.pow(test+1,i)< buckets)
        {
            i++;
        }
        return i;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 38.70 mb, beating 95.03% of leetcode users solutions using java.

#### Concepts Applied:

Math and while loop.

### Solution Oct 30, 2023 (Java, leetcode) 1356. Sort Integers by The Number of 1 Bits (Easy)
In .LeetcodeDailySolution folder as Oct30,2023.java

#### Prompt:

You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation and in case of two or more integers have the same number of 1's you have to sort them in ascending order.

Return the array after sorting it.

#### Solution:

    class Solution {
    public int[] sortByBits(int[] arr) {
        for ( int i =0 ;i< arr.length ;i++){
            arr[i] += Integer.bitCount(arr[i])*10001;
        }
        Arrays.sort(arr);
         for ( int i =0 ;i< arr.length ;i++){
             arr[i] = arr[i] %10001;
         }
        return arr;
        }
    }    

Runtime: 3 ms, beating 99.12% of leetcode users solutions using java.
Memory: 43.92 mb, beating 29.36% of leetcode users solutions using java.

#### Concepts Applied:

For loops and arrays.

### Solution Oct 31, 2023 (Java, leetcode) 2433. Find The Original Array of Prefix Xor (Medium)
In .LeetcodeDailySolution folder as Oct31,2023.java

#### Prompt:

You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:

pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
Note that ^ denotes the bitwise-xor operation.

It can be proven that the answer is unique.

#### Solution:

    class Solution {
    public int[] findArray(int[] pref) {
        int prev = pref[0];
        
        for (int i = 1; i < pref.length; i++) {
            pref[i] ^= prev;
            prev ^= pref[i];
        }
        return pref;        
        }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java. 
Memory: 58.68 mb, beating 54.80% of leetcode users solutions using java.

#### Concepts Applied:

findArray and for loop.

### Solution Nov 1, 2023 (Java, leetcode) 501. Find Mode in Binary Search Tree (Easy)
In .LeetcodeDailySolution folder as Nov1,2023.java

#### Prompt:

Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.

If the tree has more than one mode, return them in any order.

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than or equal to the node's key.
The right subtree of a node contains only nodes with keys greater than or equal to the node's key.
Both the left and right subtrees must also be binary search trees.

#### Solution:

    class Solution {
    private int currentVal;
    private int currentCount = 0;
    private int maxCount = 0;
    private int modeCount = 0;
    private int[] modes;
    public int[] findMode(TreeNode root) {
        inOrderTraversal(root);

        modes = new int[modeCount];
        modeCount = 0;
        currentCount = 0;

        inOrderTraversal(root);

        return modes;
    }
    private void inOrderTraversal(TreeNode node) {
        if (node == null) return;
        inOrderTraversal(node.left);
        handleValue(node.val);
        inOrderTraversal(node.right);
    }
    private void handleValue(int val) {
        if (val == currentVal) {
            currentCount++;
        } else {
            currentVal = val;
            currentCount = 1;
        }
        if (currentCount > maxCount) {
            maxCount = currentCount;
            modeCount = 1;
        } else if (currentCount == maxCount) {
            if (modes != null) {
                modes[modeCount] = currentVal;
            }
            modeCount++;
            }
        }
    }    

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.46 mb, beating 93.96% of leetcode users solutions using java.

#### Concepts Applied: 

Treenodes, traversals, if-statements, else statements, and else-if statements.

### Solution Nov 2, 2023 (Java, leetcode) 2265. Count Nodes Equal to Average of Subtree (Medium)
In .LeetcodeDailySolution folder as Nov2,2023.java

#### Prompt:

Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.

Note:

The average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.
A subtree of root is a tree consisting of root and all of its descendants.

#### Solution:

    class Solution {
    int count = 0;
    public int averageOfSubtree(TreeNode root) {
        dfs(root);
        return count;
    }
        private int[] dfs(TreeNode node) {
        if(node == null) {
            return new int[]{0, 0};
        } 
        int[] leftResults = dfs(node.left);
        int[] rightResults = dfs(node.right);
        
        int totalSum = node.val + leftResults[0] + rightResults[0];

        int totalCount = 1 + leftResults[1] + rightResults[1];

        if(node.val == totalSum/totalCount) count++;

        return new int[]{totalSum, totalCount};
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 42.40 mb, beating 95.77% of leetcode users solutions using java.

#### Concepts Applied:

dfs, Treenode, and if-statements.

### Solution Nov 4, 2023 (Java, leetcode) 1503. Last Momment Before All Ants Fall Out of a Plank (Medium)
In .LeetcodeDailySolution folder as Nov4,2023.java

#### Prompt:

We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.

When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.

When an ant reaches one end of the plank at a time t, it falls out of the plank immediately.

Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.

#### Solution:

    class Solution {
        public int getLastMoment(int n, int[] left, int[] right) {
        int res = 0;
        for (int i: left)
            res = Math.max(res, i);
        for (int i: right)
            res = Math.max(res, n - i);
        return res;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.49 mb, beating 92.47% of leetcode users solutions using java.

#### Concepts Applied:

For loops and Math.

### Solution Nov 5, 2023 (Java, leetcode) 1535. Find the Winner of an Array Game (Medium)
In .LeetcodeDailySolution folder as Nov5,2023.java

#### Prompt:

Given an integer array arr of distinct integers and an integer k.

A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.

Return the integer which will win the game.

It is guaranteed that there will be a winner of the game.

#### Solution:

    class Solution {
    public int getWinner(int[] A, int k) {
        int cur = A[0]; int win = 0;
        
        for (int i = 1; i < A.length; ++i) {
            if (A[i] > cur) {
                cur = A[i];
                win = 0;
            }
            if (++win == k) {
                break;
            }
        }
        return cur;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 56.40 mb, beating 69.18% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loops, and if statements. 

### Solution Nov 6, 2023 (Java, leetcode) 1845. Seat Reservation Manager (Medium)
In .LeetcodeDailySolution folder as Nov6,2023.java

#### Prompt: 

Design a system that manages the reservation state of n seats that are numbered from 1 to n.

Implement the SeatManager class:

SeatManager(int n) Initializes a SeatManager object that will manage n seats numbered from 1 to n. All seats are initially available.
int reserve() Fetches the smallest-numbered unreserved seat, reserves it, and returns its number.
void unreserve(int seatNumber) Unreserves the seat with the given seatNumber.

#### Solution:

    class SeatManager {
    private PriorityQueue<Integer> queue;

    public SeatManager(int n) {
        queue = new PriorityQueue<>();
        for (int i = 1; i <= n; i++) {
            queue.offer(i);
        }
    }
    public int reserve() {
        return (!queue.isEmpty())? queue.poll() : -1;
    }
    public void unreserve(int seatNumber) {
        queue.offer(seatNumber);
      }
    }

Runtime: 88 ms, beating 50.38% of leetcode users solutions using Java.
Memory: 89.30 mb, beating 34.40% of leetcode users solutions using Java.

#### Concepts Applied:

Queues and for loop.

### Solution Nov 7, 2023 (Java, leetcode) 1921. Eliminate Maximum Number of Monsters (Medium)
In .LeetcodeDailySolution folder as Nov7,2023.java

#### Prompt:

You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.

The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.

You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start.

You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.

Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.

#### Solution:

    class Solution {
    public int eliminateMaximum(int[] dist, int[] speed) {
        int[] time = new int[dist.length];

        for(int i=0;i<dist.length;i++)
            time[i] = (int)Math.ceil((double)dist[i]/speed[i]);

        Arrays.sort(time);

        int ans = 0;
        int T = 0;
        for(int i=0;i<time.length;i++)
        {
            if(T++<time[i])
                ans++;
            else
                break;
        }
        return ans;
        }
    }

Runtime: 19 ms, beating 62.18% of leetcode users solutions using java.
Memory: 54.50 mb, beating 83.52% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, Math, for loops, and else condition. 

### Solution Nov 8, 2023 (Java, leetcode) 2849. Determine if a Cell is Reachable at a Given Time (Medium)
In .LeetcodeDailySolution folder as Nov8,2023.java

#### Prompt:

You are given four integers sx, sy, fx, fy, and a non-negative integer t.

In an infinite 2D grid, you start at the cell (sx, sy). Each second, you must move to any of its adjacent cells.

Return true if you can reach cell (fx, fy) after exactly t seconds, or false otherwise.

A cell's adjacent cells are the 8 cells around it that share at least one corner with it. You can visit the same cell several times.

#### Solution:

    class Solution {
    public static boolean isReachableAtTime(int sx, int sy, int fx, int fy, int t) {
        int minsteps = 0;
        int a = Math.abs(fx - sx);
        int b = Math.abs(fy - sy);
        
        if (a == 0 && b == 0) {
            return t != 1;
        }
        if (a < b) {
            if (sy < fy) {
                return (fy - (sy + a) + a) <= t;
            } else {
                return (sy - (fy + a) + a) <= t;
            }
        } else {
            if (sx < fx) {
                return (fx - (sx + b) + b) <= t;
            } else {
                return (sx - (fx + b) + b) <= t;
                }
            }
        }
    }

Runtime: 1 ms, beating 91.04% of leetcode users solutions using java.
Memory: 39.60 mb, beating 53.57% of leetcode users solutions using java.

#### Concepts Applied:

Math, boolean, if and else statements.

### Solution Nov 9, 2023 (Java, leetcode) 1759. Count Number of Homogenous Substrings (Medium)
In .LeetcodeDailySolution folder as Nov9,2023.java

#### Prompt:

Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.

A string is homogenous if all the characters of the string are the same.

A substring is a contiguous sequence of characters within a string.

#### Solution: 

    class Solution {
    public int countHomogenous(String s) {
    var prev = '?'; var cnt = 1; var sum = 0;

    for (var c : s.toCharArray()) {
      if (c != prev) {
        cnt = 1;
        prev = c;
          }
      sum = (sum + cnt++) % 1000000007;
        }
    return sum;
      }
    }

Runtime: 6 ms, beating 95.62% of leetcode users solutions using java.
Memory: 44.08 mb, beatiing 63.58% of leetcode users solutions using java.

#### Concepts Applied:

Var, charArray, and if statement.

### Solution Nov 10, 2023 (Java, leetcode) 1743. Restore the Array From Adjacent Pairs (Medium)
In .LeetcodeDailySolution folder as Nov10,2023.java

#### Prompt:

There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.

You are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.

It is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.

Return the original array nums. If there are multiple solutions, return any of them.

#### Solution:

    class Solution {
    private static final int MINV = -100000, MAXV = 100000,
    RANGEV = MAXV - MINV + 1;
    private static final long UINT_MAX = 0xFFFFFFFFl;
    private static long[] index = new long[RANGEV];

    public int[] restoreArray(int[][] apairs) {
        final int n = apairs.length;
        if (n == 1) return apairs[0];
        int minv = MAXV, maxv = MINV;
        for (int i = 0; i < n; i++) {
            final var ap = apairs[i];
            final int v0 = ap[0], v1 = ap[1];
            final long j = i + 1;
            index[v0-MINV] += index[v0-MINV] == 0 ? j : j << 32;
            index[v1-MINV] += index[v1-MINV] == 0 ? j : j << 32;
            final int mn = Math.min(v0, v1);
            final int mx = Math.max(v0, v1);
            minv = Math.min(mn, minv);
            maxv = Math.max(mx, maxv);
        }

        int head = minv;
        while (head <= maxv
            && (index[head-MINV] > UINT_MAX || index[head-MINV] == 0))
            head++;

        int[] r = new int[n + 1];
        r[0] = head;
        int ri = 1;
        for (long idx = index[head-MINV]; idx != 0; idx = index[head-MINV]) {
            final int loidx = (int)(idx & UINT_MAX);
            final var ap = apairs[loidx - 1];
            index[head-MINV] >>>= 32;
            r[ri++] = head = ap[ap[0] == head ? 1 : 0];
            final int lonext = (int)(index[head-MINV] & UINT_MAX),
                      hinext = (int)(index[head-MINV] >>> 32);
            if (lonext == loidx) index[head-MINV] = hinext;
            else if (hinext == loidx) index[head-MINV] = lonext;
        }
        return r;
        }
    }

Runtime: 18 ms, beating 99.78% of leetcode users solutions using java.
Memory: 87.14 mb, beating 68.17% of leetcode users solutions using java.

#### Concepts Applied:

Long, apairs, index, Math, if statements, while and for loops.

### Solution Nov 11, 2023 (Java, leetcode) 2642. Design Graph With Shortest Path Calculator (Hard)
In .LeetcodeDailySolution folder as Nov11,2023.java

#### Prompt:

There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.

Implement the Graph class:

Graph(int n, int[][] edges) initializes the object with n nodes and the given edges.
addEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.
int shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.

#### Solution:

    class Graph {
    int[][] distance; int n;
    final int MAX_VALUE = 500_000_000;

    public Graph(int n, int[][] edges) {
        this.n = n;
        distance = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                distance[i][j] = MAX_VALUE;
            }
            distance[i][i] = 0;
        }
        for (int[] edge : edges) {
            distance[edge[0]][edge[1]] = edge[2];
        }
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    distance[i][j] = Math.min(
                        distance[i][j],
                        distance[i][k] + distance[k][j]
                    );
                }
            }
        }
    }
    
    public void addEdge(int[] edge) {
        if (distance[edge[0]][edge[1]] <= edge[2]) {
            return;
        }
        distance[edge[0]][edge[1]] = edge[2];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                distance[i][j] = Math.min(
                    distance[i][j],
                    distance[i][edge[0]] + edge[2] + distance[edge[1]][j]
                );
            }
        }
    }
    public int shortestPath(int node1, int node2) {
        if (distance[node1][node2] == MAX_VALUE) {
            return -1;
        }
        return distance[node1][node2];
        }
    }

Runtime: 64 ms, beating 97.92% of leetcode users solutions using java.
Memory: 54.40 mb, beating 76.67% of leetcode users solutions using java.

#### Concepts Applied:

Graph, for loops, if statements, Math, and nodes.

### Solution Nov 12, 2023 (Java, leetcode) 815 Bus Routes (Hard)
In .LeetcodeDailySolution folder as Nov12,2023.java

#### Prompt:

You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.

For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.
You will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.

Return the least number of buses you must take to travel from source to target. Return -1 if it is not possible.

#### Solution:

    class Solution {
    public int numBusesToDestination(int[][] routes, int source, int target) {
        if (source == target) {
            return 0;
        }
        int maxStop = -1;
        for (int[] route : routes) {
            for (int stop : route) {
                maxStop = Math.max(maxStop, stop);
            }
        }
        if (maxStop < target) {
            return -1;
        }
        int n = routes.length;
        int[] minBusesToReach = new int[maxStop + 1];
        Arrays.fill(minBusesToReach, n + 1);
        minBusesToReach[source] = 0;
        boolean flag = true;
        while (flag) {
            flag = false;
            for (int[] route : routes) {
                int min = n + 1;
                for (int stop : route) {
                    min = Math.min(min, minBusesToReach[stop]);
                }
                min++;
                for (int stop : route) {
                    if (minBusesToReach[stop] > min) {
                        minBusesToReach[stop] = min;
                        flag = true;
                    }
                }
            }
            
        }
        return (minBusesToReach[target] < n + 1 ? minBusesToReach[target] : -1);
        }
    }

Runtime: 4 ms, beating 82.66% of leetcode users solutions using java.
Memory: 53.89 mb, beating 97.41% of leetcode users solutions using java.

#### Concepts Applied:

For loops, Math, Arrays, boolean, while loop, and if statements.

### Solution Nov 13, 2023 (Java, leetcode) 2785. Sort Vowels in a String (Medium)
In .LeetcodeDailySolution folder as Nov13,2023.java

#### Prompt:

Given a 0-indexed string s, permute s to get a new string t such that:

All consonants remain in their original places. More formally, if there is an index i with 0 <= i < s.length such that s[i] is a consonant, then t[i] = s[i].
The vowels must be sorted in the nondecreasing order of their ASCII values. More formally, for pairs of indices i, j with 0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must not have a higher ASCII value than t[j].
Return the resulting string.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.

#### Solution:

    class Solution {
    boolean isVowel(Character c) {
        return c == 'a' || c == 'e' || c == 'o'|| c == 'u'|| c == 'i'
                || c == 'A' || c == 'E' || c == 'O'|| c == 'U'|| c == 'I';
    }
    public String sortVowels(String s) {
        int[] count = new int[1000];
        for (char c : s.toCharArray()) {
            if (isVowel(c)) {
                count[c - 'A']++;
            }
        }
        String sortedVowel = "AEIOUaeiou";
        StringBuilder ans = new StringBuilder();
        int j = 0;
        for (int i = 0; i < s.length(); i++) {
            if (!isVowel(s.charAt(i))) {
                ans.append(s.charAt(i));
            } else {
                while (count[sortedVowel.charAt(j) - 'A'] == 0) {
                    j++;
                }
                ans.append(sortedVowel.charAt(j));
                count[sortedVowel.charAt(j) - 'A']--;
            }
        }
        return ans.toString();
        }
    }

Runtime: 21 ms, beating 82.90% of leetcode users solutions using java.
Memory: 44.37 mb, beating 91.33% of leetcode users solutions using java.

#### Concepts Applied:

Booleans, chars, charArr, strings, for loops, charAt, if statements, else statements, and while loop.

### Solution Nov 14, 2023 (Java, leetcode) 1930. Unique Length-3 Palindromic Subsequences (Medium)
In .LeetcodeDailySolution folder as Nov14,2023.java

#### Prompt:

Given a string s, return the number of unique palindromes of length three that are a subsequence of s.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once.

A palindrome is a string that reads the same forwards and backwards.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".

#### Solution:

    class Solution {
    public int countPalindromicSubsequence(String inputString) {
        int[] minExist = new int[26];
        int[] maxExist = new int[26];
        for (int i = 0; i < 26; i++) {
            minExist[i] = Integer.MAX_VALUE;
            maxExist[i] = Integer.MIN_VALUE;
        }
        for (int i = 0; i < inputString.length(); i++) {
            int charIndex = inputString.charAt(i) - 'a';
            minExist[charIndex] = Math.min(minExist[charIndex], i);
            maxExist[charIndex] = Math.max(maxExist[charIndex], i);
        }
        int uniqueCount = 0;
        for (int charIndex = 0; charIndex < 26; charIndex++) {
            if (minExist[charIndex] == Integer.MAX_VALUE || maxExist[charIndex] == Integer.MIN_VALUE) {
                continue; 
            }
            HashSet<Character> uniqueCharsBetween = new HashSet<>();
            for (int j = minExist[charIndex] + 1; j < maxExist[charIndex]; j++) {
                uniqueCharsBetween.add(inputString.charAt(j));
            }
            uniqueCount += uniqueCharsBetween.size();
        }
        return uniqueCount;
        }
    }

Runtime: 155 ms, beating 75.16% of leetcode users solutions using java.
Memory: 44.29 mb, beating 71.41% of leetcode users solutions using java.

#### Concepts Applied:

Strings, for loops, charIndex, charAt, Math, and HashSet.

### Solution Nov 15, 2023 (Java, leetcode) 1846. Maximum Element After Decreasing and Rearranging (Medium)
In .LeetcodeDailySolution folder as Nov15,2023.java

#### Prompt:

You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:

The value of the first element in arr must be 1.
The absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.
There are 2 types of operations that you can perform any number of times:

Decrease the value of any element of arr to a smaller positive integer.
Rearrange the elements of arr to be in any order.
Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.

#### Solution:

    class Solution {
    public int maximumElementAfterDecrementingAndRearranging(int[] arr) {
        Arrays.sort(arr);
        arr[0] = 1;

        for (int i = 1; i < arr.length; ++i) {
            if (Math.abs(arr[i] - arr[i - 1]) <= 1) {
                continue; 
            } else {
                arr[i] = arr[i - 1] + 1; 
            }
        }
        return arr[arr.length - 1]; 
        }
    }

Runtime: 6 ms, beating 62.75% of leetcode users solutions using java.
Memory: 56.68 mb, beating 48.40% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loop, Math, if and else statements.

### Solution Nov 16, 2023 (Java, leetcode) 1980. Find Unique Binary String (Medium)
In .LeetcodeDailySolution folder as Nov16,2023.java

#### Prompt:

Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. 
If there are multiple answers, you may return any of them.

#### Solution:

    class Solution {
    public String findDifferentBinaryString(String[] nums) {
        StringBuilder sb = new StringBuilder();

        for(int i=0;i<nums.length;i++)
        {
            sb.append(nums[i].charAt(i) == '0'? "1": "0");
        }
        return new String(sb);
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.43 mb, beating 73.89% of leetcode users solutions using java.

#### Concepts Applied:

Strings, for loop, and charAt.

### Solution Nov 17, 2023 (Java, leetcode) 1877. Minimize Maximum Pair Sum in Array (Medium)
In .LeetcodeDailySolution folder as Nov17,2023.java

#### Prompt:

The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.

For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.
Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:

Each element of nums is in exactly one pair, and
The maximum pair sum is minimized.
Return the minimized maximum pair sum after optimally pairing up the elements.

#### Solution: 

    class Solution {
    public int minPairSum(int[] nums) {
        Arrays.sort(nums);
        int left = 0, right = nums.length - 1;
        int minMaxPairSum = Integer.MIN_VALUE;

        while (left < right) {
            int currentPairSum = nums[left] + nums[right];
            minMaxPairSum = Math.max(minMaxPairSum, currentPairSum);
            left++;
            right--;
        }
        return minMaxPairSum;
        }
    }

Runtime: 53 ms, beating 86.60% of leetcode users solutions using java.
Memory: 56.48 mb, beating 96.69% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, while loop, and Math.

### Solution Nov 18, 2023 (Java, leetcode) 1838. Frequency of the Most Frequent Element (Medium)
In .LeetcodeDailySolution folder as Nov18,2023.java

#### Prompt:

The frequency of an element is the number of times it occurs in an array.

You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.

Return the maximum possible frequency of an element after performing at most k operations.

#### Solution:

    class Solution {
    public int maxFrequency(int[] nums, int k) {
        Arrays.sort(nums);
        int i = 0;
        int j = 0;
        int sum = 0;
        int maxLength = 0;

        for (i = 0; i < nums.length; i++) {
            sum += nums[i];
            while ((i - j + 1) * nums[i] - sum > k) {
                sum -= nums[j];
                j++;
            }
            maxLength = Math.max(maxLength, i - j + 1);
        }
        return maxLength;
        }
    }

Runtime: 29 ms, beating 77.42% of leetcode users solutions using java.
Memory: 56.53 mb, beating 83.11% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loop, while loop, and Math.

### Solution Nov 19, 2023 (Java, leetcode) 1887. Reduction Operations to Make the Array Element Equal (Medium)
In .LeetcodeDailySolution folder as Nov19,2023.java

#### Prompt:

Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:

Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.

#### Solution:

    class Solution {
    public int reductionOperations(int[] nums) {
        int n = nums.length;
        int[] freq = new int[50001];

        for (int i = 0; i < n; i++) {
            freq[nums[i]]++;
        }
        int res = 0, operations = 0;

        for (int i = 50000; i >= 1; i--) {

            if (freq[i] > 0) {

                operations += freq[i];

                res += operations - freq[i];
            }
        }
        return res;
        }
    }

Runtime: 7 ms, beating 99.25% of leetcode users solutions using java.
Memory: 53.99 mb, beating 98.99% of leetcode users solutions using java.

#### Concepts Applied:

Array, for loop, and if statements.

### Solution Nov 20, 2023 (Java, leetcode) 2391. Minimum Amount of Time to Collect Garbage (Medium)
In .LeetcodeDailySolution folder as Nov20,2023.java

#### Prompt:

You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.

You are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.

There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.

Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.

Return the minimum number of minutes needed to pick up all the garbage.

#### Solution:

    class Solution {
    boolean hasG = false, hasP = false, hasM = false;
    public int garbageCollection(String[] garbage, int[] travel) {
        int n = garbage.length;
        int ans = 0;
        for (int i = 0; i < n - 1; i++) {
            ans += 3 * travel[i];
        }
        for (String s : garbage) {
            ans += s.length();
        }
        for (int i = n - 1; i > 0; i--) {
            if (!garbage[i].contains("G")) {
                ans -= travel[i - 1];
            } else {
                break;
            }
        }
        for (int i = n - 1; i > 0; i--) {
            if (!garbage[i].contains("P")) {
                ans -= travel[i - 1];
            } else {
                break;
            }
        }
        for (int i = n - 1; i > 0; i--) {
            if (!garbage[i].contains("M")) {
                ans -= travel[i - 1];
            } else {
                break;
            }
        }
        return ans;
        }
    }

Runtime: 2 ms, beating 99.33% of leetcode users solutions using java.
Memory: 60.74 mb, beating 88.61% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, for loops, and strings.

### Solution Nov 21, 2023 (Java, leetcode) 1814. Count Nice Pairs in an Array (Medium)
In .LeetcodeDailySolution folder as Nov21,2023.java

#### Prompt:

You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:

0 <= i < j < nums.length
nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public int countNicePairs(int[] nums) {
        final int mod = 1000000007;
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            nums[i] = nums[i] - reverse(nums[i]);
        }
        Arrays.sort(nums);
        long res = 0;
        for (int i = 0; i < len - 1; i++) {
            long count = 1;
            while (i < len - 1 && nums[i] == nums[i + 1]) {
                count++;
                i++;
            }
            res = (res % mod + (count * (count - 1)) / 2) % mod;
        }

        return (int) (res % mod);
    }
    private int reverse(int num) {
        int rev = 0;
        while (num > 0) {
            rev = rev * 10 + num % 10;
            num /= 10;
        }
        return rev;
        }
    }

Runtime: 20 ms, beating 100% of leetcode users solutions using java.
Memory: 54.70 mb, beating 63.24% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, long, for loops, and while loops.

### Solution Nov 22, 2023 (Java, leetcode) 1424. Diagonal Traverse II (Medium)
In .LeetcodeDailySolution folder as Nov22,2023.java

#### Prompt:

Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.

#### Solution:

    class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        Queue<Pair<Integer, Integer>> queue = new LinkedList();
        queue.offer(new Pair(0, 0));
        List<Integer> ans = new ArrayList();
        
        while (!queue.isEmpty()) {
            Pair<Integer, Integer> p = queue.poll();
            int row = p.getKey();
            int col = p.getValue();
            ans.add(nums.get(row).get(col));
            
            if (col == 0 && row + 1 < nums.size()) {
                queue.offer(new Pair(row + 1, col));
            }
            if (col + 1 < nums.get(row).size()) {
                queue.offer(new Pair(row, col + 1));
            }
        }
        int[] result = new int[ans.size()];
        int i = 0;
        for (int num : ans) {
            result[i] = num;
            i++;
        }
        return result;
        }
    }

Runtime: 28 ms, beating 72% of leetcode users solutions using java.
Memory: 68.89 mb, beating 63.64% of leetcode users solutions using java.

#### Concepts Applied:

List, linkedlist, queue, and Arraylist.

### Solution Nov 23, 2023 (Java, leetcode) 1630. Arithmetic Subarrays (Medium)
In .LeetcodeDailySolution folder as Nov23,2023.java

#### Prompt:

A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.

For example, these are arithmetic sequences:

1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic:

1, 1, 2, 5, 7
You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.

Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.

#### Solution:

    class Solution {
    public List<Boolean> checkArithmeticSubarrays(int[] nums, int[] l, int[] r) {
        List<Boolean> res=new ArrayList<>();
        
        for(int i=0;i<l.length;i++){
            if(r[i]-l[i]<2) res.add(true);
            else{
                int minNum=minNum(nums,l[i],r[i]);
                int maxNum=maxNum(nums,l[i],r[i]);
                int diff=maxNum-minNum;
                int countDiff=r[i]-l[i];
                if(minNum==maxNum) res.add(true);
                else if(diff%countDiff!=0) res.add(false);
                else{
                    int d=diff/countDiff;
                    boolean[] mark=new boolean[r[i]-l[i]+1];
                    boolean flag=true;
                    for(int p=l[i];p<=r[i];p++){
                        if((nums[p]-minNum)%d!=0) {
                            flag=false;
                            break;
                        }
                        if(mark[(nums[p]-minNum)/d]){
                            flag=false;
                            break;
                        }
                        else {
                            mark[(nums[p]-minNum)/d]=true;
                        }

                    }
                    res.add(flag);
                }
                }
        }
        System.gc();
        return res;
    }  
        public int minNum(int[] nums,int left,int right){
            int ans=nums[left];
            for(int i=left;i<=right;i++){
                ans=Math.min(ans,nums[i]);
            }
            return ans;
        }
        public int maxNum(int[] nums,int left,int right){
            int ans=nums[left];
            for(int i=left;i<=right;i++){
                ans=Math.max(ans,nums[i]);
            }
            return ans;
        }
    }

Runtime: 10 ms, beating 97.52% of leetcode users solutions using java.
Memory: 42.34 mb, beating 99.72% of leetcode users solutions using java.

#### Concepts Applied:

Lists, booleans, ArrayLists, for loops, if statements, else statements, and Math.

### Solution Nov 24, 2023 (Java, leetcode) 1561. Maximum Number of Coins You Can Get (Medium)
In .LeetcodeDailySolution folder as Nov24,2023.java

#### Prompt:

There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:

In each step, you will choose any 3 piles of coins (not necessarily consecutive).
Of your choice, Alice will pick the pile with the maximum number of coins.
You will pick the next pile with the maximum number of coins.
Your friend Bob will pick the last pile.
Repeat until there are no more piles of coins.
Given an array of integers piles where piles[i] is the number of coins in the ith pile.

Return the maximum number of coins that you can have.

#### Solution:

    class Solution {
    public int maxCoins(int[] piles) {
        int ans = 0; int n = piles.length;
        Arrays.sort(piles);

        for (int i = n / 3; i < n; i += 2) {
            ans += piles[i];
        }
        return ans;
        }
    }

Runtime: 27 ms, beating 98.94% leetcode users solutions using java.
Memory: 54.45 mb, beating 72.08% leetcode users solutions using java.

#### Concepts Applied:

Arrays and for loop.

### Solution Nov 25, 2023 (Java, leetcode) 1685. Sum of Absolute Differences in a Sorted Array (Medium)
In .LeetcodeDailySolution folder as Nov25,2023.java

#### Prompt:

You are given an integer array nums sorted in non-decreasing order.

Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.

In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).

#### Solution:

    class Solution {
    public int[] getSumAbsoluteDifferences(int[] nums) {
        int n = nums.length;
        int[] prefix = new int[n];

        prefix[0] = nums[0];

        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] + nums[i];
        }
        
        int[] ans = new int[n];

        for (int i = 0; i < n; i++) {
            int leftSum = prefix[i] - nums[i];
            int rightSum = prefix[n - 1] - prefix[i];
            
            int leftCount = i;
            int rightCount = n - 1 - i;
            
            int leftTotal = leftCount * nums[i] - leftSum;
            int rightTotal = rightSum - rightCount * nums[i];
            
            ans[i] = leftTotal + rightTotal;
        }
        return ans;
        }
    }

Runtime: 4 ms, beating 62.31% of leetcode users solutions using java.
Memory: 57.61 mb, beating 68.89% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, for loops, and prefix sums.

### Solution Nov 26, 2023 (Java, leetcode) 1727. Largest Submatrix With Rearrangements (Medium)
In .LeetcodeDailySolution folder as Nov26,2023.java

#### Prompt:

You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.

Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.

#### Solution:

    class Solution {
    public int largestSubmatrix(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;

        for (int i = 1; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == 1) {
                    matrix[i][j] += matrix[i - 1][j];
                }
            }
        }

        int res = 0;
        for (int i = 0; i < row; i++) {
            Arrays.sort(matrix[i]);

            for (int j = 0; j < col; j++) {
                int height = matrix[i][j];
                int width = col - j;
                res = Math.max(res, height * width);
            }
        }

        return res;        
        }
    }

Runtime: 8 ms, beating 100% of leetcode users solutions using java.
Memory: 67.44 mb, beating 56.32% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, for loops, and Math.

### Solution Nov 27, 2023 (Java, leetcode) 935. Knight Dealer (Medium)
In .LeetcodeDailySolution folder as Nov27,2023.java

#### Prompt:

The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:

A chess knight can move as indicated in the chess diagram below:

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/9f5adc8f-5fb5-4f5b-a3bb-bd91026b6958)

We have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/9f358451-bcd4-481a-aefe-0b60f9d69667)

Given an integer n, return how many distinct phone numbers of length n we can dial.

You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.

As the answer may be very large, return the answer modulo 109 + 7.

#### Solution:

    class Solution {
    static final int MOD = 1_000_000_007;
    public int knightDialer(int n) {
        long[] curPos = new long[10];

        Arrays.fill(curPos, 1);

        for (int jump = 2; jump <= n; jump++) {
            long[] newPos = new long[10];

            newPos[0] = (curPos[6] + curPos[4]) % MOD;
            newPos[1] = (curPos[6] + curPos[8]) % MOD;
            newPos[2] = (curPos[7] + curPos[9]) % MOD;
            newPos[3] = (curPos[4] + curPos[8]) % MOD;
            newPos[4] = (curPos[0] + curPos[3] + curPos[9]) % MOD;
            newPos[5] = 0;  
            newPos[6] = (curPos[0] + curPos[1] + curPos[7]) % MOD;
            newPos[7] = (curPos[2] + curPos[6]) % MOD;
            newPos[8] = (curPos[1] + curPos[3]) % MOD;
            newPos[9] = (curPos[2] + curPos[4]) % MOD;

            curPos = newPos;
        }
        long totalCount = 0;
        for (int i = 0; i < 10; i++) {
            totalCount = (totalCount + curPos[i]) % MOD;
        }
        return (int) totalCount;
        }
    }

Runtime: 20 ms, beating 83.37% of leetcode users solutions using java.
Memory: 43.23 mb, beating 69.42% of leetcode users solutions using java.

#### Concepts Applied:

Long, arrays, pos, and for loop.

### Solution Nov 28, 2023 (Java, leetcode) 2147. Number of Ways to Divide a Long Corrdior (Hard)
In .LeetcodeDailySolution folder as Nov28,2023.jaca

#### Prompt:

Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant.

One room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.

Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.

Return the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.

#### Solution:

    class Solution {
    public int numberOfWays(String corridor) {
        int x = 1;
        int y = 0; 
        int z = 0;
        int mod = (int)1e9 + 7;
        
        for (int i = 0; i < corridor.length(); ++i)
            if (corridor.charAt(i) == 'S') {
                x = (x + z) % mod;
                z = y; 
                y = x;
                x = 0;
            } else {
                x = (x + z) % mod;
            }
        return z;
        }
    }

Runtime: 21 ms, beating 97.30% of leetcode users solutions using java.
Memory: 44.83 mb, beating 70.27% of leetcode users solutions using java.

#### Concepts Applied:

charAt, strings, for loop, if statement, and else statement.

### Solution Nov 29, 2023 (Java, leetcode) 191. Number of 1 Bits (Easy)
In .LeetcodeDailySolution folder as Nov29,2023.java

#### Prompt:

Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).

Note:

Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.

#### Solution:

    class Solution {
    public int hammingWeight(int n) {
        int count = 0;

        while (n != 0) {
            n = n & (n - 1);
            count++;
        }
        return count;
      }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.80 mb, beating 6.93% of leetcode users solutions using java.

#### Concepts Applied:

While loop, and Brian Kernighan's Algorithm.

### Solution Nov 30, 2023 (Java, leetcode) 1611. Minimum One Bit Operations to Make Integers Zero (Hard) 
In .LeetcodeDailySolution folder as Nov30,2023.java

#### Prompt:

Given an integer n, you must transform it into 0 using the following operations any number of times:

Change the rightmost (0th) bit in the binary representation of n.
Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.
Return the minimum number of operations to transform n into 0.

#### Solution:

    class Solution {
        public int minimumOneBitOperations(int n) {
        int sign = 1, res = 0;

        while (n > 0) {
            res += n ^ (n - 1) * sign;
            n &= n - 1;
            sign = -sign;
        }
        return Math.abs(res);
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.27 mb, beating 56.86% of leetcode users solutions using java.

#### Concepts Applied:

Math, recursion, and while loop.

### Solution Dec 1, 2023 (Java, leetcode) 1662. Check If Two String Arrays are Equivalent (Easy)
In .LeetcodeDailySolution folder as Dec1,2023.java

#### Prompt:

Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.

A string is represented by an array if the array elements concatenated in order forms the string.

#### Solution:

    class Solution {
    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {

        StringBuilder sb1 = new StringBuilder();

        for ( String str : word1 ) sb1.append(str);
        StringBuilder sb2 = new StringBuilder();

        for ( String str : word2 ) sb2.append(str);
        
        return (sb1.toString().equals(sb2.toString()));
        
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.35 mb, beating 55.19% of leetcode users solutions using java.

#### Concepts Applied:

Strings, stringbuilder, boolean, and for loop.

### Solution Dec 2, 2023 (Java, leetcode) 1160. Find Words That Can Be Formed by Characters (Easy)
In .LeetcodeDailySolution folder as Dec2,2023.java

#### Prompt:

You are given an array of strings words and a string chars.

A string is good if it can be formed by characters from chars (each character can only be used once).

Return the sum of lengths of all good strings in words.

#### Solution:

    class Solution {
    public int countCharacters(String[] words, String chars) {
        int[] counts = new int[26];

        for(int i=0;i<chars.length();i++){
            counts[chars.charAt(i)-'a']++;
        }
        
        int res =0 ;

        for(String s : words)
        {
            if(canForm(s,counts))
                res+=s.length();
        }
        return res;
    }

    boolean canForm(String word, int[] counts){
        int[] c = new int[26];

        for(int i =0;i<word.length();i++)
        {
            int x = word.charAt(i)-'a';
            c[x]++;
            if(c[x] > counts[x])
                return false;
        }
        return true;
        }
    }

Runtime: 2 ms, beating 100% of leetcode users solutions using java.
Memory: 44.00 mb, beating 79.77% of leetcode users solutions using java.

#### Concepts Applied:

Strings, chars, charAt, for loops, and boolean.

### Solution Dec 3, 2023 (Java, leetcode) 1266. Minimum Time Visiting All Points (Easy)
In .LeetcodeDailySolution folder as Dec3,2023.java

#### Prompt:

On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.

You can move according to these rules:

In 1 second, you can either:
move vertically by one unit,
move horizontally by one unit, or
move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).
You have to visit the points in the same order as they appear in the array.
You are allowed to pass through points that appear later in the order, but these do not count as visits.

#### Solution:

    class Solution {
    public int toTime(int[] from, int[] to) {
        int xDiff = Math.abs(from[0] - to[0]);
        int yDiff = Math.abs(from[1] - to[1]);
        
        return Math.max(xDiff, yDiff);
    }
    
    public int minTimeToVisitAllPoints(int[][] points) {
        int time = 0;
    
        for (int i = 1; i < points.length; i++) {
            time += toTime(points[i - 1], points[i]);
        }
        return time;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.16 mb, beating 60.89% of leetcode users solutions using java.

#### Concepts Applied:

Math, and for loop.

### Solution Dec 4, 2023 (Java, leetcode) 2264. Largest 3-Same-Digit Number in String (Easy)
In .LeetcodeDailySolution folder as Dec4,2023.java

#### Prompt:

You are given a string num representing a large integer. An integer is good if it meets the following conditions:

It is a substring of num with length 3.
It consists of only one unique digit.
Return the maximum good integer as a string or an empty string "" if no such integer exists.

Note:

A substring is a contiguous sequence of characters within a string.
There may be leading zeroes in num or a good integer.

#### Solution:

    class Solution {
    public String largestGoodInteger(String num) {
        char maxDigit = '\0';

        for (int index = 0; index <= num.length() - 3; ++index) {
            if (num.charAt(index) == num.charAt(index + 1) && num.charAt(index) == num.charAt(index + 2)) {
                maxDigit = (char) Math.max(maxDigit, num.charAt(index));
            }
        }

        return maxDigit == '\0' ? "" : new String(new char[]{maxDigit, maxDigit, maxDigit});
        }
    }

Runtime: 2 ms, beating 80.42% of leetcode users solutions using java.
Memory: 40.70 mb, beating 82.25% of leetcode users solutions using java.

#### Concepts Applied:

Char, charAt, for loop, index, and if statement.

### Solution Dec 5, 2023 (Java, leetcode) 1688. Count of Matches in Tournament (Easy)
In .LeetcodeDailySolution folder as Dec5,2023.java

#### Prompt:

You are given an integer n, the number of teams in a tournament that has strange rules:

If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.
If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.
Return the number of matches played in the tournament until a winner is decided.

#### Solution:

    class Solution {
    public int numberOfMatches(int n) {
        
        return n - 1;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 39.16 mb, beating 61.47% of leetcode users solutions using java.

#### Concepts Applied:

If after each match one team needs to be eliminated, n-1 satisfies all conditions. 

### Solution Dec 6, 2023 (Java, leetcode) 1716. Calculate Money in Leetcode Bank (Easy)
In .LeetcodeDailySolution folder as Dec6,2023.java

#### Prompt:

Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.

He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday.
Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.

#### Solution:

    class Solution {
    public int totalMoney(int n) {
        int total = 0;

        for (int day = 0; day < n; day++) {
            total += (day / 7 + 1) + (day % 7);
        }

        return total;        
        }
    }

Runtime: 1 ms, beating 60.52% of leetcode users solutions using java.
Memory: 39.10 mb, beating 67.38% of leetcode users solutions using java.

#### Concepts Applied:

For loop and simple calculations.

### Solution Dec 7, 2023 (Java, leetcode) 1903. Largest Odd Number in String (Easy)
In .LeetcodeDailySolution folder as Dec7,2023.java

#### Prompt:

You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string "" if no odd integer exists.

A substring is a contiguous sequence of characters within a string.

#### Solution:

    class Solution {
    public String largestOddNumber(String num) {

        for(int i=num.length()-1; i>=0; i--){
            if((num.charAt(i)-'0')%2==1)  
            return num.substring(0,i+1);
        }
        return "";
        }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java.
Memory: 44.19 mb, beating 94% of leetcode users solutions using java.

#### Concepts Applied:

Strings, for loop, if statement, charAt, and substring.

### Solution Dec 8, 2023 (Java, leetcode) 606. Construct String from Binary Tree (Easy)
In .LeetcodeDailySolution folder as Dec8,2023.java

#### Prompt:

Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.

Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.

#### Solution:

    class Solution {
    public String tree2str(TreeNode t) {
        StringBuilder res = new StringBuilder();
        dfs(t, res);
        return res.toString();
    }
    public static void dfs(TreeNode t, StringBuilder res) {
        if (t == null)
            return;

        res.append(String.valueOf(t.val));
        if (t.left == null && t.right == null)
            return;

        res.append('(');
        dfs(t.left, res);
        res.append(')');
        
        if (t.right != null) {
            res.append('(');
            dfs(t.right, res);
            res.append(')');
            }
        }
    }

Runtime: 1 ms, beating 100% of leetcode users solutions using java.
Memory: 43.30 mb, beating 86.73% of leetcode users solutions using java.

#### Concepts Applied:

StringBuilder, strings, dfs, and if statements.

### Solution Dec 9, 2023 (Java, leetcode) 94. Binary Tree Inorder Traversal (Easy)
In .LeetcodeDailySolution folder as Dec9,2023.java

#### Prompt:

Given the root of a binary tree, return the inorder traversal of its nodes' values.

#### Solution:

    class Solution {
    List<Integer> ans = new ArrayList<>();
        public List<Integer> inorderTraversal(TreeNode root) {

        if (root == null) return Collections.emptyList();

        inorderTraversal(root.left);
        ans.add(root.val);
        inorderTraversal(root.right);

        return ans;
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 40.30 mb, beating 92.99% of leetcode users solutions using java.

#### Concepts Applied:

Lists, ArrayList, inorderTraversal, and TreeNode.

### Solution Dec 10, 2023 (Java, leetcode) 867. Transpose Matrix (Easy)
In .LeetcodeDailySolution folder as Dec10,2023.java

#### Prompt:

Given a 2D integer array matrix, return the transpose of matrix.

The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/05c43a56-2bf7-4781-95a2-c061ad8608cd)

#### Solution:

    class Solution {
    public int[][] transpose(int[][] matrix) {
        int row=matrix.length;
        int col=matrix[0].length;
        int arr[][]=new int[col][row];
    
        for(int i=0;i<col;i++){
            for(int j=0;j<row;j++){
            arr[i][j]=matrix[j][i];
            }
        }
        return arr;
        }
    }   

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 43.88 mb, beating 97.49% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, row, col, arr, and for loop. 

### Solution Dec 11, 2023 (Java, leetcode) 1287. Element Appearing More Than 25% In Sorted Array (Easy)
In .LeetcodeDailySolution folder as Dec11,2023.java

#### Prompt:

Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.

#### Solution:

    class Solution {
    public int findSpecialInteger(int[] arr) {
        int size = arr.length;
        int qtr = size / 4;
        int cnt = 1;
        int p = arr[0];

        for (int i = 1 ; i < arr.length ; i++) {
            if ( p == arr[i]) cnt++;
            else cnt = 1;
            if (cnt > qtr) return arr[i];
            p = arr[i];
        }
        return p;
        }
    }

Runtime: 1 ms, beating 64.27% of leetcode users solutions using java.
Memory: 43.13 mb, beating 72.62% of leetcode users solutions using java.

#### Concepts Applied:

arr, for loop, else statement, and if statement.

### Solution Dec 12, 2023 (Java, leetcode) 1464. Maximum Product of Two Elements in an Array (Easy)
In .LeetcodeDailySolution folder as Dec12,2023.java

#### Prompt:

Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).

#### Solution:

    class Solution {
    public int maxProduct(int[] nums) {
        int firstMax = 0;
        int secondMax = 0;

        for (int num : nums) {
            if (num > firstMax) {
                secondMax = firstMax;
                firstMax = num;
            } else {
                secondMax = Math.max(secondMax, num);
            }
        }
        return (firstMax - 1) * (secondMax - 1);        
        }
    }

Runtime: 1 ms, beating 78.60% of leetcode users solutions using java.
Memory: 41.46 mb, beating 71.33% of leetcode users solutions using java.

#### Concepts Applied:

For loop, if statement, else statement, and Math.

### Solution Dec 13, 2023 (Java, leetcode) 1582. Special Positions in a Binary Matrix (Easy)
In .LeetcodeDailySolution folder as Dec13,2023.java

#### Prompt:

Given an m x n binary matrix mat, return the number of special positions in mat.

A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).

#### Solution:

    class Solution {
    public int numSpecial(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        int[] rowCount = new int[m];
        int[] colCount = new int[n];
        
        for (int row = 0; row < m; row++) {
            for (int col = 0; col < n; col++) {
                if (mat[row][col] == 1) {
                    rowCount[row]++;
                    colCount[col]++;
                }
            }
        }
        int ans = 0;
        for (int row = 0; row < m; row++) {
            for (int col = 0; col < n; col++) {
                if (mat[row][col] == 1) {
                    if (rowCount[row] == 1 && colCount[col] == 1) {
                        ans++;
                    }
                }
            }
        }
        return ans;
        }
    }

Runtime: 2 ms, beating 89.24% of leetcode users solutions using java.
Memory: 43.70 mb, beating 75.07% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, row, col, for loops, and if statements.

### Solution Dec 14, 2023 (Java, leetcode) 2482. Difference Between Ones and Zeros in Row and Column (Medium)
In .LeetcodeDailySolution folder as Dec14,2023.java

#### Prompt:

You are given a 0-indexed m x n binary matrix grid.

A 0-indexed m x n difference matrix diff is created with the following procedure:

Let the number of ones in the ith row be onesRowi.
Let the number of ones in the jth column be onesColj.
Let the number of zeros in the ith row be zerosRowi.
Let the number of zeros in the jth column be zerosColj.
diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
Return the difference matrix diff.

#### Solution:

    class Solution {
    public int[][] onesMinusZeros(int[][] grid) {
        int row = grid.length; 
        int col = grid[0].length;
        int[][] diff = new int[row][col];
        int[] r = new int[row]; 
        int[] c = new int[col]; 

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                r[i] += grid[i][j]; 
                c[j] += grid[i][j];
            }
        }
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                diff[i][j] = 2 * (r[i] + c[j]) - row - col;
            }
        }
        return diff; 
        }
    }

Runtime: 9 ms, beating 70.09% of leetcode users solutions using java.
Memory: 71.60 mb, beating 64.84% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, row, col, grid, and for loops.

### Solution Dec 15, 2023 (Java, leetcode) 1436. Destination City (Easy)
In .LeetcodeDailySolution folder as Dec15,2023.java

#### Prompt:

You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.

It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.

#### Solution:

    class Solution {
    public String destCity(List<List<String>> paths) {
        Set<String> cities = new HashSet<>(); 
        for (List<String> path : paths) {
            cities.add(path.get(0)); 
        }
        
        for (List<String> path : paths) {
            String dest = path.get(1); 
            if (!cities.contains(dest)) {
                return dest; 
            }
        }
        return "";
        }
    }

Runtime: 2 ms, beating 79.16% of leetcode users solutions using java.
Memory: 42.93 mb, beating 60.20% of leetcode users solutions using java.

#### Concepts Applied:

List, Set, HashSet, for loops, and if statement.

### Solution Dec 16, 2023 (Java, leetcode) 241. Valid Anagram (Easy)
In .LeetcodeDailySolution folder Dec16,2023.java

#### Prompt:

Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

#### Solution:

    class Solution {
    public boolean isAnagram(String s, String t) {
        int[] count = new int[26];

        if (s.length() != t.length()) {
            return false;
        }
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a'] += 1;
        }
        for (int i = 0; i < t.length(); i++) {
            if (count[t.charAt(i) - 'a'] == 0) {
                return false;
            }
            count[t.charAt(i) - 'a'] -= 1;
        }
        return true;        
        }
    }

Runtime: 4 ms, beating 73.09% of leetcode users solutions using java.
Memory: 42.18 mb, beating 78.86% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, strings, if statements, for loops, and charAt.

### Solution Dec 17, 2023 (Java, leetcode) 2353. Design a Food Rating System (Medium)
In .LeetcodeDailySolution folder as Dec17,2023.java

#### Prompt:

Design a food rating system that can do the following:

Modify the rating of a food item listed in the system.
Return the highest-rated food item for a type of cuisine in the system.
Implement the FoodRatings class:

FoodRatings(String[] foods, String[] cuisines, int[] ratings) Initializes the system. The food items are described by foods, cuisines and ratings, all of which have a length of n.
foods[i] is the name of the ith food,
cuisines[i] is the type of cuisine of the ith food, and
ratings[i] is the initial rating of the ith food.
void changeRating(String food, int newRating) Changes the rating of the food item with the name food.
String highestRated(String cuisine) Returns the name of the food item that has the highest rating for the given type of cuisine. If there is a tie, return the item with the lexicographically smaller name.
Note that a string x is lexicographically smaller than string y if x comes before y in dictionary order, that is, either x is a prefix of y, or if i is the first position such that x[i] != y[i], then x[i] comes before y[i] in alphabetic order.

#### Solution:

    class Food implements Comparable<Food> {
    public int foodRating;
    public String foodName;
    public Food(int foodRating, String foodName) {
        this.foodRating = foodRating;
        this.foodName = foodName;
    }
    @Override
    public int compareTo(Food other) {
        if (foodRating == other.foodRating) {
            return foodName.compareTo(other.foodName);
        }
        return -1 * Integer.compare(foodRating, other.foodRating);
        }
    }
    class FoodRatings {
    private Map<String, Integer> foodRatingMap;
    private Map<String, String> foodCuisineMap;
    private Map<String, PriorityQueue<Food>> cuisineFoodMap;

    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
        foodRatingMap = new HashMap<>();
        foodCuisineMap = new HashMap<>();
        cuisineFoodMap = new HashMap<>();

        for (int i = 0; i < foods.length; ++i) {

            foodRatingMap.put(foods[i], ratings[i]);
            foodCuisineMap.put(foods[i], cuisines[i]);
            cuisineFoodMap.computeIfAbsent(cuisines[i], k -> new PriorityQueue<>()).add(new Food(ratings[i] , foods[i]));
        }
    } 
    public void changeRating(String food, int newRating) {
        foodRatingMap.put(food, newRating);
        String cuisineName = foodCuisineMap.get(food);
        cuisineFoodMap.get(cuisineName).add(new Food(newRating, food));
    }
    public String highestRated(String cuisine) {
        Food highestRated = cuisineFoodMap.get(cuisine).peek();

        while (foodRatingMap.get(highestRated.foodName) != highestRated.foodRating) {
            cuisineFoodMap.get(cuisine).poll();
            highestRated = cuisineFoodMap.get(cuisine).peek();
        }        
        return highestRated.foodName;
        }
    }

Runtime: 157 ms, beating 93.68% of leetcode users solutions using java.
Memory: 68.66 mb, beating 95.40% of leetcode users solutions using java.

#### Concepts Applied:

Maps, overriding, strings, HashMaps, if statement, for loops, and while loop.

### Solution Dec 18, 2023 (Java, leetcode) 1913. Maximum Product Difference Between Two Pairs (Easy)
In .LeetcodeDailySolution folder as Dec18,2023.java

#### Prompt:

The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).

For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.

Return the maximum such product difference.

#### Solution:

    class Solution {
    public int maxProductDifference(int[] nums) {
        int firstBig = 0, secondBig = 0;
        int firstSmall = Integer.MAX_VALUE, secondSmall = Integer.MAX_VALUE;

        for (int n : nums) {
            if (n < firstSmall) {
                secondSmall = firstSmall;
                firstSmall = n;
            } else if (n < secondSmall) {
                secondSmall = n;
            }
            if (n > firstBig) {
                secondBig = firstBig;
                firstBig = n;
            } else if (n > secondBig) {
                secondBig = n;
            }
        }
        return firstBig * secondBig - firstSmall * secondSmall;        
        }
    }

Runtime: 2 ms, beating 97.52% of leetcode users solutions using java.
Memory: 44.11 mb, beating 55.36% of leetcode users solutions using java.

#### Concepts Applied:

For loops, if statements, else-if statements, and integer pairs.

### Solution Dec 19, 2023 (Java, leetcode) 661. Image Smoother 
In .LeetcodeDailySolution folder as Dec19,2023.java

#### Prompt:

An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/80c006ea-91de-46dc-abc7-2d79623dd15f)

Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.

#### Solution:

    class Solution {
    public int[][] imageSmoother(int[][] img) {
        int rows = img.length;
        int cols = img[0].length;
        int[][] result = new int[rows][cols];

        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                int totalSum = 0;
                int count = 0;

                for (int x = Math.max(0, i-1); x < Math.min(rows, i+2); ++x) {
                    for (int y = Math.max(0, j-1); y < Math.min(cols, j+2); ++y) {
                        totalSum += img[x][y];
                        count += 1;
                    }
                }
                result[i][j] = totalSum / count;
            }
        }
        return result;
        }
    }

Runtime: 6 ms, beating 80% of leetcode users solutions using java.
Memory: 44.46 mb, beating 71.94% of leetcode users solutions using java.

#### Concepts Applied:

Matrix, rows, cols, for loops, and Math.

### Solution Dec 20, 2023 (Java, leetcode) 2706. Buy Two Chocolates (Easy)
In .LeetcodeDailySolution folder as Dec20,2023.java

#### Prompt:

You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.

You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.

Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.

#### Solution:

    class Solution {
    public int buyChoco(int[] prices, int money) {
        Arrays.sort(prices);
        int minCost = prices[0] + prices[1];

        if (minCost <= money) {
            return money - minCost;
        }
        return money;
        }
    }

Runtime: 2 ms, beating 79% of leetcode users solutions using java.
Memory: 44.49 mb, beating 5.58% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, and if statement.

### Solution Dec 21, 2023 (Java, leetcode) 1637. Widest Vertical Area Between Two Points Containing No Points (Medium)
In .LeetcodeDailySolution folder as Dec21,2023.java

#### Prompt:

Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.

A vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.

Note that points on the edge of a vertical area are not considered included in the area.

#### Solution:

    class Solution {
    public int maxWidthOfVerticalArea(int[][] points) {
        int[] X = new int[points.length];
        
        for (int i = 0; i < points.length; i++) {
            X[i] = points[i][0];
        }
        Arrays.sort(X);

        int maxWidth = 0;

        for (int i = 1; i < X.length; i++) {
            int width = X[i] - X[i - 1];

            if (width > maxWidth) {
                maxWidth = width;
            }
        }
        return maxWidth;
        }
    }

Runtime: 13 ms, beating 98.07% of leetcode users solutions using java. 
Memory: 72.73 mb, beating 5.41% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, for loops, and if statement.

### Solution Dec 22, 2023 (Java, leetcode) 1422. Maximum Score After Splitting a String (Easy)
In .LeetcodeDailySolution folder as Dec22,2023.java

#### Prompt:

Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).

The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.

#### Solution:

    class Solution {
    public int maxScore(String s) {
        int left = -1;
        int zeros = 0;
        int ones = 0;

        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) == '0') {
                zeros++;
            } else {
                ones++;
            }
            left = Math.max(left, zeros - ones);
        }
        if (s.charAt(s.length() - 1) == '1') {
            ones += 1;
        }
        return left + ones;       
        }
    }

Runtime: 1 ms, beating 97.83% of leetcode users solutions using java.
Memory: 41.36 mb, beating 34.35% of leetcode users solutions using java.

#### Concepts Applied:

For loops, charAt, strings, Math, else statement, and if statements. 

### Solution Dec 23, 2023 (Java, leetcode) 1496. Path Crossing (Easy)
In .LeetcodeDailySolution folder as Dec23,2023.java

#### Prompt:

Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.

Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.

#### Solution:

    class Solution {
    public boolean isPathCrossing(String path) {
        Map<Character, Pair<Integer, Integer>> moves = new HashMap();
        moves.put('N', new Pair(0, 1));
        moves.put('S', new Pair(0, -1));
        moves.put('W', new Pair(-1, 0));
        moves.put('E', new Pair(1, 0));
        
        Set<Pair<Integer, Integer>> visited = new HashSet();
        visited.add(new Pair(0, 0));
        
        int x = 0;
        int y = 0;
        
        for (Character c : path.toCharArray()) {
            Pair<Integer, Integer> curr = moves.get(c);
            int dx = curr.getKey();
            int dy = curr.getValue();
            x += dx;
            y += dy;
            
            Pair<Integer, Integer> pair = new Pair(x, y);
            
            if (visited.contains(pair)) {
                return true;
            }
            visited.add(pair);
        }
        return false;
        }
    }

Runtime: 1 ms, beating 96.48% of leetcode users solutions using java.
Memory: 42.31 mb, beating 5.29% of leetcode users solutions using java.

#### Concepts Applied:

Map, HashMap, Set, HashSet, Pairs, for loop, and if statement. 

### Solution Dec 24, 2023 (Java, leetcode) 1758. Minimum Charges To Make Alternating Binary String (Easy)
In .LeetcodeDailySolution folder as Dec24,2023.java

#### Prompt:

You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.

The string is called alternating if no two adjacent characters are equal. For example, the string "010" is alternating, while the string "0100" is not.

Return the minimum number of operations needed to make s alternating.

#### Solution:

    class Solution {
    public int minOperations(String s) {
        int n = s.length(), count = 0;

        if (n == 1) return 0;
        
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0 && s.charAt(i) == '1') count++;
            if (i % 2 == 1 && s.charAt(i) == '0') count++;
        }
        return Math.min(count, n - count); 
        }
    }

Runtime: 3 ms, beating 91.88% of leetcode users solutions using java.
Memory: 42.29 mb, beating 10.06% of leetcode users solutions using java.

#### Concepts Applied:

If statements, for loop, charAt, strings, and Math.

### Solution Dec 25, 2023 (Java, leetcode) 91. Decode Ways (Medium)
In .LeetcodeDailySolution folder as Dec25,2023.java 

#### Prompt:

A message containing letters from A-Z can be encoded into numbers using the following mapping:

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, "11106" can be mapped into:

"AAJF" with the grouping (1 1 10 6)
"KJF" with the grouping (11 10 6)
Note that the grouping (1 11 06) is invalid because "06" cannot be mapped into 'F' since "6" is different from "06".

Given a string s containing only digits, return the number of ways to decode it.

The test cases are generated so that the answer fits in a 32-bit integer.

#### Solution:

    class Solution {
    public int numDecodings(String s) {
        int n=s.length();
        int[] dp=new int[n+1];

        dp[n]=1 ;

        for(int i = n-1 ; i >= 0 ; i--)
            if(s.charAt(i)!='0') {

                dp[i] = dp[i+1] ;
                
                if(i < n-1 && (s.charAt(i)=='1' || s.charAt(i)=='2' && s.charAt(i+1)<'7')) 
				    dp[i]+=dp[i+2];
            }
        return dp[0];   
        }
    }

Runtime: 0 ms, beating 100% of leetcode users solutions using java.
Memory: 41.78 mb, beating 10.62% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming, for loop, if statements, and charAt.

### Solution Dec 26, 2023 (Java, leetcode) 1155. Number of Dice Rolls With Target Sum (Medium)
In .LeetcodeDailySolution folder as Dec26,2023.java

#### Prompt:

You have n dice, and each die has k faces numbered from 1 to k.

Given three integers n, k, and target, return the number of possible ways (out of the kn total ways) to roll the dice, so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public int numRollsToTarget(int d, int f, int target) {
        final int mod = 1000000007;

        int[] dp1 = new int[target + 1];  
        int[] dp2 = new int[target + 1];  

        dp1[0] = 1;

        for (int i = 1; i <= d; ++i) {

            int prev = dp1[0];  

            for (int j = 1; j <= target; ++j) {
                dp2[j] = prev; 
                prev = (int) ((prev + dp1[j]) % mod);

                if (j >= f) prev = (int) ((prev - dp1[j - f] + mod) % mod);
            }
            int[] temp = dp1;
            dp1 = dp2;
            dp2 = temp;
            dp2[0] = 0;
        }
        return dp1[target];
    	}
    }

Runtime: 5 ms, beating 94.68% of leetcode users solutions using java.
Memory: 40.54 mb, beating 78.19% of leetcode users solutions using java.

#### Concepts Applied:

Modulo, dynamic programming, for loops, and if statements.

### Solution Dec 27, 2023 (Java, leetcode) 1578. Minimum Time to Make Rope Colorful (Medium)
In .LeetcodeDailySolution folder as Dec27,2023.java

#### Prompt:

Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.

Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.

Return the minimum time Bob needs to make the rope colorful.

#### Solution:

    class Solution {
    public int minCost(String colors, int[] neededTime) {
        int time = 0;
        int n = colors.length();

        for (int i = 1; i < n; i++) {
            if (colors.charAt(i) == colors.charAt(i - 1)) {
                time += Math.min(neededTime[i], neededTime[i - 1]);
                neededTime[i] = Math.max(neededTime[i], neededTime[i - 1]);
           }
        }      
        return time;
   	}
    }

Runtime: 7 ms, beating 89.50% of leetcode users solutions using java.
Memory: 60.46 mb, beating 21.50% of leetcode users solutions using java.

#### Concepts Applied:

For loop, if statement, charAt, and Math.

### Solution Dec 28, 2023 (Java, leetcode) 1531. String Compression II (Hard)
In .LeetcodeDailySolution folder as Dec28,2023.java

#### Prompt:

Run-length encoding is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string "aabccc" we replace "aa" by "a2" and replace "ccc" by "c3". Thus the compressed string becomes "a2bc3".

Notice that in this problem, we are not adding '1' after single characters.

Given a string s and an integer k. You need to delete at most k characters from s such that the run-length encoded version of s has minimum length.

Find the minimum length of the run-length encoded version of s after deleting at most k characters.

#### Solution:

    class Solution {
    private int[][] memo = new int[101][101];
    private int recursion(String s, int i, int K) {
        int n = s.length();
        int k = K;

        if (n - i <= k) {
            return 0;
        }
        if (memo[i][k] != -1) {
            return memo[i][k];
        }
        int ans = k > 0 ? recursion(s, i + 1, k - 1) : 101;
        int c = 1;
        
        for (int j = i + 1; j <= n; j++) {

            ans = Math.min(ans, 1 + ((c > 99) ? 3 : (c > 9) ? 2 : (c > 1) ? 1 : 0) + 		recursion(s, j, k));

            if (j < n && s.charAt(i) == s.charAt(j)) {
                c++;
            } else if (--k < 0) {
                break;
            }
        }
        return memo[i][K] = ans;
    }
    public int getLengthOfOptimalCompression(String s, int k) {
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
        return recursion(s, 0, k);
      }
    }

Runtime: 42 ms, beating 73.33% of leetcode users solutions using java.
Memory: 42.29 mb, beating 51.11% of leetcode users solutions using java.

#### Concepts Applied:

Recursion, Math, charAt, if statements, for loops, else if statement, and Arrays.

### Solution Dec 29, 2023 (Java, leetcode) 1335. Minimum Difficulty of a Job Schedule (Hard)
In .LeetcodeDailySolution folder as Dec29,2023.java

#### Prompt:

You want to schedule a list of jobs in d days. Jobs are dependent (i.e To work on the ith job, you have to finish all the jobs j where 0 <= j < i).

You have to finish at least one task every day. The difficulty of a job schedule is the sum of difficulties of each day of the d days. The difficulty of a day is the maximum difficulty of a job done on that day.

You are given an integer array jobDifficulty and an integer d. The difficulty of the ith job is jobDifficulty[i].

Return the minimum difficulty of a job schedule. If you cannot find a schedule for the jobs return -1.

#### Solution:

    class Solution {
    public int minDifficulty(int[] jobDifficulty, int d){
        int jobs = jobDifficulty.length;
        
        if (jobs < d)
            return -1;

        int[][] dp = new int[d][jobs];

        dp[0][0] = jobDifficulty[0];
        
        for (int i = 1; i < jobs; i++)
            dp[0][i] = Math.max(dp[0][i - 1], jobDifficulty[i]);

        
        for (int days = 1; days < d; days++) {

            for (int i = days; i < jobs; i++) {
                int localMax = jobDifficulty[i];
                dp[days][i] = Integer.MAX_VALUE; 
                
                for (int j = i; j >= days; j--) {
                    localMax = Math.max(localMax, jobDifficulty[j]);
                    dp[days][i] = Math.min(dp[days][i], dp[days - 1][j - 1] + localMax);
                }
            }
        }
        return dp[d - 1][jobs - 1];
      }
    }

Runtime: 12 ms, beating 30.93% of leetcode users solutions using java.
Memory: 41.31 mb, beating 18.97% of leetcode users solutions using java.

#### Concepts Applied:

Dynamic programming, Math, for loops, and if statement.

### Solution Dec 30, 2023 (Java, leetcode) 1897. Redistribute Characters to Make All Strings Equal (Easy)
In .LeetcodeDailySolution folder as Dec30,2023.java

#### Prompt:

You are given an array of strings words (0-indexed).

In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j].

Return true if you can make every string in words equal using any number of operations, and false otherwise.

#### Solution:

    class Solution {
    public boolean makeEqual(String[] words) {
        int[] counts = new int[26];

        for (String word : words) {
            for (char c : word.toCharArray()) {
                counts[c - 'a']++;
            }
        }
        int n = words.length;

        for (int val : counts) {
            if (val % n != 0) {
                return false;
            }
        }
        return true;
      }
    }

Runtime: 3 ms, beating 58.96% of leetcode users solutions using java.
Memory: 44.12 mb, beating 6.64% of leetcode users solutions using java.

#### Concepts Applied:

Boolean, for loops, CharArray, and if statement.

### Solution Dec 31, 2023 (Java, leetcode) 1624. Largest Substring Between Two Equal Points (Easy)
In .LeetcodeDailySolution folder as Dec31,2023.java

#### Prompt:

Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.

A substring is a contiguous sequence of characters within a string.

#### Solution:

    class Solution {
    public int maxLengthBetweenEqualCharacters(String s) {
    int maxDistance = -1;
    
    for (int i = 0; i < s.length() - 1; i++) {
        for (int j = s.length() - 1; j > i; j--) {
            if (s.charAt(i) == s.charAt(j)) {
                maxDistance = Math.max(maxDistance, j - i - 1);
                break;
            }
        }
    }
 	return maxDistance;
      }
    }

Runtime: 4 ms, beating 32.42% of leetcode users solutions using java.
Memory: 41.35 mb, beating 13.97% of leetcode users solutions using java.

#### Concepts Applied:

For loops, if statement, charAt, and Math.

### Solution Jan 1, 2024 (Java, leetcode) 455. Assign Cookies (Easy)
In .LeetcodeDailySolution folder as Jan1,2024.java

#### Prompt:

Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.

Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.

#### Solution:

    class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);

        int i = 0;

        for(int j=0;i<g.length && j<s.length;j++)
	        if(g[i]<=s[j]) i++;
            
        return i;
      }
    }

Runtime: 8 ms, beating 98.87% of leetcode users solutions using java.
Memory: 44.91 mb, beating 28.82% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, and for loop.

### Solution Jan 2, 2024 (Java, leetcode) 2610. Convert an Array Into a 2D Array (Medium)
In .LeetcodeDailySolution folder as Jan2,2024.java

#### Prompt:

You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:

The 2D array should contain only the elements of the array nums.
Each row in the 2D array contains distinct integers.
The number of rows in the 2D array should be minimal.
Return the resulting array. If there are multiple answers, return any of them.

Note that the 2D array can have a different number of elements on each row.

#### Solution:

    class Solution {
    public List<List<Integer>> findMatrix(int[] nums) {
    int n = nums.length;

    Arrays.sort(nums);

    List<List<Integer>> ans = new ArrayList<>();
    int k = 0;

    for(int i = 0; i < n; i++){
        if(ans.size() <= k) ans.add(new ArrayList<>());
        ans.get(k).add(nums[i]);
        if(i+1 < n && nums[i] != nums[i+1])  k=0;
        else k++;
        }
    return ans;
      }
    }

Runtime: 4 ms, beating 55.24% of leetcode users solution using java.
Memory: 45.13 mb, beating 10.26% of leetcode users solutions using java.

#### Concepts Applied:

Arrays, sorting, List, ArrayList, matrix, for loop, if statements, and else statement.

### Solution Jan 3, 2024 (Java, leetcode) 2125. Number of Laser Beams in a Bank (Medium)
In .LeetcodeDailySolution folder as Jan3,2024.java

#### Prompt:

Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.

There is one laser beam between any two security devices if both conditions are met:

The two devices are located on two different rows: r1 and r2, where r1 < r2.
For each row i where r1 < i < r2, there are no security devices in the ith row.
Laser beams are independent, i.e., one beam does not interfere nor join with another.

Return the total number of laser beams in the bank.

#### Solution: 

    class Solution {
    public int numberOfBeams(String[] bank) {

        if (bank.length < 2) {
            return 0;
        }
        int solution = 0;
        int beaconsInPrevRow = 0;
        int beaconsInCurrentRow = 0;

        for (String row : bank) {
            beaconsInCurrentRow = 0;

            for (char c : row.toCharArray()) {
                if (c == '1') {
                    beaconsInCurrentRow++;
                }
            }
            solution += beaconsInCurrentRow * beaconsInPrevRow;
            beaconsInPrevRow = beaconsInCurrentRow == 0 ? beaconsInPrevRow : beaconsInCurrentRow;
        }
        return solution;
      }
    }

Runtime: 11 ms, beating 91.49% of leetcode users solutions using java.
Memory: 44.89 mb, beating 33.27% of leetcode users solutions using java.

#### Concepts Applied:

If statements, for loops, strings, matrix, and charArray.

## Made a switch to C++ for all future solutions

### Solution Jan 4, 2024 (C++, leetcode) 2870. Minimum Number of Operations to Make Array Empty (Medium)
In .LeetcodeDailySolution folder as Jan4,2024.cpp

#### Prompt:

You are given a 0-indexed array nums consisting of positive integers.

There are two types of operations that you can apply on the array any number of times:

Choose two elements with equal values and delete them from the array.
Choose three elements with equal values and delete them from the array.
Return the minimum number of operations required to make the array empty, or -1 if it is not possible.

#### Solution:

    class Solution {
    public:
    int minOperations(vector<int>& nums) {
        int ans = 0;

        unordered_map<int, int> freq;
        for(auto n: nums) freq[n]++;
        for(auto [k,f]: freq){
            if(f == 1) return -1;
            ans += f/3 + (f%3 + 1)/2;
        }
        return ans;
      }
    };

Runtime: 122 ms, beating 56.03% of leetcode users solutions using C++.
Memory: 85.06 mb, beating 89.98% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays (vector), unordered map, for loops, and if statement.

### Solution Jan 5, 2024 (C++, leetcode) 300. Longest Increasing Subsequence (Medium)
In .LeetcodeDailySolution folder as Jan5,2024.cpp

#### Prompt:

Given an integer array nums, return the length of the longest strictly increasing 
subsequence.

#### Solution:

    class Solution {
    public:
    int lengthOfLIS(std::vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        int n = nums.size();
        std::vector<int> dp(n, 1);

        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                if (nums[i] > nums[j]) {
                    dp[i] = std::max(dp[i], dp[j] + 1);
                }
            }
        }
        return *std::max_element(dp.begin(), dp.end());
      }
    };

Runtime: 243 ms, beating 52.49% of leetcode users solutions C++.
Memory: 10.87 mb, beating 62.25% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, if statements, dynamic programming, and for loops.

### Solution Jan 6, 2024 (C++, leetcode) 1235. Maximum Profit in Job Scheduling (Hard)
In .LeetcodeDailySolution folder as Jan6,2024.cpp

#### Prompt:

We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].

You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time X you will be able to start another job that starts at time X.

#### Solution:

    class Solution {
    public:
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        const int n = startTime.size();

        vector<vector<int>> jobs(n);

        for (int i = 0; i < n; i++) jobs[i] = {endTime[i], startTime[i], profit[i]};
        sort(jobs.begin(), jobs.end());

        map<int, int> dp = {{0, 0}};
        
        for (auto& job : jobs) {
            int profit = prev(dp.upper_bound(job[1]))->second + job[2];
            if (profit > dp.rbegin()->second) dp[job[0]] = profit;
        }
        return dp.rbegin()->second;
      }
    };

Runtime: 187 ms, beating 58.92% of leetcode users solutions using C++.
Memory: 75.94 mb, beating 57.04% of leetcode users solutions using C++.

#### Concepts Applied:

Hash table, dynamic programming, for loops, sorting, map, and if statement.

### Solution Jan 7, 2024 (C++, leetcode) 446. Arithmetic Slices II - Subsequence (Hard)
In .LeetcodeDailySolution folder as Jan7,2024.cpp

#### Prompt:

Given an integer array nums, return the number of all the arithmetic subsequences of nums.

A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.

For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.
For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.
A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.

For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].
The test cases are generated so that the answer fits in 32-bit integer.

#### Solution:

    class Solution {
    public:
    int numberOfArithmeticSlices(std::vector<int>& nums) {
        int n = nums.size();
        int total_count = 0;

        std::vector<std::unordered_map<int, int>> dp(n);

        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) {

                long long diff = static_cast<long long>(nums[i]) - nums[j]; 

                if (diff > INT_MAX || diff < INT_MIN)
                    continue; 

                int diff_int = static_cast<int>(diff);

                dp[i][diff_int] += 1; 

                if (dp[j].count(diff_int)) {
                    dp[i][diff_int] += dp[j][diff_int];
                    total_count += dp[j][diff_int];
                }
            }
        }
        return total_count;
      }
    };

Runtime: 411 ms, beating 75.28% of leetcode users solutions using C++.
Memory: 109.88 mb, beating 73.33% of leetcode users solutions using C++.

#### Concepts Applied:

Vector, unordered map, for loops, if statements, and dynamic programming.

### Solution Jan 8, 2024 (C++, leetcode) 938. Range Sum of BST (Easy)
In .LeetcodeDailySolution folder as Jan8,2024.cpp

#### Prompt:

Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].

#### Solution:

    class Solution {
    public:
    int rangeSumBST(TreeNode* root, int low, int high) {

        if (!root) {
            return 0;
        }
        int currentVal = (root->val >= low && root->val <= high) ? root->val : 0;
        int leftSum = rangeSumBST(root->left, low, high);
        int rightSum = rangeSumBST(root->right, low, high);

        return currentVal + leftSum + rightSum;
      }
    };

Runtime: 92 ms, beating 79.17% of leetcode users solutions using C++.
Memory: 64.95 mb, beating 51.83% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search tree, tree, binary tree, and depth-first-search.

### Solution Jan 9, 2024 (C++, leetcode) 872. Leaf-Similar Trees (Easy)
In .LeetcodeDailySolution folder as Jan9,2024.cpp

#### Prompt:

Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.

![image](https://github.com/Sshahryar/Leetcode/assets/123003299/44e59039-7152-4bac-a956-623595860368)

For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).

Two binary trees are considered leaf-similar if their leaf value sequence is the same.

Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.

#### Solution:

    class Solution {
    public:
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {

        function<void(TreeNode*, vector<int>&)> collectLeafValues =
            [&](TreeNode* root, vector<int>& leafValues) {

                if (!root) {
                    return;
                }
                if (!root->left && !root->right) {
                    leafValues.push_back(root->val);
                }
                collectLeafValues(root->left, leafValues);
                collectLeafValues(root->right, leafValues);
            };
        vector<int> leafValues1, leafValues2;

        collectLeafValues(root1, leafValues1);
        collectLeafValues(root2, leafValues2);

        return leafValues1 == leafValues2;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.91 mb, beating 8.99% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, Depth-First-Search, and binary tree.

### Solution Jan 10, 2024 (C++, leetcode) 2385. Amount of Time for Binary Tree to Be Infected (Medium)
In .LeetcodeDailySolution folder as Jan10,2024.cpp

#### Prompt:

You are given the root of a binary tree with unique values, and an integer start. At minute 0, an infection starts from the node with value start.

Each minute, a node becomes infected if:

The node is currently uninfected.
The node is adjacent to an infected node.
Return the number of minutes needed for the entire tree to be infected.

#### Solution:

    class Solution {
    public:
    int result;
    int amountOfTime(TreeNode* root, int start) {
        DFS(root, start);
        return result;
    }
    int DFS(TreeNode* node, int start){
        if(node == NULL) return 0;

        int leftDepth = DFS(node->left, start);
        int rightDepth = DFS(node->right, start);

        if(node->val == start){
            result = std::max(leftDepth, rightDepth);
            return -1;
        }
        else if(leftDepth >= 0 && rightDepth >= 0)
            return std::max(leftDepth, rightDepth)+1;
        
        result = std::max(result, std::abs(leftDepth - rightDepth));
        
        return std::min(leftDepth, rightDepth) - 1;
      }
    };

Runtime: 136 ms, beating 93.33% of leetcode users solutions using C++.
Memory: 90.57 mb, beating 99.40% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, Depth-First-Search, Breadth-First-Search, and binary tree.

### Solution Jan 11, 2024 (C++, leetcode) 1026. Maximum Difference Between Node and Ancestor (Medium)
In .LeetcodeDailySolution folder as Jan11,2024.cpp

#### Prompt:

Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.

A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.

#### Solution:

    class Solution {
    public:
    int maxAncestorDiff(TreeNode* root) {
        if (!root)
            return 0;

        int minVal = root->val, maxVal = root->val;

        differ(root, minVal, maxVal);

        return diff;
    }
    public:
    int diff = 0;
    void differ(TreeNode* root, int minVal, int maxVal) {
        if (!root)
            return;

        diff = max(diff, max(abs(minVal - root->val), abs(maxVal - root->val)));
        minVal = min(minVal, root->val);
        maxVal = max(maxVal, root->val);
        differ(root->left, minVal, maxVal);
        differ(root->right, minVal, maxVal);
      }
    };

Runtime: 3 ms, beating 85.85% of leetcode users solutions using C++.
Memory: 10.07 mb, beating 79.90% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, Depth-First Search, binary tree, and recursion.

### Solution Jan 12, 2024 (C++, leetcode) 1704. Determine in String Halves Are Alike (Easy)
In .LeetcodeDailySolution folder as Jan12,2024.cpp

#### Prompt:

You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.

Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters.

Return true if a and b are alike. Otherwise, return false.

#### Solution:

    class Solution {
    public:
    bool vow(char c){
        c=tolower(c);

        return (c=='a'||c=='e'||c=='i'||c=='o'||c=='u');
    }
    bool halvesAreAlike(string s) {

        int x=0,n=s.size();
        
        for(int i=0;i<n/2;i++){
            if(vow(s[i])) x++;
            if(vow(s[n-i-1])) x--;
        }
        return x==0;
      }
    };

Runtime: 2 ms, beating 64.10% of leetcode users solutions using C++.
Memory: 6.98 mb, beating 73.08% of leetcode ysers solutions using C++.

#### Concepts Applied:

Bool, char, unordered set, for loop, and if statement.

### Solution Jan 13, 2024 (C++, leetcode) 1347. Minimum Number of Steps to Make Two Strings Anagram (Medium)
In .LeetcodeDailySolution folder as Jan13,2024.cpp

#### Prompt:

You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character.

Return the minimum number of steps to make t an anagram of s.

An Anagram of a string is a string that contains the same characters with a different (or the same) ordering.

#### Solution:

    class Solution {
    public:
    int minSteps(string s, string t) {

        vector<int> m1(26, 0), m2(26, 0);

        for(auto c : s) m1[c-'a']++;
        for(auto c : t) m2[c-'a']++;

        int ans = 0;
        
        for(int i = 0;i < 26;i++){
            if(m1[i] > m2[i]) ans += m1[i] - m2[i]; 
        }
        return ans;
      }
    };

Runtime: 50 ms, beating 73.78% of leetcode users solutions using C++.
Memory: 16.86 mb, beating 82.35% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, counting, vector, for loop, and if statement. 

### Solution Jan 14, 2024 (C++, leetcode) 1657. Determine if Two Strings Are Close (Medium)
In .LeetcodeDailySolution folder as Jan14,2024.cpp

#### Prompt:

Two strings are considered close if you can attain one from the other using the following operations:

Operation 1: Swap any two existing characters.
For example, abcde -> aecdb
Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.
For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)
You can use the operations on either string as many times as necessary.

Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.

#### Solution:

    class Solution {
    public:
    bool closeStrings(std::string word1, std::string word2) {
        std::array<int, 26> charCount1 = {}; 
        std::array<int, 26> charCount2 = {}; 

        for (char c : word1) {
            ++charCount1[c - 'a'];
        }
        for (char c : word2) {
            ++charCount2[c - 'a'];
        }
        for (int i = 0; i < 26; ++i) {

            bool charPresentWord1 = charCount1[i] > 0;
            bool charPresentWord2 = charCount2[i] > 0;
            
            if ((charPresentWord1 && !charPresentWord2) || (!charPresentWord1 && charPresentWord2)) {
                return false;

            }
        }
        std::sort(charCount1.begin(), charCount1.end());
        std::sort(charCount2.begin(), charCount2.end());

        for (int i = 0; i < 26; ++i) {
            if (charCount1[i] != charCount2[i]) {
                return false;
            }
        }
        return true;
      }
    };

Runtime: 58 ms, beating 97.53% of leetcode users solutions using C++.
Memory: 20.70 mb, beating 99.17% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, arrays, counting, sorting, for loops, and if statements.

### Solution Jan 15, 2024 (C++, leetcode) 2225. Find Players With Zero or One Losses (Medium)
In .LeetcodeDailySolution folder as Jan15,2024.cpp

#### Prompt:

You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.

Return a list answer of size 2 where:

answer[0] is a list of all players that have not lost any matches.
answer[1] is a list of all players that have lost exactly one match.
The values in the two lists should be returned in increasing order.

Note:

You should only consider the players that have played at least one match.
The testcases will be generated such that no two matches will have the same outcome.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> findWinners(vector<vector<int>>& matches) {
        
        map<int,int>mp;

        for(int i=0;i<matches.size();i++){
            mp[matches[i][0]]+=0;
            mp[matches[i][1]]++;
        }

        vector<vector<int>>ans(2);

        for(auto a: mp){
            if(a.second==0)ans[0].push_back(a.first);
            if(a.second==1)ans[1].push_back(a.first);
        }
        return ans;
      }
    };

Runtime: 504 ms, beating 64.31% of leetcode users solutions using C++.
Memory: 162.93 mb, beating 86.78% of leetcode users solutions using C++.

#### Concepts Applied:

Sets, vectors, for loops, and if statements.

### Solution Jan 16, 2024 (C++, leetcode) 380. Insert Delete GetRandom O(1) (Medium)
In .LeetcodeDailySolution folder as Jan16,2024.cpp

#### Prompt:

Implement the RandomizedSet class:

RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
You must implement the functions of the class such that each function works in average O(1) time complexity.

#### Solution:

    class RandomizedSet {
    unordered_set<int> s;
    public:
    RandomizedSet() {
    }
    bool insert(int val) {
        auto a = s.insert(val);
        return a.second;
    }
    bool remove(int val) {
        auto b = s.erase(val);
        return b;
    }
    int getRandom() {
        return *next(s.begin(),rand()%s.size());
	}
    };

Runtime: 192 ms, beating 33.78% of leetcode users solutions using C++.
Memory: 97.20 mb, beating 90.76% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered set, bools, and randomization.

### Solution Jan 17, 2024 (C++, leetcode) 1207. Unique Number of Occurences (Easy)
In .LeetcodeDailySolution folder as Jan17,2024.cpp

#### Prompt:

Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.

#### Solution:

    class Solution {
    public:
    bool uniqueOccurrences(vector<int>& arr) {

        map<int, int> mp;

        for(auto i : arr) mp[i]++;
        set<int> s;

        for(auto [n, f] :mp) s.insert(f);

        return mp.size() == s.size();
      }
    };

Runtime: 2 ms, beating 65.75% of leetcode users solutions using C++.
Memory: 8.68 mb, beating 41.35% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, hashing, set, for loops, and comparison.

### Solution Jan 18, 2024 (C++, leetcode) 70. Climbing Stairs (Easy)
In .LeetcodeDailySolution folder as Jan18,2024.cpp

#### Prompt:

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

#### Solution:

    class Solution {
    public:
    int climbStairs(int n) {

        long long int prv1 = 1;
        long long int prv2 = 1;

        for(int i = 0; i < n; i++){
            long long int tmp = prv1;
            prv1 = prv1 + prv2;
            prv2 = tmp;
        }
        return prv2;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 6.34 mb, beating 71.74% of leetcode users solutions using C++.

#### Concepts Applied:

Simple counting of steps.

### Solution Jan 19, 2024 (C++, leetcode) 931. Minimum Falling Path Sum (Medium)
In .LeetcodeDailySolution folder as Jan19,2024.cpp

#### Prompt:

Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.

A falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).

#### Solution:

    class Solution {
    public:
    int minFallingPathSum(vector<vector<int>>& matrix) {       
        int n=matrix.size();
        int m=matrix[0].size();

        vector<vector<int>>dp(n,vector<int>(m,0));
        
        for(int j=0;j<m;j++){
            dp[0][j]=matrix[0][j];    
        }
        for(int i=1;i<n;i++){
            for(int j=0;j<m;j++){
                int ld=1e9,rd=1e9;
                int up=matrix[i][j] + dp[i-1][j];
                if(j-1>=0)
                    ld=matrix[i][j] + dp[i-1][j-1];
                if(j+1<m)
                    rd=matrix[i][j] + dp[i-1][j+1];
                dp[i][j] = min(up,min(ld,rd));   
            }
        }
        int mini=dp[n-1][0];
        
        for(int j=1;j<m;j++){
            mini=min(mini,dp[n-1][j]);
        }
        return mini; 
    }};

Runtime: 11 ms, beating 80.62% of leetcode users solutions using C++.
Memory: 13.08 mb, beating 5.08% of leetcode users solutions using C++.

#### Concepts Applied:

Dynamic programming, matrix, arrays, for loops, and if statements.

### Solution Jan 20, 2024 (C++, leetcode) 907. Sum of Subarray Minimums (Medium)
In .LeetcodeDailySolution folder as Jan20,2024.cpp

#### Prompt:

Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    int sumSubarrayMins(vector<int>& arr) {
        const int MOD = 1000000007;
        stack<int> st;
        long sumOfMinimums = 0;

        for (int i = 0; i <= arr.size(); i++) {
            while (!st.empty() && (i == arr.size() || arr[st.top()] >= arr[i])) {
                int mid = st.top();

                st.pop();
                
                int leftBoundary = st.empty() ? -1 : st.top();
                int rightBoundary = i;

                long count = (mid - leftBoundary) * (rightBoundary - mid) % MOD;

                sumOfMinimums += (count * arr[mid]) % MOD;
                sumOfMinimums %= MOD;
            }
            st.push(i);
        }
        return static_cast<int>(sumOfMinimums);
      }
    };

Runtime: 55 ms, beating 97.94% of leetcode users solutions using C++.
Memory: 41.76 mb, beating 80.15% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, subarray, modulo, stacks, for loop, and while loop. 

### Solution Jan 21, 2024 (C++, leetcode) 198. House Robber (Medium)
In .LeetcodeDailySolution folder as Jan21,2024.cpp

#### Prompt:

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.

#### Solution:

    class Solution {
    public: 
    int rob(vector<int>& nums) {
        int n = nums.size(), pre = 0, cur = 0;

        for (int i = 0; i < n; i++) {
            int temp = max(pre + nums[i], cur);
            
            pre = cur;
            cur = temp;
        }
        return cur;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.99 mb, beating 5.08% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, (dynamic programming with variables).

### Solution Jan 22, 2024 (C++, leetcode) 645. Set Mismatch (Easy)
In .LeetcodeDailySolution folder as Jan22,2024.cpp

#### Prompt:

You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.

You are given an integer array nums representing the data status of this set after the error.

Find the number that occurs twice and the number that is missing and return them in the form of an array.

#### Solution:

    class Solution {
    public:
    vector<int> findErrorNums(vector<int>& nums) {
        int n = nums.size();
        int sum = (n * (n + 1))/2;
        long long sqr_sum = 0;

        for(int i = 1; i <= n; i++) sqr_sum += i * i;
        int arr_sum = 0;
        long long arr_sqr_sum = 0;

        for(int i = 0; i < n; i++){
            arr_sum += nums[i];
            arr_sqr_sum += (nums[i] * nums[i]);
        }
        int sum_diff = arr_sum - sum;
        int sqr_sum_diff = arr_sqr_sum - sqr_sum;
        int missing = (sqr_sum_diff - (sum_diff * sum_diff)) / (2 * sum_diff);
        int duplicate = sum_diff + (missing);

        return {duplicate , missing};
      }
    };

Runtime: 18 ms, beating 92.06% of leetcode users solutions using C++.
Memory: 23.90 mb, beating 36.42% of leetcode users solutions using C++.

#### Concepts Applied:

For loops, and mathematics.

### Solution Jan 23, 2024 (C++, leetcode) 1239. Maximum Length of a Conactenated String with Unique Characters (Medium)
In .LeetcodeDailySolution folder as Jan23,2024.cpp

#### Prompt:

You are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters.

Return the maximum possible length of s.

A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.

#### Solution:

    class Solution {
    public:
    int maxLength(vector<string>& arr) {
        vector<int> dp = {0};
        int res = 0;
        
        for (const string& s : arr) {
            int a = 0, dup = 0;
            for (char c : s) {
                dup |= a & (1 << (c - 'a'));
                a |= 1 << (c - 'a');
            }
            if (dup > 0)
                continue;
            for (int i = dp.size() - 1; i >= 0; i--) {
                if ((dp[i] & a) > 0)
                    continue;

                dp.push_back(dp[i] | a);
                res = max(res, __builtin_popcount(dp[i] | a));
            }
        }
        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.40 mb, beating 78.50% of leetcode users solutions using C++.

#### Concepts Applied:

Bit manipulation, array, for loops, if statement, and dynamic programming.

### Solution Jan 24, 2024 (C++, leetcode) 1457. Pseudo-Palindromic Paths in a Binary Tree (Medium)
In .LeetcodeDailySolution folder as Jan24,2024.cpp

#### Prompt:

Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.

Return the number of pseudo-palindromic paths going from the root node to leaf nodes.

#### Solution:

    class Solution {
    public:
    int pseudoPalindromicPaths(TreeNode* root) {
        return countPseudoPalindromicPaths(root, 0);
    }
    private:
    int countPseudoPalindromicPaths(TreeNode* node, int path) {
        if (!node) {
            return 0;
        }
        path ^= (1 << node->val);

        if (!node->left && !node->right) {
            return (path & (path - 1)) == 0 ? 1 : 0;
        }
        return countPseudoPalindromicPaths(node->left, path) + countPseudoPalindromicPaths(node->right, path);
      }
    };

Runtime: 247 ms, beating 88.57% of leetcode users solutions using C++.
Memory: 176.94 mb, beating 99.43% of leetcode users solutions using C++.

#### Concepts Applied:

Recursion, depth-first search, bit manipulation, tree, binary tree, and if statements.

### Solution Jan 25, 2024 (C++, leetcode) 1143. Longest Common Subsequence (Medium)
In .LeetcodeDailySolution folder as Jan25,2024.cpp

#### Prompt:

Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.

A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, "ace" is a subsequence of "abcde".
A common subsequence of two strings is a subsequence that is common to both strings.

#### Solution:

    class Solution {
    public:
    int longestCommonSubsequence(string text1, string text2) {
        if (text1.length() < text2.length()) {
            return LCS(text1, text2);
        }
        return LCS(text2, text1);
    }
    int LCS(string s1, string s2) {
        vector<vector<int>> M(2, vector<int>(s1.length() + 1, 0));

        for (int i = 1; i <= s2.length(); i++) {
            M[i % 2][0] = 0;
            for (int j = 1; j <= s1.length(); j++) {
                if (s1[j - 1] == s2[i - 1]) {
                    M[i % 2][j] = M[(i - 1) % 2][j - 1] + 1;
                } else {
                    M[i % 2][j] = max(M[(i - 1) % 2][j - 1],
                                max(M[(i - 1) % 2][j], M[i % 2][j - 1]));
                }
            }
        }
        return M[s2.length() % 2][s1.length()];
      }
    };

Runtime: 19 ms, beating 92.26% of leetcode users solutions using C++.
Memory: 7.70 mb, beating 88.11% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, dynamic programming, if statements, and else statements.

### Solution Jan 26, 2024 (C++, leetcode) 576. Out of Boundary Paths (Medium)
In .LeetcodeDailySolution folder as Jan26,2024.cpp

#### Prompt:

There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball.

Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    int M=1e9+7;
    vector<vector<vector<int>>> dp;
    int solve(int n, int m, int maxMove, int startRow, int startColumn){

        if(startColumn<0 || startColumn>=n || startRow<0 || startRow>=m) return 1;
        if(maxMove == 0) return 0;
        if(dp[startRow][startColumn][maxMove] != -1) return dp[startRow][startColumn][maxMove];

        int up = solve(n, m, maxMove-1, startRow-1, startColumn);
        int down = solve(n, m, maxMove-1, startRow+1, startColumn);
        int left = solve(n, m, maxMove-1, startRow, startColumn-1);
        int right = solve(n, m, maxMove-1, startRow, startColumn+1);

        return dp[startRow][startColumn][maxMove] = ((up+down)%M + (left+right)%M)%M;
    }
    int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        dp = vector<vector<vector<int>>>(m, vector<vector<int>>(n, vector<int>(maxMove+1, -1)));
        return solve(n, m, maxMove, startRow, startColumn);
      }
    };

Runtime: 6 ms, beating 67.66% of leetcode users solutions using C++.
Memory: 10.36 mb, beating 24.21% of leetcode users solutions using C++.

#### Concepts Applied:

Modulo, recursion, memoization, array, dynamic programming, and if statements.

### Solution Jan 27, 2024 (C++, leetcode) 629. K Inverse Pairs Array (Hard)
In .LeetcodeDailySolution folder as Jan27,2024.cpp

#### Prompt:

For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.length and nums[i] > nums[j].

Given two integers n and k, return the number of different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs. Since the answer can be huge, return it modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    int kInversePairs(int n, int k) {
        int MOD = 1000000007;

        vector<int> dp(k + 1);

        dp[0] = 1;
        
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                dp[j] = (dp[j] + dp[j - 1]) % MOD;
            }
            for (int j = k; j >= i; j--) {
                dp[j] = (dp[j] - dp[j - i] + MOD) % MOD;
            }
        }
        return dp[k];
      }
    };

Runtime: 6 ms, beating 87.57% of leetcode users solutions using C++.
Memory: 7.43 mb, beating 89.73% of leetcode users solutions using C++.

#### Concepts Applied:

Modulo, array, dynamic programming, and for loops.

### Solution Jan 28, 2024 (C++, leetcode) 1074. Number of Submatrices That Sum to Target (Hard)
In .LeetcodeDailySolution folder as Jan28,2024.cpp

#### Prompt:

Given a matrix and a target, return the number of non-empty submatrices that sum to target.

A submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 <= x <= x2 and y1 <= y <= y2.

Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 != x1'.

#### Solution:

    class Solution {
    public:
    int numSubmatrixSumTarget(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size(), res = 0;

        for (int l = 0; l < n; ++l) {
            int sums[105] = {0};

            for (int r = l; r < n; ++r) {
                for (int i = 0; i < m; ++i) {
                    sums[i] += matrix[i][r];
                }
                for (int i = 0; i < m; ++i) {
                    int sum = 0;

                    for (int j = i; j < m; ++j) {
                        sum += sums[j];

                        if (sum == target) {
                            ++res;
                        }
                    }
                }
            }
        }
        return res;
      }
    };

Runtime: 102 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.46 mb, beating 87.16% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, matrices, for loops, and if statement.

### Solution Jan 29, 2024 (C++, leetcode) 232. Implement Queue using Stacks (Easy)
In .LeetcodeDailySolution folder as Jan29,2024.cpp

#### Prompt:

Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).

Implement the MyQueue class:

void push(int x) Pushes element x to the back of the queue.
int pop() Removes the element from the front of the queue and returns it.
int peek() Returns the element at the front of the queue.
boolean empty() Returns true if the queue is empty, false otherwise.
Notes:

You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.

#### Solution:

    class MyQueue {
    public:
    stack<int> input;
    stack<int> output;

    MyQueue() {
    }
    void push(int x) {
        input.push(x);
        }
    int pop() {
        if(!output.empty()){
            int e =  output.top();
            output.pop();
            return e;
        }
        else{
            while(!input.empty()){
                int e = input.top();
                input.pop();
                output.push(e);
            }
            int e =  output.top();
            output.pop();
            return e;
        }
    }
    int peek() {
        if(!output.empty()){
            return output.top();
        }
        else{
            while(!input.empty()){
                int ele = input.top();
                input.pop();
                output.push(ele);
            }
            return output.top();
        }
    }
    bool empty() {
        if(input.empty() and output.empty()) return true;
        else return false;
        }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.25 mb, beating 16.98% of leetcode users solutions using C++.

#### Concepts Applied:

Stacks, queues, while loops, if statements, and else statements.

### Solution Jan 30, 2024 (C++, leetcode) 150. Evaluate Reverse Polish Notation (Medium)
In .LeetcodeDailySolution folder as Jan30,2024.cpp

#### Prompt:

You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.

Evaluate the expression. Return an integer that represents the value of the expression.

Note that:

The valid operators are '+', '-', '*', and '/'.
Each operand may be an integer or another expression.
The division between two integers always truncates toward zero.
There will not be any division by zero.
The input represents a valid arithmetic expression in a reverse polish notation.
The answer and all the intermediate calculations can be represented in a 32-bit integer.

#### Solution:

    #include <bits/stdc++.h>

    class Solution {
    public:
    int evalRPN(vector<string>& tokens) {
        stack<int> numbers;

        for (const string& token : tokens) {
            if (token.size() > 1 || isdigit(token[0])) {
                numbers.push(stoi(token));
            } else { 
                int operand2 = numbers.top();
                numbers.pop();

                int operand1 = numbers.top();
                numbers.pop();

                switch (token[0]) {
                    case '+': 
                        numbers.push(operand1 + operand2);
                        break;
                    case '-': 
                        numbers.push(operand1 - operand2);
                        break;
                    case '*': 
                        numbers.push(operand1 * operand2);
                        break;
                    case '/': 
                        numbers.push(operand1 / operand2);
                        break;
                }                
            }
        }
        return numbers.top();
      }
    };

Runtime: 8 ms, beating 70.52% of leetcode users solutions using C++.
Memory: 15.44 mb, beating 10.51% of leetcode users solutions using C++.

#### Concepts Applied:

Stacks, for loop, if statement, else statement, switch, and mathematical operations.

### Solution Jan 31, 2024 (C++, leetcode) 739. Daily Temperatures (Medium)
In .LeetcodeDailySolution folder as Jan31,2024.cpp

#### Prompt:

Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.

#### Solution:

    class Solution {
    public:
    std::vector<int> dailyTemperatures(std::vector<int>& temps) {
        std::vector<int> results(temps.size());
        std::stack<int> stack;

        for (int i = 0; i < temps.size(); i++) {
            while (!stack.empty() && temps[stack.top()] < temps[i]) {
                results[stack.top()] = i - stack.top();
                stack.pop();
            }
            stack.push(i);
        }
        return results;
      }
    };

Runtime: 133 ms, beating 72.67% of leetcode users solutions using C++.
Memory: 105.44 mb, beating 25.93% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, stacks, for loop, and while loop.

### Solution Feb 1, 2024 (C++, leetcode) 2966. Divide Array Into Arrays With Max Difference (Medium)
In .LeetcodeDailySolution folder as Feb1,2024.cpp

#### Prompt:

You are given an integer array nums of size n and a positive integer k.

Divide the array into one or more arrays of size 3 satisfying the following conditions:

Each element of nums should be in exactly one array.
The difference between any two elements in one array is less than or equal to k.
Return a 2D array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> divideArray(vector<int>& nums, int k) {
        vector<vector<int>> res;

        sort(nums.begin(), nums.end());
        
        for(int i = 2; i < nums.size(); i += 3){
            if(nums[i] - nums[i - 2] > k) return {};
            res.push_back({nums[i-2], nums[i-1], nums[i]});
        }
        return res;
      }
    };

Runtime: 132 ms, beating 98.28% of leetcode users solutions using C++.
Memory: 119.69 mb, beating 39.01% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, for loop, and if statement. 

### Solution Feb 2, 2024 (C++, leetcode) 1291. Sequential Digits (Medium)
In .LeetcodeDailySolution folder as Feb2,2024.cpp

#### Prompt:

An integer has sequential digits if and only if each digit in the number is one more than the previous digit.

Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.

#### Solution:

    class Solution {
    public:
    vector<int> result;
    void solve(int low , int high,int i , int ans){
    
    if(ans >= low && ans <= high){
        result.push_back(ans);
    }
    if(ans > high || i>9){
        return;
    }
    solve(low,high,i+1, ans*10+i);
    }
    vector<int> sequentialDigits(int low, int high) {
        
        for(int i =1 ;i<10;i++){
            solve(low,high,i,0); 
        }
        sort(result.begin(),result.end());

        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.62 mb, beating 8.68% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, if statements, for loop, and sorting.

### Solution Feb 3, 2024 (C++, leetcode) 1043. Partition Array for Maximum Sum (Medium)
In .LeetcodeDailySolution folder as Feb3,2024.cpp

#### Prompt:

Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray.

Return the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer.

#### Solution:

    #include <bits/stdc++.h>

    class Solution {
    public:
    int maxSumAfterPartitioning(std::vector<int>& arr, int k) {
        int n = arr.size();

        std::vector<int> dp(n + 1, 0);

        for (int i = 0; i < n; i++) {
            int curMax = 0, curSum = 0;

            for (int j = i; j >= std::max(0, i - k + 1); j--) {
                curMax = std::max(curMax, arr[j]);

                int cur = curMax * (i - j + 1) + dp[j];

                curSum = std::max(curSum, cur);
            }
           dp[i + 1] = curSum;
        }
        return dp[n];
      }
    };

Runtime: 6 ms, beating 94.83% of leetcode users solutions using C++.
Memory: 10.93 mb, beating 15.42% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, dynamic programming, and for loops.

### Solution Feb 4, 2024 (C++, leetcode) 76. Minimum Window Substring (Hard)
In .LeetcodeDailySolution folder as Feb4,2024.cpp

#### Prompt:

Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. 
If there is no such substring, return the empty string "".

The testcases will be generated such that the answer is unique.

#### Solution:

    class Solution {
    public:
    std::string minWindow(std::string s, std::string t) {

        if (s.empty() || t.empty() || s.length() < t.length()) {
            return "";
        }
        std::vector<int> map(128, 0);
        int count = t.length();
        int start = 0, end = 0, minLen = INT_MAX, startIndex = 0;

        for (char c : t) {
            map[c]++;
        }
        while (end < s.length()) {
            if (map[s[end++]]-- > 0) {
                count--;
            }
            while (count == 0) {
                if (end - start < minLen) {
                    startIndex = start;
                    minLen = end - start;
                }
                if (map[s[start++]]++ == 0) {
                    count++;
                }
            }
        }
        return minLen == INT_MAX ? "" : s.substr(startIndex, minLen);
      }
    };

Runtime: 4 ms, beating 91.16% of leetcode users solutions using C++.
Memory: 9.28 mb, beating 22.77% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sliding window, if statements, for loop, and while loops. 

### Solution Feb 5, 2024 (C++, leetcode) 387. First Unique Character in a String (Easy)
In .LeetcodeDailySolution folder as Feb5,2024.cpp

#### Prompt:

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.

#### Solution:

    class Solution {
    public:
    int firstUniqChar(string& s) {
        int position[26] = {0};

        for(int i = 1; i<=s.size(); i++){
            char c = s[i-1]-'a';

            if(position[c] == 0){
                position[c] = -i;
            }
            else{
                position[c] = i; 
            }
        }
        int minPosition = INT_MAX;

        for(int i=0;i<26;i++){
            if(position[i] < 0)
                minPosition = min(minPosition, -position[i]);
        }
        return minPosition == INT_MAX ? -1 : minPosition - 1;
      }
    };
	auto init = [](){ 
 	   return 'c';
	}();

Runtime: 14 ms, beating 98.04% of leetcode users solutions using C++.
Memory: 10.90 mb, beating 96.77% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loops, if statements, and else statement.

### Solution Feb 6, 2024 (C++, leetcode) 49. Group Anagrams (Medium)
In .LeetcodeDailySolution folder as Feb6,2024.cpp

#### Prompt:

Given an array of strings strs, group the anagrams together. You can return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

#### Solution:

    class Solution {
    public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {

        vector<vector<string>> ans;                 

        unordered_map<string, vector<string>> mp;         
        
        for(int i = 0; i < strs.size(); i++) {           
            string s = strs[i];                         
            sort(strs[i].begin(), strs[i].end());      
            mp[strs[i]].push_back(s);                 
        }
        for(auto i : mp)                          
            ans.push_back(i.second);
        
        return ans;     
      }
    };

Runtime: 23 ms, beating 89.73% of leetcode users solutions using C++.
Memory: 24.31 mb, beating 26.31% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, strings, unordered map, sorting, and for loops.

### Solution Feb 7, 2024 (C++, leetcode) 451. Sort Characters By Frequency (Medium)
In .LeetcodeDailySolution folder as Feb7,2024.cpp

#### Prompt:

Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string.

Return the sorted string. If there are multiple answers, return any of them.

#### Solution:

    #include <bits/stdc++.h>

    class Solution {
    public:
    string frequencySort(string s) {

        unordered_map<char, int> charCount;

        for (char c : s) {
            charCount[c]++;
        }
        vector<char> sortedChars;

        for (const auto& entry : charCount) {
            sortedChars.push_back(entry.first);
        }
        sort(sortedChars.begin(), sortedChars.end(), [&](char a, char b) {
            return charCount[a] > charCount[b];
        });
        string result;

        for (char c : sortedChars) {
            result += string(charCount[c], c);
        }
        return result;
      }
    };

Runtime: 6 ms, beating 95.18% of leetcode users solutions using C++.
Memory: 11 mb, beating 15.79% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered map, for loops, char array, sorting, and strings.

### Solution Feb 8, 2024 (C++, leetcode) 279. Perfect Squares (Medium)
In .LeetcodeDailySolution folder as Feb8,2024.cpp

#### Prompt:

Given an integer n, return the least number of perfect square numbers that sum to n.

A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.

#### Solution:

    class Solution {
    public:
    int numSquares(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            int minVal = INT_MAX;

            for (int j = 1; j * j <= i; j++) {
                int remainder = i - j * j;
                minVal = min(minVal, dp[remainder]);
            }
            dp[i] = minVal + 1;
        }
        return dp[n];
      }
    };

Runtime: 32 ms, beating 94.80% of leetcode users solutions using C++.
Memory: 10.46 mb, beating 38.77% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, dynamic programming, for loops, and simple math.

### Solution Feb 9, 2024 (C++, leetcode) 368. Largest Divisible Subset (Medium)
In .LeetcodeDailySolution folder as Feb9,2024.cpp

#### Prompt:

Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:

answer[i] % answer[j] == 0, or
answer[j] % answer[i] == 0
If there are multiple solutions, return any of them.

#### Solution:

    class Solution {
    public:
    vector<int> largestDivisibleSubset(vector<int>& nums) {
        int n=nums.size(), maxi=1, num=-1;
        vector<int>v;
        sort(nums.begin(), nums.end());
        vector<int>dp(n, 1);
        for(int i=1; i<n; i++){
            for(int j=0; j<i; j++){
                if(!(nums[i]%nums[j]) && dp[i]<dp[j]+1){
                    dp[i]=dp[j]+1;
                    if(maxi<dp[i]){
                        maxi=dp[i];
                    }
                }
            }
        }
        for(int i=n-1; i>=0; i--){
            if(maxi==dp[i] && (num==-1 || !(num%nums[i]))){
                v.push_back(nums[i]);
                maxi--;
                num=nums[i];
            }
        }
        return v;
       }
     };

Runtime: 12 ms, beating 92.51% of leetcode users solutions using C++.
Memory: 11.32 mb, beating 32.74% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, sorting, for loops, if statements, and dynamic programming.

### Solution Feb 10, 2024 (C++, leetcode) 647. Palindromic Substrings (Medium)
In .LeetcodeDailySolution folder as Feb10,2024.cpp

#### Prompt:

Given a string s, return the number of palindromic substrings in it.

A string is a palindrome when it reads the same backward as forward.

A substring is a contiguous sequence of characters within the string.

#### Solution:

    class Solution {
    public:
    int countSubstrings(string s) {
        int n = s.length(), ans = 0;
        
        for (int i = 0; i < n; ++i) {
            int even = palindromeCount(s, i, i + 1);
            int odd = palindromeCount(s, i, i);
            ans += even + odd;
        }
        return ans;
    }
    int palindromeCount(const string& s, int left, int right) {
        int count = 0;

        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            --left;
            ++right;
            ++count;
        }
        return count;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.55 mb, beating 69.61% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, for loops, simple math, and while loop.

### Solution Feb 11, 2024 (C++, leetcode) 1463. Cherry Pickup II (Hard) 
In .LeetcodeDailySolution folder as Feb11,2024.cpp

#### Prompt:

You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell.

You have two robots that can collect cherries for you:

Robot #1 is located at the top-left corner (0, 0), and
Robot #2 is located at the top-right corner (0, cols - 1).
Return the maximum number of cherries collection using both robots by following the rules below:

From a cell (i, j), robots can move to cell (i + 1, j - 1), (i + 1, j), or (i + 1, j + 1).
When any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.
When both robots stay in the same cell, only one takes the cherries.
Both robots cannot move outside of the grid at any moment.
Both robots should reach the bottom row in grid.

#### Solution:

    class Solution {
    public:
    int m, n;
    int dp[71][71][71]; 
    int helper(vector<vector<int>>& grid, int row, int column1, int column2){

        if(row >= m) return 0; 
        if(dp[row][column1][column2] != -1) return dp[row][column1][column2]; 

        int cherryCount = grid[row][column1];

        if(column1 != column2) cherryCount += grid[row][column2]; 

        int result = 0;

        for(int i = -1; i <= 1; ++i){ 
            for(int j = -1; j <= 1; ++j){ 

                int newRow = row + 1;
                int newColumn1 = column1 + i;
                int newColumn2 = column2 + j;

                if(newColumn1 >= 0 && newColumn1 < n && newColumn2 >= 0 && newColumn2 < n) 
                    result = max(result, helper(grid, newRow, newColumn1, newColumn2));
            }
        }
        return dp[row][column1][column2] = cherryCount + result;
    }
    int cherryPickup(vector<vector<int>>& grid) {
        m = grid.size(); 
        n = grid[0].size(); 
        memset(dp, -1, sizeof(dp)); 
        
        return helper(grid, 0, 0, n - 1);
      }
    };

Runtime: 27 ms, beating 98.38% of leetcode users solutions using C++.
Memory: 12.53 mb, beating 77.18% of leetcode users solutions using C++.

#### Concepts Applied:

Dynamic programming, integer array, matrix, if statements, and for loops.

### Solution Feb 12, 2024 (C++, leetcode) 169. Majority Element (Easy)
In .LeetcodeDailySolution folder as Feb12,2024.cpp

#### Prompt:

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

#### Solution:

    class Solution {
    public:
    int majorityElement(vector<int>& nums) {
        int res = 0;
        int majority = 0;
        
        for (int n : nums) {
            if (majority == 0) {
                res = n;
            }
            majority += n == res ? 1 : -1;
        }
        
        return res;        
      }
    };

Runtime: 9 ms, beating 89.28% of leetcode users solutions using C++. 
Memory: 21.91 mb, beating 35.07% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, for loop, and if statement.

### Solution Feb 13, 2024 (C++, leetcode) 2108. Find First Palindromic String in the Array (Easy)
In .LeetcodeDailySolution folder as Feb13,2024.cpp

#### Prompt:

Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string "".

A string is palindromic if it reads the same forward and backward.

#### Solution:

    #include <bits/stdc++.h>

    class Solution {
    public:
    std::string firstPalindrome(std::vector<std::string>& words) {
        auto isPalindrome = [](const std::string& s) {
            int i = 0, j = s.length() - 1;

            while (i <= j) {
                if (s[i] != s[j]) {
                    return false;
                }
                i++;
                j--;
            }
            return true;
        };
        for (const auto& word : words) {
            if (isPalindrome(word)) {
                return word;
            }
        }
        return "";
      }
    };

Runtime: 40 ms, beating 91.75% of leetcode users solutions using C++.
Memory: 23.29 mb, beating 62.17% of leetcode users solutions using C++.

#### Concepts Applied:

String array, while loop, if statements, and for loop.

### Solution Feb 14, 2024 (C++, leetcode) 2149. Rearrange Array Elements by Sign (Medium)
In .LeetcodeDailySolution folder as Feb14,2024.cpp

#### Prompt:

You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.

You should rearrange the elements of nums such that the modified array follows the given conditions:

Every consecutive pair of integers have opposite signs.
For all integers with the same sign, the order in which they were present in nums is preserved.
The rearranged array begins with a positive integer.
Return the modified array after rearranging the elements to satisfy the aforementioned conditions.

#### Solution:

    #include <bits/stdc++.h>

    class Solution {
    public:
    vector<int> rearrangeArray(vector<int>& nums) {
        int n = nums.size();
        int posIndex = 0, negIndex = 0;
        vector<int> result(n);

        for (int i = 0; i < n; ++i) {
            if (i % 2 == 0) {
                while (posIndex < n && nums[posIndex] < 0)
                    ++posIndex;
                        result[i] = nums[posIndex++];
            } else {
                while (negIndex < n && nums[negIndex] >= 0)
                    ++negIndex;
                        result[i] = nums[negIndex++];
            }
        }
        return result;
      }
    };

Runtime: 149 ms, beating 68.86% of leetcode users solutions using C++.
Memory: 126.29 mb, beating 60.91% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, for loop, modulo, if statement, while loops, and else statement.

### Solution Feb 15, 2024 (C++, leetcode) 2971. Find Polygon With the Largest Perimeter (Medium)
In .LeetcodeDailySolution folder as Feb15,2024.cpp

#### Prompt:

You are given an array of positive integers nums of length n.

A polygon is a closed plane figure that has at least 3 sides. The longest side of a polygon is smaller than the sum of its other sides.

Conversely, if you have k (k >= 3) positive real numbers a1, a2, a3, ..., ak where a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.

The perimeter of a polygon is the sum of lengths of its sides.

Return the largest possible perimeter of a polygon whose sides can be formed from nums, or -1 if it is not possible to create a polygon.

#### Solution:

    class Solution {
    public:
    long long largestPerimeter(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        long long sum = 0;
        long long ans = -1;
        
        for(int i=0;i<nums.size();i++){
            if(nums[i]<sum)ans = nums[i] + sum;
            sum+=nums[i];
        }
        
        return ans;
      }
    };

Runtime: 123 ms, beating 98.04% of leetcode users solutions using C++.
Memory: 83.40 mb, beating 35.31% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, sorting, for loop, and if statement.

### Solution Feb 16, 2024 (C++, leetcode) 1481. Least Number of Unique Integers after K Removals (Medium)
In .LeetcodeDailySolution folder as Feb16,2024.cpp

#### Prompt:

Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.

#### Solution:

    class Solution {
    public:
    int findLeastNumOfUniqueInts(vector<int>& arr, int k) {
        unordered_map<int, int> mp;

        for (int& x : arr) {
            mp[x]++;
        }
        vector<int> freq;
        for (auto& pair : mp) {
            freq.push_back(pair.second);
        }
        sort(begin(freq), end(freq));
        
        int count = 0;

        for (int& f : freq) {
            if (k >= f) {
                k -= f;
                count++;
            } else {
                break;
            }
        }
        return freq.size() - count;
      }
    };

Runtime: 115 ms, beating 84.61% of leetcode users solutions using C++.
Memory: 66.06 mb, beating 61.11% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, unordered map, for loops, sorting, if statement, and else statement.

### Solution Feb 17, 2024 (C++, leetcode) 1642. Furthest Building You Can Reach (Medium)
In .LeetcodeDailySolution folder as Feb17,2024.cpp

#### Prompt:

You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.

You start your journey from building 0 and move to the next building by possibly using bricks or ladders.

While moving from building i to building i+1 (0-indexed),

If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks.
If the current building's height is less than the next building's height, you can either use one ladder or (h[i+1] - h[i]) bricks.
Return the furthest building index (0-indexed) you can reach if you use the given ladders and bricks optimally.

#### Solution:

    class Solution {
    public:
    int furthestBuilding(vector<int>& h, int b, int l) {        
        priority_queue<int> p;
    
        int i=0, diff =0; 

        for(i=0; i<h.size()-1; i++){ 
            diff = h[i+1]-h[i];
            if(diff <= 0){
                continue;
            }
            b -= diff; 

            p.push(diff); 
       
            if(b < 0){
                b += p.top(); 
                p.pop(); 
                l--;
            }          
            if(l < 0) break;
        }
        return i;
      }
    };

Runtime: 74 ms, beating 76.70% of leetcode users solutions using C++.
Memory: 57.45 mb, beating 30.85% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, priority queue, for loop, and if statements.

### Solution Feb 18, 2024 (C++, leetcode) 2402. Meeting Rooms III (Hard)
In .LeetcodeDailySolution folder as Feb18,2024.cpp

#### Prompt:

You are given an integer n. There are n rooms numbered from 0 to n - 1.

You are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). All the values of starti are unique.

Meetings are allocated to rooms in the following manner:

Each meeting will take place in the unused room with the lowest number.
If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the same duration as the original meeting.
When a room becomes unused, meetings that have an earlier original start time should be given the room.
Return the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number.

A half-closed interval [a, b) is the interval between a and b including a and not including b.

#### Solution:

    #include <bits/stdc++.h>
    using namespace std;

    typedef long long ll; 

    class Solution {
    public:
    int mostBooked(int n, vector<vector<int>>& A) {
        vector<int> roomcnt(n, 0);
        set<int> s;
        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;

        sort(A.begin(), A.end());

        int m = A.size();

        for (int i = 0; i < n; ++i) {
            s.insert(i);
        }
        for (int i = 0; i < m; ++i) {
            ll start = A[i][0];
            ll end = A[i][1];

            while (q.size() > 0 && q.top().first <= start) {
                int room = q.top().second;
                q.pop();
                s.insert(room);
            }
            if (s.size() == 0) {
                pair<ll, ll> p = q.top();
                q.pop();
                ll dif = end - start;
                start = p.first;
                end = start + dif;
                s.insert(p.second);
            }
            auto it = s.begin();
            roomcnt[*it]++;
            q.push({end, *it});
            s.erase(*it);
        }
        int ans = 0;
        int maxi = 0;

        for (int i = 0; i < n; ++i) {
            if (maxi < roomcnt[i]) {
                maxi = roomcnt[i];
                ans = i;
            }
        }
        return ans;
      }
    };

Runtime: 337 mb, beating 74.11% of leetcode users solutions using C++.
Memory: 124.60 mb, beating 13.32% of leetcode users solutions using C++.

#### Concepts Applied:

Long long, integer array, integer set, priority queue, sorting, for loops, while loop, and if statements.

### Solution Feb 19, 2024 (C++, leetcode) Power of Two (Easy)
In .LeetcodeDailySolution folder as Feb19,2024.cpp

#### Prompt:

Given an integer n, return true if it is a power of two. Otherwise, return false.

An integer n is a power of two, if there exists an integer x such that n == 2x.

#### Solution:

    class Solution {
    public:
    bool isPowerOfTwo(int n) {
        return n > 0 && not (n & n - 1);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.09 mb, beating 73.96% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean and simple return statement.

### Solution Feb 20, 2024 (C++, leetcode) 268. Missing Number (Easy)
In .LeetcodeDailySolution folder as Feb20,2024.cpp

#### Prompt:

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

#### Solution:

    class Solution {
    public:
    int missingNumber(vector<int>& nums) {
        int res = nums.size();
        
        for (int i = 0; i < nums.size(); i++) {
            res += i - nums[i];
        }
        return res;        
      }
    };

Runtime: 11 ms, beating 82.54% of leetcode users solutions using C++.
Memory: 20.26 mb, beating 65.57% of leetcode users solution using C++.

#### Concepts Applied:

Integer array, for loop, and indexing.

### Solution Feb 21, 2024 (C++, leetcode) 201. Bitwise AND of Numbers Range (Medium)
In .LeetcodeDailySolution folder as Feb21,2024.cpp

#### Prompt:

Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.

#### Solution:

    class Solution {
    public:
    int rangeBitwiseAnd(int left, int right) {
        int cnt = 0;
        while (left != right) {
            left >>= 1;
            right >>= 1;
            cnt++;
        }
        return (left << cnt);
      }
    };

Runtime: 4 ms, beating 79.88% of leetcode users solutions using C++.
Memory: 8.78 mb, beating 75.72% of leetcode users solutions using C++.

#### Concepts Applied:

While loop, and bit manipulation.

### Solution Feb 22, 2024 (C++, leetcode) 997. Find the Town Judge (Easy)
In .LeetcodeDailySolution folder as Feb22,2024.cpp

#### Prompt:

In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

The town judge trusts nobody.
Everybody (except for the town judge) trusts the town judge.
There is exactly one person that satisfies properties 1 and 2.
You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.

Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.

#### Solution:

    class Solution {
    public:
    int findJudge(int n, vector<vector<int>>& trust) {
        vector<int> trusts(n + 1, 0);
        
        for (const auto& pair : trust) {
            trusts[pair[0]] -= 1;
            trusts[pair[1]] += 1;
        }
        for (int i = 1; i <= n; i++) {
            if (trusts[i] == n - 1) {
                return i;
            }
        }
        return -1;
      }
    };

Runtime: 112 ms, beating 86.73% of leetcode users solutions using C++.
Memory: 64.24 mb, beating 82.51% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, for loops, and if statement.

### Solution Feb 23, 2024 (C++, leetcode) 787. Cheapest Flights Within K Stops (Medium)
In .LeetcodeDailySolution folder as Feb23,2024.cpp

#### Prompt:

There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.

You are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.

#### Solution:

    #include <bits/stdc++.h>
    using namespace std;

    class Solution {
    public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        vector<int> dp(n, numeric_limits<int>::max());
        dp[src] = 0;

        for (int i = 0; i <= k; i++) {
            vector<int> temp = dp;
            for (const auto& flight : flights) {
                if (dp[flight[0]] != numeric_limits<int>::max()) {
                    temp[flight[1]] = min(temp[flight[1]], dp[flight[0]] + flight[2]);
                }
            }
            dp = temp;
        }
        return dp[dst] == numeric_limits<int>::max() ? -1 : dp[dst];
      }
    };

Runtime: 15 ms, beating 73.57% of leetcode users solutions using C++.
Memory: 15.97 mb, beating 83.49% of leetcode users solutions suing C++.

#### Concepts Applied:

Integer arrays, dynamic programming, for loops, and if statement.

### Solution Feb 24, 2024 (C++, leetcode) 2902. Find All People With Secret (Hard)
In .LeetcodeDailySolution folder as Feb24,2024.cpp

#### Prompt:

You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson.

Person 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa.

The secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.

Return a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order.

#### Solution:

    class UnionFind {    
    public:
    vector<int> root, rank;

    UnionFind(int n) : root(n), rank(n) {
        rank.assign(n, 1);
        iota(root.begin(), root.end(), 0);
    }
    int Find(int x) {
        if (x == root[x]) return x;
        else return root[x] = Find(root[x]);
    }
    void Union(int x, int y) {
        int rX = Find(x), rY = Find(y);
        if (rX == rY)  return;
        if (rank[rX] > rank[rY]) swap(rX, rY);   
        root[rX] = rY;
        if (rank[rX]==rank[rY]) rank[rY]++;
    }
    bool connected(int x, int y) {
        return Find(x) == Find(y);
    }
    void reset(int x){
        root[x]=x;
        rank[x]=1;
      }
    };
    class Solution {
    public:
    using int2=pair<int, int>;
    vector<int> findAllPeople(int n, vector<vector<int>>& meetings, int firstPerson){
        vector<int2> meet_time[100001];
        int tMax=-1;

        for(auto& meet: meetings){
            int x=meet[0], y=meet[1], t=meet[2];
            meet_time[t].emplace_back(x, y);
            tMax=max(tMax, t);
        }
        UnionFind uf(n);
        uf.Union(0, firstPerson);

        for (int t=0; t<=tMax; t++){
            for(auto& [x, y]: meet_time[t])
                uf.Union(x, y);
            for(auto& [x, y]: meet_time[t]){
                if (!uf.connected(0, x)){
                    uf.reset(x);
                    uf.reset(y);
                }
            }
        }
        vector<int> list={0};

        for(int i=1; i<n; i++)
            if (uf.connected(0, i)) list.push_back(i);
        return list;
      }
    };
    int ans() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    return 'c';
    };

Runtime: 360 ms, beating 95.73% of leetcode users solutions using C++.
Memory: 149.54 mb, beating 86.75% of leetcode users solutions using C++.

#### Concepts Applied:

Union find, boolean, integer arrays, for loops, if statements, else statement, integer pair, and list array.

### Solution Feb 25, 2024 (C++, leetcode) 2709. Greatest Common Divisor Traversal (Hard)
In .LeetcodeDailySolution folder as Feb25,2024.cpp

#### Prompt:

You are given a 0-indexed integer array nums, and you are allowed to traverse between its indices. You can traverse between index i and index j, i != j, if and only if gcd(nums[i], nums[j]) > 1, where gcd is the greatest common divisor.

Your task is to determine if for every pair of indices i and j in nums, where i < j, there exists a sequence of traversals that can take us from i to j.

Return true if it is possible to traverse between all such pairs of indices, or false otherwise.

#### Solution:

    class Solution {
    int getf(vector<int> &f, int x) {

        return f[x] == x ? x : (f[x] = getf(f, f[x]));
    }
    void merge(vector<int> &f, vector<int> &num, int x, int y) {
        x = getf(f, x);
        y = getf(f, y);

        if (x == y) {
            return;
        }
        if (num[x] < num[y]) {
            swap(x, y);
        }
        f[y] = x;
        num[x] += num[y];
    }
    public:
    bool canTraverseAllPairs(vector<int>& nums) {
        const int n = nums.size();

        if (n == 1) {
            return true;
        }
        vector<int> f(n), num(n);

        for (int i = 0; i < n; ++i) {
            f[i] = i;
            num[i] = 1;
        }
        unordered_map<int, int> have;

        for (int i = 0; i < n; ++i) {
            int x = nums[i];

            if (x == 1) {
                return false;
            }
            for (int d = 2; d * d <= x; ++d) {
                if (x % d == 0) {
                    if (have.count(d)) {
                        merge(f, num, i, have[d]);
                    } else {
                        have[d] = i;
                    }
                    while (x % d == 0) {
                        x /= d;
                    } 
                }
            }
            if (x > 1) {
                if (have.count(x)) {
                    merge(f, num, i, have[x]);
                } else {
                    have[x] = i;
                }
            }
        }
        return num[getf(f, 0)] == n;
      }
    };

Runtime: 407 ms, beating 71.51% of leetcode users solutions using C++.
Memory: 90.99 mb, beating 82.42% of leetcode users solutions using C++.

#### Concepts Applied:

Union find, if statements, booleans, integer arrays, unordered map, for loops, else statements, and while loops. 

### Solution Feb 26, 2024 (C++, leetcode) 100. Same Tree (Easy)
In .LeetcodeDailySolution folder as Feb26,2024.cpp

#### Prompt:

Given the roots of two binary trees p and q, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

#### Solution:

    class Solution {
    public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        
        return p==q || p && q && p->val==q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.69 mb, beating 44.38% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean, recursion, and comparisons.

### Solution Feb 27, 2024 (C++, leetcode) 543. Diameter of Binary Tree (Easy)
In .LeetcodeDailySolution folder as Feb27,2024.cpp

#### Prompt:

Given the root of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

The length of a path between two nodes is represented by the number of edges between them.

#### Solution:

    class Solution {
    public:

    int helper(TreeNode*root, int&ans) {
        if (!root) return 0;
        int l = helper(root->left, ans);
        int r = helper(root->right, ans);

        ans = max(ans, l+r);

        return 1 + max(l,r);
      }
    int diameterOfBinaryTree(TreeNode* root) {
        if (!root) return 0;
        int ans = 0;
        helper(root, ans);
        return ans;  
      }
    };

Runtime: 6 ms, beating 73.56% of leetcode users solutions using C++.
Memory: 18.94 mb, beating 70.17% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, depth first search, recursion, and if statements.

### Solution Feb 28, 2024 (C++, leetcode) 513. Find Bottom Left Tree Value (Medium)
In .LeetcodeDailySolution folder as Feb28,2024.cpp

#### Prompt:

Given the root of a binary tree, return the leftmost value in the last row of the tree.

#### Solution:

    class Solution {
    public:
    int findBottomLeftValue(TreeNode* root) {
        TreeNode* curr;
        queue<TreeNode*> Q; Q.push(root);

        while (!Q.empty()) {
            curr = Q.front(); Q.pop();
            if (curr->right) Q.push(curr->right);
            if (curr->left) Q.push(curr->left);
        }
        return curr->val;
      }
    };

Runtime: 3 ms, beating 98.29% of leetcode users solutions using C++.
Memory: 20.15 mb, beating 76.07% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, breadth first search, queue, and while loop.

### Solution Feb 29, 2024 (C++, leetcode) 1609. Even Odd Tree (Medium)
In .LeetcodeDailySolution folder as Feb29,2024.cpp

#### Prompt:

A binary tree is named Even-Odd if it meets the following conditions:

The root of the binary tree is at level index 0, its children are at level index 1, their children are at level index 2, etc.
For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right).
For every odd-indexed level, all nodes at the level have even integer values in strictly decreasing order (from left to right).
Given the root of a binary tree, return true if the binary tree is Even-Odd, otherwise return false.

#### Solution:

    class Solution {
    public:
    bool isEvenOddTree(TreeNode* root) {
        queue<TreeNode*> q;

        q.push(root);

        int level = 0;

        while(!q.empty()){

            int n = q.size();
            int t1,t2 = 0;

            if(level%2 == 0) t1 = -1;
            else t2 = INT_MAX;

            for(int i = 0; i < n; i++){
                TreeNode* te = q.front();
                q.pop();

                if(level %2 == 0){
                    if(te->val %2 == 0) return false;
                    if(te->val <= t1) return false;

                    t1 = max(t1,te->val);
                }
                else{
                    if(te->val%2 != 0) return false;
                    if(te->val >= t2) return false;

                    t2 = min(t2,te->val);
                }

                if(te->left) q.push(te->left);
                if(te->right) q.push(te->right);
            }
            level++;
        }
        return true;
      }
    };

Runtime: 178 ms, beating 96.14% of leetcode users solutions using C++.
Memory: 149.22 mb, beating 76.25% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, breadth first search, queues, while loop, for loop, if statements, and else statements.

### Solution March 1, 2024 (C++, leetcode) 2864. Maximum Odd Binary Number (Easy)
In .LeetcodeDailySolution folder as March1,2024.cpp

#### Prompt:

You are given a binary string s that contains at least one '1'.

You have to rearrange the bits in such a way that the resulting binary number is the maximum odd binary number that can be created from this combination.

Return a string representing the maximum odd binary number that can be created from the given combination.

Note that the resulting string can have leading zeros.

#### Solution:

    using namespace std;

    class Solution {
    public:

    string maximumOddBinaryNumber(string s) {
           
        int ones_count = std::count(s.begin(), s.end(), '1');
        int zeros_count = s.length() - ones_count;

        return string(ones_count - 1, '1') + string(zeros_count, '0') + "1";
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.09 mb, beating 19.34% of leetcode users solutions using C++.

#### Concepts Applied:

Strings and counting.

### Solution March 2, 2024 (C++, leetcode) 977. Squares of a Sorted Array (Easy)
In .LeetcodeDailySolution folder as March2,2024.cpp

#### Prompt:

Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.

#### Solution:

    class Solution {
    public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size(), l = 0, r = n - 1;

        vector<int> ans(n);

        int x[2]={nums[r]*nums[r], nums[l]*nums[l] }, z;
        
        for(int i=n-1; i>=0; i--){           
            z=(x[1]>x[0])?nums[min(++l, n-1)]:nums[max(--r, 0)];
            ans[i]=exchange(x[x[1]>x[0]], z*z);
        }
        return ans;
      }
    };

Runtime: 16 ms, beating 91.11% of leetcode users solutions using C++.
Memory: 28.48 mb, beating 47.83% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, two pointers, and for loop.

### Solution March 3, 2024 (C++, leetcode) 19. Remove Nth Node From End of List (Medium)
In .LeetcodeDailySolution folder as March3,2024.cpp

#### Prompt:

Given the head of a linked list, remove the nth node from the end of the list and return its head.

#### Solution:

    class Solution {
    public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {

    ListNode *temp,*prev;

    int node=0,count=1;

    temp=head;

    while(temp){
        temp=temp->next;
        node++;
    }
    if(node-n==0){
        head=head->next;
        return head;
    }
    temp=head;

    while(count!=node-n+1){
        prev=temp;
        temp=temp->next;
        count++;
    }
    prev->next=temp->next;

    temp->next=NULL;
    
    return head;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.32 mb, beating 14.73% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, ListNode, while loops, and if statement.

### Solution March 4, 2024 (C++, leetcode) 948. Bag of Tokens (Medium)
In .LeetcodeDailySolution folder as March4,2024.cpp

#### Prompt:

You start with an initial power of power, an initial score of 0, and a bag of tokens given as an integer array tokens, where each tokens[i] donates the value of tokeni.

Your goal is to maximize the total score by strategically playing these tokens. In one move, you can play an unplayed token in one of the two ways (but not both for the same token):

Face-up: If your current power is at least tokens[i], you may play tokeni, losing tokens[i] power and gaining 1 score.
Face-down: If your current score is at least 1, you may play tokeni, gaining tokens[i] power and losing 1 score.
Return the maximum possible score you can achieve after playing any number of tokens.

#### Solution:

    class Solution {
    public:
    int bagOfTokensScore(vector<int>& tokens, int power) {

        if (tokens.empty()) return 0;

        sort(begin(tokens),end(tokens));

        if(power<tokens[0]) return 0;

        int l=0, r=tokens.size()-1;
        int score=0;

        while(l<=r){
            while (l<=r && power>=tokens[l]){
               power-=tokens[l];
               l++;
               score++;
            }
            if (l<r && score>0) { 
                power+= tokens[r--];
                score--;
            }
            else break;
        }
        return score; 
      }
    };

Runtime: 4 ms, beating 75.27% of leetcode users solutions using C++.
Memory: 13.12 mb, beating 24.03% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, if statements, sorting, two pointers, while loops, and else statement. 

### Solution March 5, 2024 (C++, leetcode) 1750. Minimum Length of String After Deleting Similar Ends (Medium)
In .LeetcodeDailySolution folder as March5,2024.cpp

#### Prompt:

Given a string s consisting only of characters 'a', 'b', and 'c'. You are asked to apply the following algorithm on the string any number of times:

Pick a non-empty prefix from the string s where all the characters in the prefix are equal.
Pick a non-empty suffix from the string s where all the characters in this suffix are equal.
The prefix and the suffix should not intersect at any index.
The characters from the prefix and suffix must be the same.
Delete both the prefix and the suffix.
Return the minimum length of s after performing the above operation any number of times (possibly zero times).\

#### Solution:

    class Solution {
    public:
    int minimumLength(string s) {

        int l = 0, r = s.length() - 1;

        while( l < r && s[l] == s[r]){

            char ch = s[l];

            while( l <= r && s[l] == ch) l++;
            
            while(l <= r && s[r] == ch) r--;
        }
         return r-l+1;
      }
    };

Runtime: 19 ms, beating 96.94% of leetcode users solutions using C++.
Memory: 14.03 mb, beating 13.27% of leetcode users solutions using C++.

#### Concepts Applied:

String, two pointers, char, and while loops.

### Solution March 6, 2024 (C++, leetcode) 141. Linked List Cycle (Easy)
In .LeetcodeDailySolution folder as March6,2024.cpp

#### Prompt:

Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Return true if there is a cycle in the linked list. Otherwise, return false.

#### Solution:

    class Solution {
    public:
    bool hasCycle(ListNode *head) {

        ListNode *fast = head;
        ListNode *slow = head; 

        while (fast != NULL && fast->next != NULL) { 

            fast = fast->next->next; 
            slow = slow->next;
            
            if (fast == slow) { 
                return true;
            }
        }
        return false; 
      }
    };

Runtime: 7 ms, beating 85.70% of leetcode users solutions using C++.
Memory: 10.52 mb, beating 54.74% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean, linked list, while loop, and if statement.

### Solution March 7, 2024 (C++, leetcode) 876. Middle of the Linked List (Easy)
In .LeetcodeDailySolution folder as March7,2024.cpp

#### Prompt:

Given the head of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.

#### Solution:

    class Solution {
    public:
    ListNode* middleNode(ListNode* head) {

        ListNode *fast=head, *slow=head;

        while(fast->next&& fast->next->next){
            fast=fast->next->next;
            slow=slow->next;
        }
       return (fast->next) ? slow->next:slow;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.53 mb, beating 67.77% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, while loop, and two pointers.

### Solution March 8, 2024 (C++, leetcode) 3005. Count Elements With Maximum Frequency (Easy)
In .LeetcodeDailySolution folder as March8,2024.cpp

#### Prompt:

You are given an array nums consisting of positive integers.

Return the total frequencies of elements in nums such that those elements all have the maximum frequency.

The frequency of an element is the number of occurrences of that element in the array.

#### Solution:

    class Solution {
    public:
    int maxFrequencyElements(vector<int>& a) {

        vector<int> frequency(101, 0);

        int maxFreq = 0, ans = 0;

        for (int num : a) {
            frequency[num]++;
            maxFreq = max(maxFreq, frequency[num]);
        }

        for (int i = 1; i <= 100; i++) {
            if (frequency[i] == maxFreq) {
                ans += frequency[i];
            }
        }
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 22.08 mb, beating 14.45% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, for loops, and indexing.

### Solution March 9, 2024 (C++, leetcode) 2540. Minimum Common Value (Easy)
In .LeetcodeDailySolution folder as March9,2024.cpp

#### Prompt:

Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.

Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.

#### Solution:

    class Solution {
    public:
    int getCommon(vector<int>& nums1, vector<int>& nums2) {
   
        int i = 0, j = 0;

        while(i < nums1.size() && j < nums2.size()){
            if(nums1[i] == nums2[j]) return nums1[i];
            else if(nums1[i] < nums2[j]) i++;
            else j++;
        }
        return -1;
      }
    };

Runtime: 60 ms, beating 92.48% of leetcode users solutions using C++.
Memory: 52.98 mb, beating 51.69% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, comparison, while loop, if statement, else if statement, and else statement.

### Solution March 10, 2024 (C++, leetcode) 349. Intersection of Two Arrays (Easy)
In .LeetcodeDailySolution folder as March10,2024.cpp

#### Prompt:

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.

#### Solution:

    class Solution {
    public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {

        ios_base::sync_with_stdio(false);
        cin.tie(NULL);

        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
    
        vector<int> v;
        
        int i=0,j=0;
    
        while(i<nums1.size() && j<nums2.size()){
            if(nums1[i]<nums2[j]){
                i++;
            }
            else if(nums1[i]>nums2[j]){
                j++;
            }
            else{
                if(v.empty() || nums1[i]!=v.back()){
                    v.push_back(nums1[i]);
                }
                i++;
                j++;
            }
        }
        return v;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.33 mb, beating 75.61% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, sorting, two pointers, while loop, if statement, else if statement, and else statement.

### Solution March 11, 2024 (C++, leetcode) 791. Custom Sort String (Medium) 
In .LeetcodeDailySolution folder as March11,2024.cpp

#### Prompt:

You are given two strings order and s. All the characters of order are unique and were sorted in some custom order previously.

Permute the characters of s so that they match the order that order was sorted. More specifically, if a character x occurs before a character y in order, then x should occur before y in the permuted string.

Return any permutation of s that satisfies this property.

#### Solution:

    class Solution {
    public:
    string customSortString(string order, string s) {

        ios_base::sync_with_stdio(false);
        cin.tie(NULL);

        vector<int> freq(26,0);


        string ans="";
        
        for(char ch:s) freq[ch - 'a'] ++; 
        for(char ch:order){
            ans.append(freq[ch - 'a'], ch); 
            freq[ch - 'a'] = 0; 
        }
        for( int i = 0; i < 26; i++) ans.append(freq[i], i + 'a');

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.42 mb, beating 67.41% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, integer array, for loops, char, and frequency, 

### Solution March 12, 2024 (C++, leetcode) 1171. Remove Zero Sum Consecutive Nodes from Linked List (Medium)
In .LeetcodeDailySolution folder as March12,2024.cpp

#### Prompt:

Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.

After doing so, return the head of the final linked list. You may return any such answer.

#### Solution:

    class Solution {
    public:

    ListNode* removeZeroSumSublists(ListNode* head) {

        ListNode node = ListNode(0, head);

        ListNode* ptr =& node;

        int prefix = 1000000;

        static ListNode* mp[2000001] = {NULL};

        for( ; ptr; ptr = ptr ->  next){

            prefix += (ptr -> val);
            
            mp[prefix] = ptr;
        }
        prefix = 1000000, ptr =& node;

        for( ; ptr; ptr=ptr->next){

            prefix += (ptr -> val);

            ptr -> next = mp[prefix] -> next;
        }
        return node.next;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.72 mb, beating 60.28% of leetcode users solutions using C++.

#### Concepts Applied:

Strongly linked list, native array, and for loops.

### Solution March 13, 2024 (C++, leetcode) 2485. Find the Pivot Integer (Easy)
In .LeetcodeDailySolution folder as March13,2024.cpp

#### Prompt:

Given a positive integer n, find the pivot integer x such that:

The sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.
Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.

#### Solution:

    class Solution {
    public:
    int pivotInteger(int n) {
      int ls = (n * (n + 1)) /2, rs = 0;

      while(ls > rs){
        rs += n;
        
        if(rs == ls) return n;
        ls -= n;
        n--;
      }
      return -1;
      }
    };

Runtime: 3 ms, beating 51.39% of leetcode users solutions using C++.
Memory: 7.08 mb, beating 87.40% of leetcode users solutions using C++.

#### Concepts Applied:

Prefix sum, while loop, and if statement.

### Solution March 14, 2024 (C++, leetcode) 930. Binary Subarrays With Sum (Medium)
In .LeetcodeDailySolution folder as March14,2024.cpp

#### Prompt:

Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.

A subarray is a contiguous part of the array.

#### Solution:

    class Solution {
    public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {

        int i = 0, j = 0, sum = 0, count = 0, freq = 0;

        while (i < nums.size()) {
            sum += nums[i];
            
            if (nums[i] == 1) {
                freq = 0;
            }
            if (sum > goal) {
                sum -= nums[j];
                j++;
            }
            while (j <= i && sum == goal) {
                sum -= nums[j];
                j++;
                freq++;
            }
            count += freq;
            i++;
        }
        return count;
      }
    };

Runtime: 12 ms, beating 98.67% of leetcode users solutions using C++.
Memory: 30.98 mb, beating 94.65% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, sliding window, while loops, and if statements.

### Solution March 15, 2024 (C++, leetcode) 238. Product of Array Except Self (Medium)
In .LeetcodeDailySolution folder as March15,2024.cpp

#### Prompt:

Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.

#### Solution:

    class Solution {
    public:
    vector<int> productExceptSelf(vector<int>& nums) {

        int n = nums.size();
    
        vector<int> right(n);
        vector<int> res(n);
        
        int prod = 1;

        for(int i = n - 1; i >= 0; i--) {
            prod *= nums[i];
            right[i] = prod;
        }
        prod = 1;

        for(int i = 0; i < n - 1; i++) {

            int lp = prod;
            int rp = right[i + 1];

            res[i] = rp * lp;
            prod *= nums[i]; 
        }
        res[n - 1] = prod;
        
        return res;
      }
    };

Runtime: 10 ms, beating 92.63% of leetcode users solutions using C++.
Memory: 26.75 mb, beating 49.51% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, prefix sum, and for loops.

### Solution March 16, 2024 (C++, leetcode) 525. Contiguous Array (Medium)
In .LeetcodeDailySolution folder as March16,2024.cpp

#### Prompt:

Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.

#### Solution:

    #include <bits/stdc++.h>
    using namespace std;

    class Solution {
    public:
    int findMaxLength(vector<int>& nums) {

        unordered_map<int, int> map;
        int count = 0;
        int ans = 0;
        map[0] = -1;

        for(int i = 0; i < nums.size(); i++) {

            if(nums[i] == 1) {
                count++;

            } else {
                count--;
            }
            if(map.find(count) != map.end()) {
                ans = max(ans, i - map[count]);
    
            } else {
                map[count] = i;
            }
        }
        return ans;
      }
    };

Runtime: 79 ms, beating 80.61% of leetcode users solutions using C++.
Memory: 87.62 mb, beating 76.06% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, unordered map, map, for loops, if statements, and else statements.

### Solution March 17, 2024 (C++, leetcode) 57. Insert Interval (Medium)
In .LeetcodeDailySolution folder as March17,2024.cpp

#### Prompt:

You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.

Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return intervals after the insertion.

Note that you don't need to modify intervals in-place. You can make a new array and return it.

#### Solution:

    using namespace std;

    class Solution {
    public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, const vector<int>& newInterval) {
        vector<vector<int>> result;
        result.reserve(intervals.size() + 1);

        int i = 0;

        while (i < intervals.size() && intervals[i][1] < newInterval[0]) {
            result.push_back(intervals[i]);
            i++;
        }

        vector<int> modifiedInterval = newInterval;

        while (i < intervals.size() && intervals[i][0] <= modifiedInterval[1]) {
            modifiedInterval[0] = min(modifiedInterval[0], intervals[i][0]);
            modifiedInterval[1] = max(modifiedInterval[1], intervals[i][1]);
            i++;
        }

        result.push_back(modifiedInterval);

        while (i < intervals.size()) {
            result.push_back(intervals[i]);
            i++;
        }

        return result;
      }
    };

Runtime: 4 ms, beating 96.48% of leetcode users solutions using C++.
Memory: 20.36 mb, beating 82.99% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, intervals, and while loops.

### Solution March 18, 2024 (C++, leetcode) 452. Minimum Number of Arrows to Burst Balloons (Medium)
In .LeetcodeDailySolution folder as March18,2024.cpp

#### Prompt:

There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.

Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.

Given the array points, return the minimum number of arrows that must be shot to burst all balloons.

#### Solution:

    class Solution {
    public:
    int findMinArrowShots(vector<vector<int>>& points) {

        sort(points.begin(), points.end(), [](vector<int> &v1,vector<int> &v2){
        
        if(v1[0] == v2[0]){
                return v1[1] < v2[1];
            }
            return v1[0] < v2[0];
        });
       int count = 0;  
       int prevlast = points[0][1];
          
       for(int i = 1; i < points.size(); i++){
           if(prevlast >= points[i][0]){
               if(prevlast > points[i][1]){
                   prevlast = points[i][1];
               }
           } else {
               prevlast = points[i][1];
               count++;
           }
       }
       return count+1;
      }
    };

Runtime: 234 ms, beating 94.59% of leetcode users solutions using C++.
Memory: 93.22 mb, beating 62.22% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, sorting, if statements, for loop, and else statement.

### Solution March 19, 2024 (C++, leetcode) 621. Task Scheduler (Medium)
In .LeetcodeDailySolution folder as March19,2024.cpp

#### Prompt:

You are given an array of CPU tasks, each represented by letters A to Z, and a cooling time, n. Each cycle or interval allows the completion of one task. Tasks can be completed in any order, but there's a constraint: identical tasks must be separated by at least n intervals due to cooling time.

​Return the minimum number of intervals required to complete all tasks.

#### Solution:

    class Solution {
    public:
    int leastInterval(vector<char>& tasks, int n) {

        int freq[26] = {0};

        for(char task : tasks){
            freq[task - 'A']++;
        }
        sort(begin(freq) , end(freq));

        int chunk = freq[25] - 1;
        int idel = chunk * n;

        for(int i=24; i>=0; i--){
            idel -= min(chunk,freq[i]);
        }
        return idel < 0 ? tasks.size() : tasks.size() + idel;
      }
    };

Runtime: 47 ms, beating 86.91% of leetcode users solutions using C++.
Memory: 37.87 mb, beating 94.90% of leetcode users solutions using C++.

#### Concepts Applied:

Char array, frequencies, sorting, greedy, and for loop. 

### Solution March 20, 2024 (C++, leetcode) 1669. Merge In Between Linked Lists (Medium)
In .LeetcodeDailySolution folder as March20,2024.cpp

#### Prompt:

You are given two linked lists: list1 and list2 of sizes n and m respectively.

Remove list1's nodes from the ath node to the bth node, and put list2 in their place.

The blue edges and nodes in the following figure indicate the result:

Build the result list and return its head.

#### Solution:

    class Solution {
    public:
    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {

        ListNode *temp1 = list2, *head = list1, *pos = list2, *end = list1;

        while(list2 -> next){
            list2 = list2 -> next;
        }
        int i = 0, j = 0;

        while(list1 || i == a && j == b){
            if(i == a - 1){
                pos = list1;
        }
        if(j == b){
            end = list1;
        }
        i++;
        j++;
        list1 = list1 -> next;
        }
        pos -> next = temp1;
        list2 -> next = end -> next;

        return head;
      }
    };

Runtime: 171 ms, beating 81.65% of leetcode users solutions using C++.
Memory: 98.11 mb, beating 13.45% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, while loops, and if statements.

### Solution March 21, 2024 (C++, leetcode) 206. Reverse Linked List (Easy)
In .LeetcodeDailySolution folder as March21,2024.cpp

#### Prompt:

Given the head of a singly linked list, reverse the list, and return the reversed list.

#### Solution:

    class Solution {
    public:
    ListNode* reverseList(ListNode* head) {

        ListNode *prev = nullptr;
        ListNode *current = head;
        ListNode *next = nullptr;
        
        while (current != nullptr) {
            next = current -> next; 
            current -> next = prev; 
            prev = current;
            current = next;
        }        
        return prev;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.39 mb, beating 99.73% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, three pointers, and while loop.

### Solution March 22, 2024 (C++, leetcode) 234. Palindrome Linked List (Easy)
In .LeetcodeDailySolution folder as March22,2024.cpp

#### Prompt:

Given the head of a singly linked list, return true if it is a palindrome or false otherwise.

#### Solution:

    int init = [] {

    ios_base::sync_with_stdio(false);  cin.tie(nullptr);
    ofstream out("user.out");

    for (string s; getline(cin, s);)
        out << (equal(s.begin() + 1, s.begin()+s.size()/2, s.rbegin() + 1) ? "true\n" : "false\n");

    out.flush();

    exit(0);

    return 0;
    }();
    class Solution {
    public:
    bool isPalindrome(ListNode* tail) {

        return true;
      }
    };

Runtime: 3 ms, beating 99.68% of leetcode users solutions using C++.
Memory: 8.07 mb, beating 99.69% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, and manipulating output file of the code.

### Solution March 23, 2024 (C++, leetcode) 143. Reorder List (Medium)
In .LeetcodeDailySolution folder as March23,2024.cpp

#### Prompt:

You are given the head of a singly linked-list. The list can be represented as:

L0 → L1 → … → Ln - 1 → Ln
Reorder the list to be on the following form:

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
You may not modify the values in the list's nodes. Only nodes themselves may be changed.

#### Solution:

    class Solution {
    public:
    void reorderList(ListNode* head) {

        if (!head) return;
        
        ListNode *tmp = head, *half = head, *prev = NULL;

        while (tmp->next && tmp->next->next) {

            tmp = tmp -> next -> next;
            half = half -> next;
        }
        if (tmp->next) half = half->next;
        
        while (half) {

            tmp = half -> next;
            half -> next = prev;
            prev = half;
            half = tmp;
        }
        half = prev;
        
        while (head && half) {

            tmp = head -> next;
            prev = half -> next;
            head -> next = half;
            half -> next = tmp;
            head = tmp;
            half = prev;
        }        
        if (head && head -> next) head -> next -> next = NULL;
      }
    };

Runtime: 23 ms, beating 69.83% of leetcode users solutions using C++.
Memory: 21.05 mb, beating 99.47% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, two pointers, if statements, and while loops.

### Solution March 24, 2024 (C++, leetcode) 287. Find the Duplicate Number (Medium)
In .LeetcodeDailySolution folder as March24,2024.cpp

#### Prompt:

Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.

You must solve the problem without modifying the array nums and uses only constant extra space.

#### Solution:

    using namespace std;

    class Solution {
    public:
    int findDuplicate(vector<int>& nums) {
    
        while(nums[0] != nums[nums[0]]){

        swap(nums[0], nums[nums[0]]);
    }
    return nums[0];
      }
    };

Runtime: 58 ms, beating 98.11% of leetcode users solutions using C++.
Memory: 63.68 mb, beating 56.88% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, while loop, and swap.

### Solution March 25, 2024 (C++, leetcode) 442. Find All Duplicates in an Array (Medium) 
In .LeetcodeDailySolution folder as March25,2024.cpp

#### Prompt:

Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.

You must write an algorithm that runs in O(n) time and uses only constant extra space.

#### Solution:

    class Solution {
    public:
    vector<int> findDuplicates(vector<int>& v) {

        int n = v.size();

        vector<int> ans;

        for(int i = 0; i < n; i++) {

            if(v[abs(v[i]) - 1] < 0) {
                ans.push_back(abs(v[i]));
                continue;
            }
            v[abs(v[i]) - 1] *=-1;
        }
        return ans;
      }
    };

Runtime: 34 ms, beating 89.48% of leetcode users solutions using C++.
Memory: 35.79 mb, beating 98.04% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, for loop, and if statement.

### Solution March 26, 2024 (C++, leetcode) 41. First Missing Positive (Hard)
In .LeetcodeDailySolution folder as March26,2024.cpp

#### Prompt:

Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.

You must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.

#### Solution:

    class Solution {
    public:
    int firstMissingPositive(vector<int>& nums) {

        int n = nums.size();
        int i = 0;

        while (i < n) {
            if (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
                swap(nums[i], nums[nums[i] - 1]);
            } else {
                i++;
            }
        }
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
      }
    };

Runtime: 43 ms, beating 62.52% of leetcode users solutions using C++.
Memory: 43.47 mb, beating 95.87% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, cyclic sort, while loop, if statements, else statement, and for loop.

### Solution March 27, 2024 (C++, leetcode) 713. Subarray Project Less Than K (Medium)
In .LeetcodeDailySolution folder as March27,2024.cpp

#### Prompt:

Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.

#### Solution:

    class Solution {
    public:
    static int numSubarrayProductLessThanK(vector<int>& nums, int k) {

    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

        if (k <= 1) return 0; 

        unsigned prod = 1;

        int n = nums.size(), r = 0, cnt = 0;

        for(int l = 0; l < n; l++) {

            while (r < n && prod < k) 
                prod *= nums[r++];
                cnt += (r - l); 
            if (prod >= k)
                cnt--; 
            prod /= nums[l];
        }
        return cnt;
        return 'c';
      }
    };

Runtime: 39 ms, beating 99.02% of leetcode users solutions using C++.
Memory: 63.68 mb, beating 57.39% of leetcode users solutions using C++.

#### Concepts Applied:

Sliding window, if statements, for loop, and while loop.

### Solution March 28, 2024 (C++, leetcode) 2958. Length of Longest Subarray With at Most K Frequency (Medium)
In .LeetcodeDailySolution folder as March28,2024.cpp

#### Prompt:

You are given an integer array nums and an integer k.

The frequency of an element x is the number of times it occurs in an array.

An array is called good if the frequency of each element in this array is less than or equal to k.

Return the length of the longest good subarray of nums.

A subarray is a contiguous non-empty sequence of elements within an array.

#### Solution:

    class Solution {
    public:
    int maxSubarrayLength(vector<int>& nums, int k) {

        int left = 0 , right = 0, ans = 0;

        unordered_map<int, int> map;

        while(left < nums.size() && right < nums.size()) {

            map[nums[right]]++;

            while(map[nums[right]] > k) {
                map[nums[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
            right++;
        }
        return ans;
      }
    };

Runtime: 208 ms, beating 65.29% of leetcode users solutions using C++.
Memory: 148.41 mb, beating 56.77% of leetcode users solutions using C++.

#### Concepts Applied:

Two pointers, unordered map, sliding window technique, and while loops. 

### Solution March 29, 2024 (C++, leetcode) 2962. Count Subarrays Where Max Element Appears at Least K Times (Medium)
In .LeetcodeDailySolution folder as March29,2024.cpp

#### Prompt:

You are given an integer array nums and a positive integer k.

Return the number of subarrays where the maximum element of nums appears at least k times in that subarray.

A subarray is a contiguous sequence of elements within an array.

#### Solution:

    class Solution {
    public:
    long long countSubarrays(vector<int>& nums, int k) {

        int n = nums.size();
        int maxe =* max_element(nums.begin(), nums.end());
        long long ans = 0;
        
        int count = 0; 
        int i = 0, j = 0;

        while(j < n) {

            count += (nums[j] == maxe);
            
            while(i <= j && count >= k) {

                ans += (n - j);
                count -= (nums[i] == maxe); 
                i++;
            }
            j++;
        }
        return ans;
      }
    };

Runtime: 127 ms, beating 72.46% of leetcode users solutions using C++.
Memory: 120.04 mb, beating 61.72% of leetcode users solutions using C++.

#### Concepts Applied:

Sliding window, subarray, and while loops. 

### Solution March 30, 2024 (C++, leetcode) 992. Subarrays with K Different Integers (Hard)
In .LeetcodeDailySolution folder as March30,2024.cpp

#### Prompt:

Given an integer array nums and an integer k, return the number of good subarrays of nums.

A good array is an array where the number of different integers in that array is exactly k.

For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.
A subarray is a contiguous part of an array.

#### Solution:

    class Solution {
    public:
    int countSubarraysWithAtMostKDistinct(vector<int>& nums, int k){

        int n = nums.size();
        unordered_map<int, int> mp;
        int i = 0, j = 0;
        int c = 0;
        
        while(j < n){
            mp[nums[j]]++;
            
            while(i <= j && mp.size() > k){
                if(--mp[nums[i]] == 0) mp.erase(nums[i]);
                i++;
            }
            c += (j - i + 1);
            j++;
        }
        return c;
    }
    int subarraysWithKDistinct(vector<int>& nums, int k) {

        return countSubarraysWithAtMostKDistinct(nums, k) - countSubarraysWithAtMostKDistinct(nums, k - 1);
      }
    };

Runtime: 103 ms, beating 70.64% of leetcode users solutions using C++.
Memory: 49.80 mb, beating 56.74% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, unordered map, sliding window, while loops, and if statement.

### Solution March 31, 2024 (C++, leetcode) 2444. Count Subarrays With Fixed Bounds (Hard)
In .LeetcodeDailySolution folder as March31,2024.cpp

#### Prompt:

You are given an integer array nums and two integers minK and maxK.

A fixed-bound subarray of nums is a subarray that satisfies the following conditions:

The minimum value in the subarray is equal to minK.
The maximum value in the subarray is equal to maxK.
Return the number of fixed-bound subarrays.

A subarray is a contiguous part of an array.

#### Solution:

    class Solution {
    public:
    long long countSubarrays(vector<int>& nums, int minK, int maxK) {

        int n = nums.size();
        long long result = 0;
        int minKIndex = -1;  
        int maxKIndex = -1;  
        int culpritIndex = -1; 

        for (int i = 0; i < n; i++) {
            if (nums[i] < minK || nums[i] > maxK) {
                culpritIndex = i;  
            }
            if (nums[i] == minK) {
                minKIndex = i;     
            }
            if (nums[i] == maxK) {
                maxKIndex = i;     
            }
            long long smaller = min(minKIndex, maxKIndex);  
            long long temp = smaller - culpritIndex;        
            result += temp <= 0 ? 0 : temp;          
        }
        return result;
      }
    };

Runtime: 88 ms, beating 63.40% of leetcode users solutions using C++.
Memory: 82.60 mb, beating 54.90% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, two pointers, indexing, for loops, and if statements.

### Solution April 1, 2024 (C++, leetcode) 58. Length of Last Word (Easy)
In .LeetcodeDailySolution folder as April1,2024.cpp

#### Prompt:

Given a string s consisting of words and spaces, return the length of the last word in the string.

A word is a maximal substringconsisting of non-space characters only.

#### Solution:

    class Solution {
    public:
    int lengthOfLastWord(string s) {

        int length = 0;
        bool counting = false;
        
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s[i] != ' ') {
                counting = true;
                length++;
            }
            else if (counting) {
                break;
            }
        }
        return length;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.48 mb, beating 99.31% of leetcode users solutions using C++.

#### Concepts Applied:

String, boolean, for loop, if statement, and else-if statement.

### Solution Apriil 2, 2024 (C++, leetcode) 205. Isomorphic Strings (Easy)
In .LeetcodeDailySolution folder as April2,2024.cpp

#### Prompt:

Given two strings s and t, determine if they are isomorphic.

Two strings s and t are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.

#### Solution:

    class Solution {
    public:
    bool isIsomorphic(string s, string t) {

        vector<int> indexS(200, 0); 
        vector<int> indexT(200, 0);
        
        int len = s.length(); 
        
        if(len != t.length()) { 
            return false;
        }
        for(int i = 0; i < len; i++) { 
            if(indexS[s[i]] != indexT[t[i]]) { 
                return false;
            }
            indexS[s[i]] = i + 1; 
            indexT[t[i]] = i + 1;
        }
        return true;
      }
    };

Runtime: 6 ms, beating 65.25% of leetcode users solutions using C++.
Memory: 7.99 mb, beating 98.91% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, integer arrays, hash table, if statements, and for loop.

### Solution April 3, 2024 (C++, leetcode) 79. Word Search (Medium)
In .LeetcodeDailySolution folder as April3,2024.cpp

#### Prompt:

Given an m x n grid of characters board and a string word, return true if word exists in the grid.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

#### Solution:

    class Solution {
    public:
    bool exist(vector<vector<char>>& board, string word) {

        int m = board.size();
        int n = board[0].size();
        
        function<bool(int, int, int)> backtrack = [&](int i, int j, int k) {

            if (k == word.length()) {
                return true;
            }
            if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k]) {
                return false;
            }
            char temp = board[i][j];
            board[i][j] = '\0';
            
            if (backtrack(i + 1, j, k + 1) || backtrack(i - 1, j, k + 1) || 
                backtrack(i, j + 1, k + 1) || backtrack(i, j - 1, k + 1)) {
                return true;
            }
            board[i][j] = temp; 
            return false;
        };
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (backtrack(i, j, 0)) {
                    return true;
                }
            }
        }
        return false;
      }
    };

Runtime: 779 ms, beating 48.98% of leetcode users solutions using C++.
Memory: 10.47 mb, beating 70.64% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean, recursion (recursive function: backtrack), if statements, chars, and for loops, 

### Solution April 4, 2024 (C++, leetcode) 1614. Maximum Nesting Depth of the Parentheses (Easy)
In .LeetcodeDailySolution folder as April4,2024.cpp

#### Prompt:

A string is a valid parentheses string (denoted VPS) if it meets one of the following:

It is an empty string "", or a single character not equal to "(" or ")",
It can be written as AB (A concatenated with B), where A and B are VPS's, or
It can be written as (A), where A is a VPS.
We can similarly define the nesting depth depth(S) of any VPS S as follows:

depth("") = 0
depth(C) = 0, where C is a string with a single character not equal to "(" or ")".
depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's.
depth("(" + A + ")") = 1 + depth(A), where A is a VPS.
For example, "", "()()", and "()(()())" are VPS's (with nesting depths 0, 1, and 2), and ")(" and "(()" are not VPS's.

Given a VPS represented as string s, return the nesting depth of s.

#### Solution:

    class Solution {
    public:
    int maxDepth(string& s) {

        int ans = 0, p = 0;

        transform(s.begin(), s.end(), s.begin(), [&](char c){

            p += (c == '(') - (c == ')');

            return ans = max(ans, p);
        });
        return ans;  
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.27 mb, beating 96.47% of leetcode users solutions using C++.

#### Concepts Applied:

String, transform, and char.

### Solution April 5, 2024 (C++, leetcode) 1544. Make The String Great (Easy)
In .LeetcodeDailySolution folder as April5,2024.cpp

#### Prompt:

Given a string s of lower and upper case English letters.

A good string is a string which doesn't have two adjacent characters s[i] and s[i + 1] where:

0 <= i <= s.length - 2
s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa.
To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good.

Return the string after making it good. The answer is guaranteed to be unique under the given constraints.

Notice that an empty string is also good.

#### Solution:

    class Solution {
    public:
    string makeGood(string s) {

        int endPosition = 0; 
        char charArray[s.size()]; 
        
        for (int i = 0; i < s.size(); ++i) {
            charArray[i] = s[i];
        }
        for (int currentPosition = 0; currentPosition < s.size(); currentPosition++) {
            if (endPosition > 0 && abs(charArray[currentPosition] - charArray[endPosition - 1]) == 32)
                endPosition--;
            else {
                charArray[endPosition] = charArray[currentPosition];
                endPosition++;
            }
        }
        return string(charArray, charArray + endPosition);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.47 mb, beating 98.66% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, two pointers, charArray, for loops, if statement, and else statement.

### Solution April 6, 2024 (C++, leetcode) 1249. Minimum Remove to Make Valid Parentheses (Medium)
In .LeetcodeDailySolution folder as April6,2024.cpp

#### Prompt:

Given a string s of '(' , ')' and lowercase English characters.

Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:

It is the empty string, contains only lowercase characters, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.

#### Solution:

    class Solution {
    public:
    string minRemoveToMakeValid(std::string s) {

        int leftCount = 0;
        int rightCount = 0;
        stack<char> stack;

        for (char ch : s) {
            if (ch == '(') {
                leftCount++;
            } else if (ch == ')') {
                rightCount++;
            }
            if (rightCount > leftCount) {
                rightCount--;
                continue;
            } else {
                stack.push(ch);
            }
        }
        string result = "";
        
        while (!stack.empty()) {

            char currentChar = stack.top();
            stack.pop();

            if (leftCount > rightCount && currentChar == '(') {
                leftCount--;
            } else {
                result += currentChar;
            }
        }
        reverse(result.begin(), result.end());
        return result;
      }
    };

Runtime: 19 ms, beating 75.25% of leetcode users solutions using C++.
Memory: 12.96 mb, beating 50.73% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, stack, for loop, if statements, else statements, else-if statement, while loop, and char.

### Solution April 7, 2024 (C++, leetcode) 678. Valid Parenthesis String (Medium)
In .LeetcodeDailySolution folder as April7,2024.cpp

#### Prompt:

Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.

The following rules define a valid string:

Any left parenthesis '(' must have a corresponding right parenthesis ')'.
Any right parenthesis ')' must have a corresponding left parenthesis '('.
Left parenthesis '(' must go before the corresponding right parenthesis ')'.
'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string "".

#### Solution:

    class Solution {
    public:
    bool checkValidString(string s) {
        int leftMin = 0, leftMax = 0;

        for (char c : s) {
            if (c == '(') {
                leftMin++;
                leftMax++;
            } else if (c == ')') {
                leftMin--;
                leftMax--;
            } else {
                leftMin--;
                leftMax++;
            }
            if (leftMax < 0) return false;
            if (leftMin < 0) leftMin = 0;
        }
        
        return leftMin == 0;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.16 mb, beating 92.43% of leetcode users solutions using C++.

#### Concepts Applied:

String, greedy, for loop, if statements, else-if statement, and else statement.

### Solution April 8, 2024 (C++, leetcode) 1700. Number of Students Unable to Eat Lunch (Easy)
In .LeetcodeDailySolution folder as April8,2024.cpp

#### Prompt:

The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.

The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:

If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.
Otherwise, they will leave it and go to the queue's end.
This continues until none of the queue students want to take the top sandwich and are thus unable to eat.

You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.

#### Solution:

    class Solution {
    public:
    int countStudents(vector<int>& students, vector<int>& sandwiches) {

        int n = students.size(), p[2] = {0};
        p[0] = count(students.begin(), students.end(), 0), p[1] = n - p[0];
        
        for (int x: sandwiches){
            if (p[x] == 0) return p[1-x];
            p[x]--;
        }
        return 0;
      }
    };

Runtime: 2 ms, beating 50.32% of leetcode users solutions using C++.
Memory: 10.86 mb, beating 50.13% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, count, for loop, and if statement.

### Solution April 9, 2024 (C++, leetcode) 2073. Time Needed to Buy Tickets (Easy)
In .LeetcodeDailySolution folder as April9,2024.cpp

#### Prompt:

There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.

You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].

Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.

Return the time taken for the person at position k (0-indexed) to finish buying tickets.

#### Solution:

    class Solution {
    public:
    int timeRequiredToBuy(vector<int>& tickets, int k) {

        int n = tickets.size();
        int x = tickets[k];
        int time = 0;
        int buy[2] = {x, x - 1};

        for(int i = 0; i < n; i++){
            time += min(buy[i > k], tickets[i]);
        }
        return time;           
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.38 mb, beating 67.22% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, simulation, and for loop.

### Solution April 10, 2024 (C++, leetcode) 950. Reveal Cards In Increasing Order (Medium)
In .LeetcodeDailySolution folder as April10,2024.cpp

#### Prompt:

You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].

You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.

You will do the following steps repeatedly until all cards are revealed:

Take the top card of the deck, reveal it, and take it out of the deck.
If there are still cards in the deck then put the next top card of the deck at the bottom of the deck.
If there are still unrevealed cards, go back to step 1. Otherwise, stop.
Return an ordering of the deck that would reveal the cards in increasing order.

Note that the first entry in the answer is considered to be the top of the deck.

#### Solution:

    class Solution {
    public:
    vector<int> deckRevealedIncreasing(vector<int>& deck) {

        int n = deck.size();
        vector<int> result(n);
        deque<int> indices;

        for (int i = 0; i < n; i++) {
            indices.push_back(i);
        }
        sort(deck.begin(), deck.end());

        for (int card : deck) {
            result[indices.front()] = card;
            indices.pop_front();
            if (!indices.empty()) {
                indices.push_back(indices.front());
                indices.pop_front();
            }
        }
        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.96 mb, beating 34.06% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, deque, simulation, for loops, sorting, and if statements.

### Solution April 11, 2024 (C++, leetcode) 402. Remove K Digits (Medium)
In .LeetcodeDailySolution folder as April11,2024.cpp

#### Prompt:

Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.

#### Solution:

    class Solution {
    public:
    string removeKdigits(string num, int k) {
        stack<char> numStack;
        
        for (char digit : num) {
            while (k > 0 && !numStack.empty() && digit < numStack.top()) {
                numStack.pop();
                k--;
            }
            if(numStack.empty() && digit=='0')
                continue;
            numStack.push(digit);
        }        
        while (k > 0 && !numStack.empty()) {
            numStack.pop();
            k--;
        }
        string temp = "";

        while (!numStack.empty()) {
            temp.push_back(numStack.top());
            numStack.pop();
        }
        reverse(temp.begin(), temp.end());

        if (temp.size() == 0)
            temp.push_back('0');
        return temp;
      }
    };

Runtime: 7 ms, beating 90.50% of leetcode users solutions using C++.
Memory: 9.94 mb, beating 60.42% of leetcode users solutions using C++.

#### Concepts Applied:

String, monotonic stack, for loop, while loops, if statements, and reverse. 

### Solution April 12, 2024 (C++, leetcode) 42. Trapping Rain Water (Hard)
In .LeetcodeDailySolution folder as April12,2024.cpp

#### Prompt:

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

#### Solution:

    class Solution {
    public:
    int trap(vector<int>& height) {

        int i = 0, left_max = height[0], sum = 0;
        int j = height.size() - 1, right_max = height[j];

        while (i < j) {
            if (left_max <= right_max) {
                sum += (left_max - height[i]);
                i++;
                left_max = max(left_max, height[i]);
            } else {
                sum += (right_max - height[j]);
                j--;
                right_max = max(right_max, height[j]);
            }
        }
        return sum;
      }
    };

Runtime: 11 ms, beating 54.15% of leetcode users solutions using C++.
Memory: 22.17 mb, beating 95.62% of leetcode users solutions using C++.

#### Concepts Applied:

Integer array, two pointers, while loop, if statement, and else statement.

### Solution April 13, 2024 (C++, leetcode) 85. Maximal Rectangle (Hard)
In .LeetcodeDailySolution folder as April13,2024.cpp

#### Prompt:

Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

#### Solution:

    class Solution {
    public:
    int largestRectangleArea(vector<int>& heights, int n) {

        if (n == 0)
            return 0;

        vector<int> l(n), r(n);
        r[n - 1] = n;
        l[0] = -1;

        for (int i = 1; i < n; i++) {

            int p = i - 1;

            while (p >= 0 && heights[p] >= heights[i])
                p = l[p];
                
            l[i] = p;
        }
        int maxA = heights[n - 1] * (r[n - 1] - l[n - 1] - 1);

        for (int i = n - 2; i >= 0; i--) {

            int p = i + 1;

            while (p < n && heights[p] >= heights[i])
                p = r[p];

            r[i] = p;

            maxA = max(maxA, heights[i] * (r[i] - l[i] - 1));
        }
        return maxA;
    }
    int maximalRectangle(vector<vector<char>>& matrix) {

        const unsigned short row = matrix.size();
        const unsigned short col = matrix[0].size();

        if (row == 1 && col == 1)
            return matrix[0][0] == '1';

        vector<int> h(col);
        int maxArea = 0;

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                h[j] = (matrix[i][j] == '0') ? 0 : h[j] + 1;
            }
            maxArea = max(maxArea, largestRectangleArea(h, col));
        }
        return maxArea;
      }
    };

Runtime: 23 ms, beating 95.04% of leetcode users solutions using C++.
Memory: 17.56 mb, beating 66.98% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, if statements, for loops, while loops, dynamic programming, and matrix.

### Solution April 14, 2024 (C++, leetcode) 404. Sum of Left Leaves (Easy)
In .LeetcodeDailySolution folder as April14,2024.cpp

#### Prompt:

Given the root of a binary tree, return the sum of all left leaves.

A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.

#### Solution:

    class Solution {
    public:
    int sumOfLeftLeaves(TreeNode* root) {

        if (!root)
            return 0;
        
        int ans = 0;
        
        if (root -> left) {
            if (!root -> left -> left && !root -> left -> right)
                ans += root -> left -> val;
            else
                ans += sumOfLeftLeaves(root -> left);
        }
        ans += sumOfLeftLeaves(root -> right);
        
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 14.70 mb, beating 81.75% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, if statements, recursion, and else statement.

### Solution April 15, 2024 (C++, leetcode) 129. Sum Root to Leaf Numbers (Medium) 
In .LeetcodeDailySolution folder as April15,2024.cpp

#### Prompt:

You are given the root of a binary tree containing digits from 0 to 9 only.

Each root-to-leaf path in the tree represents a number.

For example, the root-to-leaf path 1 -> 2 -> 3 represents the number 123.
Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.

A leaf node is a node with no children.

#### Solution:

    class Solution {
    public:
    int sumNumbers(TreeNode* root) {

        int ans = 0;
        
        function<void(TreeNode*, int)> dfs = [&](TreeNode* node, int path) {
            if (!node) return;
            if (!node->left && !node->right) {
                ans += path * 10 + node->val;
                return;
            }
            dfs(node->left, path * 10 + node->val);
            dfs(node->right, path * 10 + node->val);
        };
        dfs(root, 0);
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.10 mb, beating 31.40% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, depth first search, and if statements.

### Solution April 16, 2024 (C++, leetcode) 623. Add One Row to Tree (Medium)
In .LeetcodeDailySolution folder as April16,2024.cpp

#### Prompt:

Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.

Note that the root node is at depth 1.

The adding rule is:

Given the integer depth, for each not null tree node cur at the depth depth - 1, create two tree nodes with value val as cur's left subtree root and right subtree root.
cur's original left subtree should be the left subtree of the new left subtree root.
cur's original right subtree should be the right subtree of the new right subtree root.
If depth == 1 that means there is no depth depth - 1 at all, then create a tree node with value val as the new root of the whole original tree, and the original tree is the new root's left subtree.

#### Solution:

    class Solution {
    public:
    TreeNode* addOneRow(TreeNode* root, int val, int depth, bool isLeft=1) {

    if (!root) return root;
    switch(depth){
        case 1:
            if (isLeft) return new TreeNode(val, root, NULL);
            else return new TreeNode(val, NULL, root);
        break;
        case 2:
            root->left=new TreeNode(val, root->left, NULL);
            root->right=new TreeNode(val, NULL, root->right);
        break;
        default:
            root->left=addOneRow(root->left, val, depth-1);
            root->right=addOneRow(root->right, val, depth-1, 0);
    }
    return root;
      }
    };

Runtime: 7 ms, beating 95.54% of leetcode users solutions using C++.
Memory: 24.20 mb, beating 95.92% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, recursive breadth-first search, if statement, switch, and break.

### Solution April 17, 2024 (C++, leetcode) 988. Smallest String Starting From Leaf (Medium)
In .LeetcodeDailySolution folder as April17,2024.cpp

#### Prompt:

You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.

Return the lexicographically smallest string that starts at a leaf of this tree and ends at the root.

As a reminder, any shorter prefix of a string is lexicographically smaller.

For example, "ab" is lexicographically smaller than "aba".
A leaf of a node is a node that has no children.

#### Solution:

    class Solution {
    private:

    string res = "~"; 

    void dfs(TreeNode* root, string str) {

        if(root == nullptr){
            return;
        }
        str = char('a' + root->val) + str;

        if(root->left == nullptr && root->right == nullptr){
            res = min(res, str);       
        }
        dfs(root->left, str);
        dfs(root->right, str);
    }
    public:
    string smallestFromLeaf(TreeNode* root) {
        dfs(root, "");
        
        return res;
      }
    };

Runtime: 4 ms, beating 90.65% of leetcode users solutions using C++.
Memory: 20.40 mb, beating 50.79% of leetcode users solutions using C++.

#### Concepts Applied:

String, tree, if statements, and depth-first search.

### Solution April 18, 2024 (C++, leetcode) 463. Island Perimeter (Easy)
In .LeetcodeDailySolution folder as April18,2024.cpp

#### Prompt:

You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.

Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).

The island doesn't have "lakes", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.

#### Solution:

    class Solution {
    private:
    inline int getCellPerimeter(int x, int y, vector<vector<int>>& grid) {
        int cellPerimiter = 4;

        if (x > 0 && grid[x-1][y] == 1) cellPerimiter -= 2;
        if (y > 0 && grid[x][y-1] == 1) cellPerimiter -= 2;

        return cellPerimiter;
    }

    public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int islandPerimeter = 0;

        for (int i = 0; i < grid.size(); ++i) {
            for (int j = 0; j < grid[0].size(); ++j) {
                if (grid[i][j] == 1) {
                    islandPerimeter += getCellPerimeter(i, j, grid); 
                }
            }
        }

        return islandPerimeter;
      }
    };

Runtime: 68 ms, beating 75.91% of leetcode users solutions using C++.
Memory: 100.79 mb, beating 76.51% of leetcode users solutions using C++.

#### Concepts Applied:

If statements, grid, and for loops.

### Solution April 19, 2024 (C++, leetcode) 200. Number of Islands (Medium)
In .LeetcodeDailySolution folder as April19,2024.cpp

#### Prompt:

Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.

An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

#### Solution:

    class Solution {
    public:
    int numIslands(vector<vector<char>>& grid) {
        if(grid.empty() || grid[0].empty())
            return 0;
        
        int rows = grid.size();
        int cols = grid[0].size();
        int islands = 0;
        
        function<void(int, int)> dfs = [&](int row, int col) {
            if(row < 0 || col < 0 || row >= rows || col >= cols || grid[row][col] != '1')
                return;
            grid[row][col] = '0';
            dfs(row - 1, col);
            dfs(row + 1, col);
            dfs(row, col - 1);
            dfs(row, col + 1);
        };
        for(int row = 0; row < rows; row++) {
            for(int col = 0; col < cols; col++) {
                if(grid[row][col] == '1') {
                    dfs(row, col);
                    islands++;
                }
            }
        }
        return islands;
      }
    };

Runtime: 26 ms, beating 77.04% of leetcode users solutions using C++.
Memory: 16.74 mb, beating 48.78% of leetcode users solutions using C++.

#### Concepts Applied:

2D Grid, depth-first search, if statemnts, and for loops.

### Solution April 20, 2024 (C++, leetcode) 1992. Find All Groups of Farmland (Medium)
In .LeetcodeDailySolution folder as April20,2024.cpp

#### Prompt:

You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.

To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.

land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].

Return a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> findFarmland(vector<vector<int>>& land) {

        vector<vector<int>> result;
        int m = land.size();
        int n = land[0].size();
        
        auto findFarmlandCoordinates = [&](int row, int col) {

            vector<int> coordinates = {row, col};
            int r = row, c = col;
            
            while (r < m && land[r][col] == 1) r++;
            while (c < n && land[row][c] == 1) c++;
            
            coordinates.push_back(r - 1);
            coordinates.push_back(c - 1);
            
            for (int i = row; i <= r - 1; i++) {
                for (int j = col; j <= c - 1; j++) {
                    land[i][j] = 0;
                }
            }
            return coordinates;
        };
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (land[i][j] == 1) {
                    result.push_back(findFarmlandCoordinates(i, j));
                }
            }
        }
        return result;
      }
    };

Runtime: 117 ms, beating 50.16% of leetcode users solutions using C++.
Memory: 63.36 mb, beating 77.02% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, 2D matrix, while loops, for loops, and if statements. 

### Solution April 21, 2024 (C++, leetcode) 1971. Find if Path Exists in Graph (Easy)
In .LeetcodeDailySolution folder as April21,2024.cpp

#### Prompt:

There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.

You want to determine if there is a valid path that exists from vertex source to vertex destination.

Given edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.

#### Solution:

    class Solution {
    public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {

        if (n == 1) return true;
        vector<bool> visited(n, false);
        visited[source] = true;
        bool flag = true;
        
        while (flag) {
            flag = false;
            for (const auto& edge : edges) {
                if (visited[edge[0]] != visited[edge[1]]) {
                    visited[edge[0]] = true;
                    visited[edge[1]] = true;
                    flag = true;
                }
                if (visited[destination]) return true;
            }
        }
        return false;
      }
    };

Runtime: 258 ms, beating 97.52% of leetcode users solutions using C++.
Memory: 118.75 mb, beating 100% of leetcode users solutions using C++.

#### Concepts Applied:

Boolean, depth-first search, if statements, integer arrays, while loop, and for loop. 

### Solution April 22, 2024 (C++, leetcode) 752. Open the Lock (Medium)
In .LeetcodeDailySolution folder as April22,2024.cpp

#### Prompt:

You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.

The lock initially starts at '0000', a string representing the state of the 4 wheels.

You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.

Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.

#### Solution:

    class Solution {
    public:
    static int openLock(vector<string>& deadends, const string& target) {

        bitset<10000> seen = 0;

        for(string& s: deadends){
            seen[stoi(s)] = 1;
        }

        if (seen[0]) return -1;

        queue<pair<short, short>> q;
        q.emplace(0, 0);
        seen[0] = 1;
        short z = stoi(target);
        const short dec[4] = {1, 10, 100,1000};
        const char move[2][10] = {
            {1,2,3,4,5,6,7,8,9,0},
            {9,0,1,2,3,4,5,6,7,8}
        };
        while(!q.empty()){

            auto [turn, s] = q.front(); q.pop();

            if (s == z) return turn;
            short digit, t = s;

            for(short d = 0; d < 4; d++){
                digit = t % 10, t /= 10;
                for(short i: {0, 1}){
                    short dnext = move[i][digit];
                    short x = s + (dnext - digit) * dec[d];
                    if (!seen[x]) {
                        q.emplace(turn + 1, x);
                        seen[x] = 1;
                    }
                }
            }
        }
        return -1;
      }
    };

Runtime: 17 ms, beating 98.71% of leetcode users solutions using C++.
Memory: 13.64 mb, beating 99.60% of leetcode users solutions using C++.

#### Concepts Applied:

String arrays, bitset, for loops, if statements, queue, pair, and while loop.

### Solution April 23, 2024 (C++, leetcode) 310. Minimum Height Trees (Medium)
In .LeetcodeDailySolution folder as April23,2024.cpp

#### Prompt:

A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.

Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).

Return a list of all MHTs' root labels. You can return the answer in any order.

The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.

#### Solution:

    class Solution {
    public:
    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {
        if (n == 1) return {0};
    
        vector<list<int>> adjacency_list(n);
        vector<int> degree(n, 0);

        for (auto& edge : edges) {
            int u = edge[0], v = edge[1];
            adjacency_list[u].push_back(v);
            adjacency_list[v].push_back(u);
            degree[u]++;
            degree[v]++;
        }
        queue<int> leaves;

        for (int i = 0; i < n; ++i) {
            if (degree[i] == 1) leaves.push(i);
        }
        int remainingNodes = n;

        while (remainingNodes > 2) {
            int leavesCount = leaves.size();
            remainingNodes -= leavesCount;
            for (int i = 0; i < leavesCount; ++i) {
                int leaf = leaves.front();
                leaves.pop();
                for (int neighbor : adjacency_list[leaf]) {
                    if (--degree[neighbor] == 1) {
                        leaves.push(neighbor);
                    }
                }
            }
        }
        vector<int> result;
        
        while (!leaves.empty()) {
            result.push_back(leaves.front());
            leaves.pop();
        }
        return result;
      }
    };

Runtime: 101 ms, beating 82.73% of leetcode users solutions using C++.
Memory: 60.04 mb, beating 52.56% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, breadth-first search, if statements, list, for loops, queue, and while loops. 

### Solution April 24, 2024 (C++, leetcode) 1137. N-th Tribonacci Number (Easy)
In .LeetcodeDailySolution folder as April24,2024.cpp

#### Prompt:

The Tribonacci sequence Tn is defined as follows: 

T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.

Given n, return the value of Tn.

#### Solution:

    class Solution {
    public:
    int tribonacci(int n) {
         
        if (n == 0) return 0;

        else if (n <= 2) return 1;

        tuple<int, int, int> t = {0, 1, 1};
         
        for(int i = 3; i <= n; i++){
            auto [x, y, z] = t;
            t = {y, z, x + y + z};
        }            
        return get<2>(t);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.06 mb, beating 81.43% of leetcode users solutions using C++.

#### Concepts Applied:

If statement, else-if statement, tuple, and for loop.

### Solution April 25, 2024 (C++, leetcode) 2370. Longest Ideal Subsequence (Medium)
In .LeetcodeDailySolution folder as April25,2024.cpp

#### Prompt:

You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:

t is a subsequence of the string s.
The absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.
Return the length of the longest ideal string.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

Note that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.

#### Solution:

    class Solution {
    public:
    int longestIdealString(string& s, int k) {

        int seq[26] = {0};
        int ans = 0;

        for(char c: s){
            int i = c-'a';
            int j0 = max(0, i - k),  j1 = min(i + k, 25);

            for(int j = j0; j <= j1; j++)
                seq[i] = max(seq[i], seq[j]);
            seq[i]++;
        }
        return *max_element(seq, seq + 26);   
      }
    };

Runtime: 41 ms, beating 83.26% of leetcode users solutions using C++.
Memory: 10.36 mb, beating 100% of leetcode users solutions using C++.

#### Concepts Applied:

String, dynamic programming, and for loops.

### Solution April 26, 2024 (C++, leetcode) 1289. Minimum Falling Path Sum II (Hard)
In .LeetcodeDailySolution folder as April26,2024.cpp

#### Prompt:

Given an n x n integer matrix grid, return the minimum sum of a falling path with non-zero shifts.

A falling path with non-zero shifts is a choice of exactly one element from each row of grid such that no two elements chosen in adjacent rows are in the same column.

#### Solution:

    class Solution {
    public:
    int minFallingPathSum(vector<vector<int>>& grid) {

        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> dp(n, vector<int>(m, 0));

        for (int j = 0; j < m; ++j) {
            dp[n - 1][j] = grid[n - 1][j];
        }
        for (int i = n - 2; i >= 0; --i) {
            for (int j = 0; j < m; ++j) {

                int minNextRow = INT_MAX;

                for (int k = 0; k < m; ++k) {
                    if (k != j) {
                        minNextRow = min(minNextRow, dp[i + 1][k]);
                    }
                }
                dp[i][j] = grid[i][j] + minNextRow;
            }
        }
        int ans = *min_element(dp[0].begin(), dp[0].end());

        return ans;
      }
    };

Runtime: 127 ms, beating 68.68% of leetcode users solutions using C++.
Memory: 18.09 mb, beating 67.90% of leetcode users solutions using C++.

#### Concepts Applied:

Grid, dynamic programming, recursion, for loops, and if statement. 

### Solution April 27, 2024 (C++, leetcode) 514. Freedom Trail (Hard)
In .LeetcodeDailySolution folder as April27,2024.cpp

#### Prompt:

In the video game Fallout 4, the quest "Road to Freedom" requires players to reach a metal dial called the "Freedom Trail Ring" and use the dial to spell a specific keyword to open the door.

Given a string ring that represents the code engraved on the outer ring and another string key that represents the keyword that needs to be spelled, return the minimum number of steps to spell all the characters in the keyword.

Initially, the first character of the ring is aligned at the "12:00" direction. You should spell all the characters in key one by one by rotating ring clockwise or anticlockwise to make each character of the string key aligned at the "12:00" direction and then by pressing the center button.

At the stage of rotating the ring to spell the key character key[i]:

You can rotate the ring clockwise or anticlockwise by one place, which counts as one step. The final purpose of the rotation is to align one of ring's characters at the "12:00" direction, where this character must equal key[i].
If the character key[i] has been aligned at the "12:00" direction, press the center button to spell, which also counts as one step. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.

#### Solution:

    class Solution {
    public:
    int findRotateSteps(string ring, string key) {

        if (ring.empty() || key.empty()) {
            return 0;
        }
        unordered_map<char, vector<int>> ringMap;
        
        for (int i = 0; i < ring.size(); i++) {
            ringMap[ring[i]].push_back(i);
        }
        vector<int> dp(ring.size(), INT_MAX);

        for (int i : ringMap[key[0]]) {
            dp[i] = min(i, (int)ring.size() - i) + 1;
        }
        for (int i = 1; i < key.size(); i++) {

            vector<int> new_dp(ring.size(), INT_MAX);

            for (int j : ringMap[key[i]]) {
                for (int k : ringMap[key[i - 1]]) {
                    new_dp[j] = min(new_dp[j], dp[k] + min(abs(j - k), (int)ring.size() - abs(j - k)) + 1);
                }
            }
            dp = move(new_dp);
        }
        return *min_element(dp.begin(), dp.end());
      }
    };

Runtime: 11 ms, beating 78.30% of leetcode users solutions using C++.
Memory: 15.80 mb, beating 47.64% of leetcode users solutions using C++.

#### Concepts Applied:

Dynamic programming, hash maps, if statements, and for loops.

### Solution April 28, 2024 (C++, leetcode) 834. Sum of Distances in Tree (Hard)
In .LeetcodeDailySolution folder as April28,2024.cpp

#### Prompt:

There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.

You are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.

Return an array answer of length n where answer[i] is the sum of the distances between the ith node in the tree and all other nodes.

#### Solution:

    class Solution {
    private:

    vector<vector<int>> graph;
    vector<int> count;
    vector<int> res;
    int N;

    public:
    vector<int> sumOfDistancesInTree(int N, vector<vector<int>>& edges) {

        this -> N = N;
        res.resize(N);
        graph.resize(N);
        count.resize(N);

        for (auto& e : edges) {
            ++count[e[0]];
            ++count[e[1]];
        }
        for (int i = 0; i < N; i++) {
            graph[i].resize(count[i]);
        }
        for (auto& e : edges) {
            graph[e[0]][--count[e[0]]] = e[1];
            graph[e[1]][--count[e[1]]] = e[0];
        }
        dfs1(0, -1);
        dfs2(0, -1);

        return res;
    }
    private:

    void dfs1(int cur, int parent) {

        count[cur] = 1;

        for (int child : graph[cur]) {
            if (child != parent) {

                dfs1(child, cur);
                count[cur] += count[child];
                res[cur] += res[child] + count[child];
            }
        }
    }
    void dfs2(int cur, int parent) {

        for (int child : graph[cur]) {
            if (child != parent) {

                res[child] = res[cur] + N - 2 * count[child];
                dfs2(child, cur);
            }
        }
      }.
    };

Runtime: 175 ms, beating 94.33% of leetcode users solutions using C++.
Memory: 88.79 mb, beating 98.52% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, pointers, depth-first search, for loops, and if statements.	

### Solution April 29, 2024 (C++, leetcode) 2997. Minimum Number of Operations to Make Array XOR Equal to K (Medium)
In .LeetcodeDailySolution folder as April29,2024.cpp

#### Prompt:

You are given a 0-indexed integer array nums and a positive integer k.

You can apply the following operation on the array any number of times:

Choose any element of the array and flip a bit in its binary representation. Flipping a bit means changing a 0 to 1 or vice versa.
Return the minimum number of operations required to make the bitwise XOR of all elements of the final array equal to k.

Note that you can flip leading zero bits in the binary representation of elements. For example, for the number (101)2 you can flip the fourth bit and obtain (1101)2.

#### Solution:

    class Solution {
    public:
    int minOperations(vector<int>& nums, int k) {


        int ans = 0;
        for (auto& x : nums) {
            ans = ans ^ x;
        }
        ans = ans ^ k;

        int res = 0;
        
        while (ans > 0) {
            if (ans & 1)1
                res++;
            ans = ans >> 1;
        }
        return res;
      }
    };

Runtime: 98 ms, beating 91.20% of leetcode users solutions using C++.
Memory: 91.30 mb, beating 55.11% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, bit manipulation, for loop, while loop, and if statement.

### Solution April 30, 2024 (C++, leetcode) 1915. Number of Wonderful Substrings (Medium)
In .LeetcodeDailySolution folder as April30,2024.cpp

#### Prompt:

A wonderful string is a string where at most one letter appears an odd number of times.

For example, "ccjjc" and "abab" are wonderful, but "ab" is not.
Given a string word that consists of the first ten lowercase English letters ('a' through 'j'), return the number of wonderful non-empty substrings in word. If the same substring appears multiple times in word, then count each occurrence separately.

A substring is a contiguous sequence of characters in a string.

#### Solution:

    class Solution {
    public:
    int get(char c) {
        
        return c - 'a';
    }

    long long wonderfulSubstrings(string word) {

        vector<long long> cnt(1024, 0);
        cnt[0] = 1;
        int curState = 0;
        long long res = 0;

        for (char c : word) {
            
            curState ^= 1 << get(c);
            res += cnt[curState];

            for (char odd = 'a'; odd <= 'j'; odd++) {
                int oddState = curState ^ (1 << get(odd));
                res += cnt[oddState];
            }
            cnt[curState]++;
        }
        return res;
      }
    };

Runtime: 48 ms, beating 83.23% of leetcode users solutions using C++.
Memory: 16.61 mb, beating 61.08% of leetcode users solutions using C++.

#### Concepts Applied:

String, substring, prefix string, and for loops.

### Solution May 1, 2024 (C++, leetcode) 2000. Reverse Prefix of Word (Easy)
In .LeetcodeDailySolution folder as May1,2024.cpp

#### Prompt:

Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.

For example, if word = "abcdefd" and ch = "d", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be "dcbaefd".
Return the resulting string.

#### Solution:

    class Solution {
    public:
    string reversePrefix(string word, char ch) {
        int ind = word.find(ch);

        if(ind != string::npos){
            reverse(word.begin(), word.begin() + ind + 1);
        }

        return word;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.45 mb, beating 65.41% of leetcode users solutions using C++.

#### Concepts Applied:

String, find, if statement, and reverse.

### Solution May 2, 2024 (C++, leetcode) 2441. Largest Positive Integer With Its Negative (Easy)
In .LeetcodeDailySolution folder as May2,2024.cpp

#### Prompt:

Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.

Return the positive integer k. If there is no such integer, return -1.

#### Solution:

    class Solution {
    public:
    int findMaxK(vector<int>& nums) {

        sort(nums.begin(), nums.end(), [](int & lhs, int & rhs){
            return abs(lhs)<abs(rhs);});

        for (int i = nums.size() - 1; i > 0; i--) {
            if (nums[i] + nums[i - 1] == 0) {
                return abs(nums[i]);
            }
        }
        return -1;
      }
    };

Runtime: 11 ms, beating 94.06% of leetcode users solutions using C++.
Memory: 22.76 mb, beating 79.58% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, absolute value function, for loop, and if statement.

### Solution May 3, 2024 (C++, leetcode) 165. Compare Version Numbers (Medium)
In .LeetcodeDailySolution folder as May3,2024.cpp

#### Prompt:

Given two version numbers, version1 and version2, compare them.

Version numbers consist of one or more revisions joined by a dot '.'. Each revision consists of digits and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example 2.5.33 and 0.1 are valid version numbers.

To compare version numbers, compare their revisions in left-to-right order. Revisions are compared using their integer value ignoring any leading zeros. This means that revisions 1 and 001 are considered equal. If a version number does not specify a revision at an index, then treat the revision as 0. For example, version 1.0 is less than version 1.1 because their revision 0s are the same, but their revision 1s are 0 and 1 respectively, and 0 < 1.

Return the following:

If version1 < version2, return -1.
If version1 > version2, return 1.
Otherwise, return 0.

#### Solution:

    class Solution {
    public:
    int compareVersion(string version1, string version2) {
        
        int i = 0, j = 0;

        while (i < version1.size() || j < version2.size()) {
            int v1 = 0, v2 = 0;

            while (i < version1.size() && version1[i] != '.') {
                v1 = v1 * 10 + (version1[i] - '0');
                i++;
            }
            while (j < version2.size() && version2[j] != '.') {
                v2 = v2 * 10 + (version2[j] - '0');
                j++;
            }
            if (v1 > v2) return 1;

            else if (v1 < v2) return -1;

            i++; 
            j++;
        }
        return 0;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.41 mb, beating 52.59% of leetcode users solutions using C++.

#### Concepts Applied:

String, two pointers, while loops, if statement, and else-if statement.

### Solution May 4, 2024 (C++, leetcode) 881. Boats to Save People (Medium)
In .LeetcodeDailySolution folder as May4,2024.cpp

#### Prompt:

You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.

Return the minimum number of boats to carry every given person.

#### Solution:

    class Solution {
    public:
    int numRescueBoats(vector<int>& people, int limit) {

         sort(people.begin() , people.end());

        int i=0 , boats=0;
        int j=people.size()-1;

        while(i<=j){
            if(people[i]+people[j]<=limit){
                i++;
                j--;
                boats++;
            }
            else{
                boats++;
                j--;
            }
        }
        return boats;
      }
    };

Runtime: 53 ms, beating 79.61% of leetcode users solutions using C++.
Memory: 45.32 mb, beating 85.14% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, two pointers, while loop, if statement, and else-if statement.

### Solution May 5, 2024 (C++, leetcode) 237. Delete Node in a Linked List (Medium)
In .LeetcodeDailySolution folder as May5,2024.cpp

#### Prompt:

There is a singly-linked list head and we want to delete a node node in it.

You are given the node to be deleted node. You will not be given access to the first node of head.

All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.

Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:

The value of the given node should not exist in the linked list.
The number of nodes in the linked list should decrease by one.
All the values before node should be in the same order.
All the values after node should be in the same order.

Custom testing:

For the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.
We will build the linked list and pass the node to your function.
The output will be the entire list after calling your function.

#### Solution:

    class Solution {
    public:
    void deleteNode(ListNode* node) {

        while (node -> next -> next) {
            node -> val = node -> next -> val;
            node = node -> next;
        }
        node -> val = node -> next -> val;
        node -> next = NULL;
      }
    };

Runtime: 3 ms, beating 92.51% of leetcode users solutions using C++.
Memory: 11.27 mb, beating 84.03% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list and while loop.

### Solution May 6, 2024 (C++, leetcode) 2487. Remove Nodes From Linked List (Medium)
In .LeetcodeDailySolution folder as May6,2024.cpp

#### Prompt:

You are given the head of a linked list.

Remove every node which has a node with a greater value anywhere to the right side of it.

Return the head of the modified linked list.

#### Solution:

    class Solution {
    public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* current = head;

        while (current != nullptr) {
            ListNode* nextNode = current -> next;
            current -> next = prev;
            prev = current;
            current = nextNode;
        }
        return prev;
    }
    ListNode* removeNodes(ListNode* head) {

        ListNode* reversedHead = reverseList(head);
        ListNode* current = reversedHead;
        int maxValue = INT_MIN;
        ListNode* prev = nullptr;

        while (current != nullptr) {
            if (current -> val < maxValue) {
                prev -> next = current -> next;
            } else {
                maxValue = current -> val;
                prev = current;
            }
            current = current -> next;
        }
        return reverseList(reversedHead);
      }
    };

Runtime: 242 ms, beating 95.59% of leetcode users solutions using C++.
Memory: 159.88 mb, beating 81.03% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, pointers, while loops, if statement, and else-if statement.

### Solution May 7, 2024 (C++, leetcode) 2816. Double a Number Represented as a Linked List (Medium)
In .LeetcodeDailySolution folder as May7,2024.cpp

#### Prompt:

You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.

Return the head of the linked list after doubling it.

#### Solution:

    class Solution {
    public:
    ListNode* doubleIt(ListNode* head) {

        int carry = twice(head);

        if (carry > 0) {
            head = new ListNode(carry, head);
        }
        return head;
    }
    private:
    int twice(ListNode* head) {

        if (head == nullptr) {
            return 0;
        }
 
        int doubledValue = head -> val * 2 + twice(head -> next);
        head -> val = doubledValue % 10;
        
        return doubledValue / 10;
      }
    };

Runtime: 154 ms, beating 95.20% of leetcode users solutions using C++.
Memory: 121.09 mb, beating 50.42% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, recursion, and if statements.

### Solution May 8, 2024 (C++, leetcode) 506. Relative Ranks (Easy)
In .LeetcodeDailySolution folder as May8,2024.cpp

#### Prompt:

You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.

The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:

The 1st place athlete's rank is "Gold Medal".
The 2nd place athlete's rank is "Silver Medal".
The 3rd place athlete's rank is "Bronze Medal".
For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is "x").
Return an array answer of size n where answer[i] is the rank of the ith athlete.

#### Solution:

    class Solution {
    private:
    int findMax(vector<int>& score) {

        int maxScore = 0;

        for (int s : score) {
            if (s > maxScore) {
                maxScore = s;
            }
        }
        return maxScore;
    }
    public:
    vector<string> findRelativeRanks(vector<int>& score) {

        int N = score.size();
        int M = findMax(score);
        vector<int> scoreToIndex(M + 1, 0);

        for (int i = 0; i < N; i++) {
            scoreToIndex[score[i]] = i + 1;
        }
        const vector<string> MEDALS = {"Gold Medal", "Silver Medal", "Bronze Medal"};
        vector<string> rank(N);
        int place = 1;
        
        for (int i = M; i >= 0; i--) {
            if (scoreToIndex[i] != 0) {
                int originalIndex = scoreToIndex[i] - 1;
                if (place < 4) {
                    rank[originalIndex] = MEDALS[place - 1];
                } else {
                    rank[originalIndex] = to_string(place);
                }
                place++;
            }
        }
        return rank;
      }
    };

Runtime: 3 ms, beating 96.77% of leetcode users solutions using C++.
Memory: 14.38 mb, beating 59.41% of leetcode users solutions using C++.

#### Concepts Applied:

Maximum, mapping, arrays, for loops, if statements, and else statement.

### Solution May 9, 2024 (C++, leetcode) 3075. Maximize Happiness of Selected Children (Medium)
In .LeetcodeDailySolution folder as May9,2024.cpp

#### Prompt:

You are given an array happiness of length n, and a positive integer k.

There are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.

In each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.

Return the maximum sum of the happiness values of the selected children you can achieve by selecting k children.

#### Solution:

    class Solution {
    public:
    long long maximumHappinessSum(vector<int>& happiness, int k) {

        sort(happiness.begin(), happiness.end(), greater<int>());
        
        long long totalHappinessSum = 0;
        int turns = 0;
        
        for(int i = 0; i < k; i++) {
            totalHappinessSum += max(happiness[i] - turns, 0);  
            turns++; 
        }
        return totalHappinessSum;
      }
    };

Runtime: 151 ms, beating 84.37% of leetcode users solutions using C++.
Memory: 107.19 mb, beating 59.71% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, and for loop.

### Solution May 10, 2024 (C++, leetcode) 786. K-th Smallest Prime Fraction (Medium)
In .LeetcodeDailySolution folder as May10,2024.cpp

#### Prompt:

You are given a sorted integer array arr containing 1 and prime numbers, where all the integers of arr are unique. You are also given an integer k.

For every i and j where 0 <= i < j < arr.length, we consider the fraction arr[i] / arr[j].

Return the kth smallest fraction considered. Return your answer as an array of integers of size 2, where answer[0] == arr[i] and answer[1] == arr[j].

#### Solution:

    class Solution {
    public:
    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {

        int n = arr.size();
        double left = 0, right = 1.0;
        
        while (left < right){
            double mid = (left + right) / 2;
            
            double maxFraction = 0.0;
            int totalSmallerFractions = 0, numeratorIdx = 0, denominatorIdx = 0;
            int j = 1;
            
            for (int i = 0; i < n - 1; i++){
                while (j < n && arr[i] >= mid * arr[j]){
                    j++;
                }

                totalSmallerFractions += (n - j);
                
                if (j == n) break;
                
                double fraction = static_cast<double>(arr[i]) / arr[j];
                
                if (fraction > maxFraction) {
                  numeratorIdx = i;
                  denominatorIdx = j;
                  maxFraction = fraction;
                }
            }
            if (totalSmallerFractions == k) {
                return {arr[numeratorIdx], arr[denominatorIdx]};
            } else if (totalSmallerFractions > k) {
                right = mid; 
            } else {
                left = mid; 
            }
        }
        return {}; 
      }
    };

Runtime: 7 ms, beating 90.58% of leetcode users solutions using C++.
Memory: 10.71 mb, beating 88.27% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search, fractions, while loop, for loop, if statements, else-if statement, and else statement.

### Solution May 11, 2024 (C++, leetcode) 857. Minimum Cost to Hire K Workers (Hard)
In .LeetcodeDailySolution folder as May11,2024.cpp

#### Prompt:

There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker.

We want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:

Every worker in the paid group must be paid at least their minimum wage expectation.
In the group, each worker's pay must be directly proportional to their quality. This means if a worker’s quality is double that of another worker in the group, then they must be paid twice as much as the other worker.
Given the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10-5 of the actual answer will be accepted.

#### Solution:

    class Solution {
    public:
    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {

        int n = quality.size();
        double minCost = DBL_MAX; 
        double qualityTillNow = 0;
        vector<pair<double, int>> wageQualityRatio;

        for (int i = 0; i < n; ++i) {
            
            wageQualityRatio.emplace_back(
                static_cast<double>(wage[i]) / quality[i], quality[i]);
        }
        sort(wageQualityRatio.begin(), wageQualityRatio.end());
        priority_queue<int> highQualityWorkers;

        for (int i = 0; i < n; ++i) {
            
            double ratio = wageQualityRatio[i].first;
            int qua = wageQualityRatio[i].second;

            qualityTillNow += qua;
            highQualityWorkers.push(qua);

            if (highQualityWorkers.size() > k) {
                qualityTillNow -= highQualityWorkers.top();
                highQualityWorkers.pop();
            }
            if (highQualityWorkers.size() == k) {
                minCost = min(minCost, qualityTillNow * ratio);
            }
        }
        return minCost;
      }
    };

Runtime: 25 ms, beating 69.47% of leetcode users solutions using C++.
Memory: 26.28 mb, beating 75.07% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, for loops, if statements, and max-heap (priority queue).

### Solution May 12, 2024 (C++, leetcode) 2373. Largest Local Values in a Matrix (Easy)
In .LeetcodeDailySolution folder as May12,2024.cpp

#### Prompt:

You are given an n x n integer matrix grid.

Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:

maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1.
In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.

Return the generated matrix.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> largestLocal(vector<vector<int>>& grid) {
        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
        int n = grid.size();
        vector<vector<int>> res(n - 2, vector<int>(n - 2));

        for (int i = 1; i < n - 1; ++i) {
            for (int j = 1; j < n - 1; ++j) {
                int temp = 0;

                for (int k = i - 1; k <= i + 1; ++k) {
                    for (int l = j - 1; l <= j + 1; ++l) {
                        temp = max(temp, grid[k][l]);
                    }
                }

                res[i - 1][j - 1] = temp;
            }
        }

        return res;
      }
    };

Runtime: 8 ms, beating 73.11% of leetcode users solutions using C++.
Memory: 13.56 mb, beating 52.48% of leetcode users solutions using C++.

#### Concepts Applied:

Sliding window, grid, for loops, and array.

### Solution May 13, 2024 (C++, leetcode) 861. Score After Flipping Matrix (Medium) 
In .LeetcodeDailySolution folder as May13,2024.cpp

#### Prompt:

You are given an m x n binary matrix grid.

A move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).

Every row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.

Return the highest possible score after making any number of moves (including zero moves).

#### Solution:

    class Solution {
    public:
    int matrixScore(vector<vector<int>>& grid) {

        int n = grid.size(), m = grid[0].size();
        int res = (1 << (m - 1)) * n;

        for(int j = 1; j < m; ++j) {

            int val = 1 << (m - 1 - j);
            int set = 0;

            for(int i = 0; i < n; ++i) {
                if(grid[i][j] == grid[i][0]) {
                    set++;
                }
            }
            res += max(set, n - set) * val;
        }
        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.05 mb, beating 94.41% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, matrix, grid, and for loops.

### Solution May 14, 2024 (C++, leetcode) 1219. Path with Maximum Gold (Medium)
In .LeetcodeDailySolution folder as May14,2024.cpp

#### Prompt:

In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.

Return the maximum amount of gold you can collect under the conditions:

Every time you are located in a cell you will collect all the gold in that cell.
From your position, you can walk one step to the left, right, up, or down.
You can't visit the same cell more than once.
Never visit a cell with 0 gold.
You can start and stop collecting gold from any position in the grid that has some gold.

#### Solution:

    class Solution {
    public:

    vector<int> roww = {1, -1, 0, 0};
    vector<int> coll = {0, 0, -1, 1};
    int maxGold = 0;

    int dfs(vector<vector<int>>& grid, int x, int y, int n, int m) {

        if (x < 0 || x >= n || y < 0 || y >= m || grid[x][y] == 0) return 0;
        
        int curr = grid[x][y];
        grid[x][y] = 0;
        int localMaxGold = curr;

        for (int i = 0; i < 4; i++) {
            int newX = x + roww[i];
            int newY = y + coll[i];
            localMaxGold = max(localMaxGold, curr + dfs(grid, newX, newY, n, m));
        }
        grid[x][y] = curr;
        return localMaxGold;
    }
    int getMaximumGold(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] != 0) {
                    maxGold = max(maxGold, dfs(grid, i, j, n, m));
                }
            }
        }
        return maxGold;
      }
    };

Runtime: 142 ms, beating 55.63% of leetcode users solutions using C++.
Memory: 8.87 mb, beating 99.48% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, grid, if statements, and for loops.

### Solution May 15, 2024 (C++, leetcode) 2812. Find the Safest Path in a Grid (Medium)
In .LeetcodeDailySolution folder as May15,2024.cpp

#### Prompt:

You are given a 0-indexed 2D matrix grid of size n x n, where (r, c) represents:

A cell containing a thief if grid[r][c] = 1
An empty cell if grid[r][c] = 0
You are initially positioned at cell (0, 0). In one move, you can move to any adjacent cell in the grid, including cells containing thieves.

The safeness factor of a path on the grid is defined as the minimum manhattan distance from any cell in the path to any thief in the grid.

Return the maximum safeness factor of all paths leading to cell (n - 1, n - 1).

An adjacent cell of cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) and (r - 1, c) if it exists.

The Manhattan distance between two cells (a, b) and (x, y) is equal to |a - x| + |b - y|, where |val| denotes the absolute value of val.

#### Solution:

    class Solution {
    public:
    vector<int> roww = {0, 0, -1, 1};
    vector<int> coll = {-1, 1, 0, 0};

    void bfs(vector<vector<int>>& grid, vector<vector<int>>& score, int n) {

        queue<pair<int, int>> q;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j]) {
                    score[i][j] = 0;
                    q.push({i, j});
                }
            }
        }
        while (!q.empty()) {

            auto t = q.front();
            q.pop();

            int x = t.first, y = t.second;
            int s = score[x][y];

            for (int i = 0; i < 4; i++) {

                int newX = x + roww[i];
                int newY = y + coll[i];

                if (newX >= 0 && newX < n && newY >= 0 && newY < n &&
                    score[newX][newY] > 1 + s) {

                    score[newX][newY] = 1 + s;
                    q.push({newX, newY});
                }
            }
        }
    }

    int maximumSafenessFactor(vector<vector<int>>& grid) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int n = grid.size();
        if (grid[0][0] || grid[n - 1][n - 1])
            return 0;

        vector<vector<int>> score(n, vector<int>(n, INT_MAX));
        bfs(grid, score, n);
        vector<vector<bool>> vis(n, vector<bool>(n, false));

        priority_queue<pair<int, pair<int, int>>> pq;
        pq.push({score[0][0], {0, 0}});

        while (!pq.empty()) {
            auto temp = pq.top().second;
            auto safe = pq.top().first;
            pq.pop();

            if (temp.first == n - 1 && temp.second == n - 1)
                return safe;
            vis[temp.first][temp.second] = true;

            for (int i = 0; i < 4; i++) {
                int newX = temp.first + roww[i];
                int newY = temp.second + coll[i];

                if (newX >= 0 && newX < n && newY >= 0 && newY < n &&
                    !vis[newX][newY]) {
                    int s = min(safe, score[newX][newY]);
                    pq.push({s, {newX, newY}});
                    vis[newX][newY] = true;
                }
            }
        }

        return -1;
      }
    };

Runtime: 238 ms, beating 100% of leetcode users solutions using C++.
Memory: 122.11 mb, beating 91.95% of leetcode users solutions using C++.

#### Concepts Applied:

Breadth-first search, priority queue, Dijkstra's algorithm, for loops, if statements, and while loops. 

### Solution May 16, 2024 (C++, leetcode) 2331. Evaluate Boolean Binary Tree (Easy)
In .LeetcodeDailySolution folder as May16,2024.cpp

#### Prompt:

You are given the root of a full binary tree with the following properties:

Leaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True.
Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND.
The evaluation of a node is as follows:

If the node is a leaf node, the evaluation is the value of the node, i.e. True or False.
Otherwise, evaluate the node's two children and apply the boolean operation of its value with the children's evaluations.
Return the boolean result of evaluating the root node.

A full binary tree is a binary tree where each node has either 0 or 2 children.

A leaf node is a node that has zero children.

#### Solution:

    class Solution {
    public:
    bool helper(TreeNode* root) {
        
        if(root -> val == 0 || root -> val == 1) {
            return root -> val == 1;
        } else if(root -> val == 2) {
            return helper(root -> left) || helper(root -> right);
        } else if(root -> val == 3) {
            return helper(root -> left) && helper(root -> right);
        } 

        return false;
    }

    bool evaluateTree(TreeNode* root) {
        return helper(root);
      }
    };

Runtime: 4 ms, beating 97.35% of leetcode users solutions using C++.
Memory: 17.31 mb, beating 64.62% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, recursion, helper function, if statement, and else-if statements.

### Solution May 18, 2024 (C++, leetcode) 979. Distribute Coins in Binary Tree (Medium)
In .LeetcodeDailySolution folder as May18,2024.cpp

#### Prompt:

You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.

In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.

Return the minimum number of moves required to make every node have exactly one coin.

#### Solution:

    class Solution {
    public:

    int ans;

    int distributeCoins(TreeNode* root) {

        ans = 0;
        countSteps(root);

        return ans;
    }
    int countSteps(TreeNode* root) {

        if (root == nullptr)
            return 0;

        int leftCoins = countSteps(root -> left);
        int rightCoins = countSteps(root -> right);
        ans += abs(leftCoins) + abs(rightCoins);

        return (root -> val - 1) + leftCoins + rightCoins;
      }
    };

Runtime: 3 ms, beating 80.19% of leetcode users solutions using C++.
Memory: 15.47 mb, beating 88.89% of leetcode users solutions using C++.

#### Concepts Applied:

Tree, depth-first search, if statement, and absolute value.

### Solution May 19, 2024 (C++, leetcode) 3068. Find the Maximum Sum of Node Values (Hard)
In .LeetcodeDailySolution folder as May19,2024.cpp

#### Prompt:

There exists an undirected tree with n nodes numbered 0 to n - 1. You are given a 0-indexed 2D integer array edges of length n - 1, where edges[i] = [ui, vi] indicates that there is an edge between nodes ui and vi in the tree. You are also given a positive integer k, and a 0-indexed array of non-negative integers nums of length n, where nums[i] represents the value of the node numbered i.

Alice wants the sum of values of tree nodes to be maximum, for which Alice can perform the following operation any number of times (including zero) on the tree:

Choose any edge [u, v] connecting the nodes u and v, and update their values as follows:
nums[u] = nums[u] XOR k
nums[v] = nums[v] XOR k
Return the maximum possible sum of the values Alice can achieve by performing the operation any number of times.

#### Solution:

    class Solution {
    public:
    long long maximumValueSum(std::vector<int>& nums, int k, std::vector<std::vector<int>>& edges) {

        long long sum = 0;
        long long minExtra = 1000000;
        int count = 0;

        for (int val : nums) {

            if ((val ^ k) > val) {

                sum += (val ^ k);
                minExtra = min(minExtra, static_cast<long long>((val ^ k) - val));
                count++;
                
            } else {

                sum += val;
                minExtra = min(minExtra, static_cast<long long>(val - (val ^ k)));
            }
        }

        if (count % 2 == 0) {

            return sum;

        } else {

            return sum - minExtra;
        }
      }
    };

Runtime: 171 ms, beating 91.22% of leetcode users solutions using C++.
Memory: 125.56 mb, beating 89.41% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, if statements, and else statements. 

### Solution May 20, 2024 (C++, leetcode) 1863. Sum of All Subset XOR Totals (Easy)
In .LeetcodeDailySolution folder as May20,2024.cpp

#### Prompt: 

The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.

For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 

Note: Subsets with the same elements should be counted multiple times.

An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.

#### Solution:

    class Solution {
    public:
    int subsetXORSum(vector<int>& nums) {

        return dfs(nums, 0, 0);
    }
    
    private:
    int dfs(vector<int>& nums, int index, int currentXor) {

        if (index == nums.size()) {
            return currentXor;
        }
        int include = dfs(nums, index + 1, currentXor ^ nums[index]);

        int exclude = dfs(nums, index + 1, currentXor);
        
        return include + exclude;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.23 mb, beating 88.34% of leetcode users solutions using C++.

#### Concepts Applied: 

Arrays, depth-first search, recursion, and if statement.

### Solution May 21, 2024 (C++, leetcode) 78. Subsets (Medium)
In .LeetcodeDailySolution folder as May21,2024.cpp

#### Prompt:

Given an integer array nums of unique elements, return all possible subsets (the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> subsets(vector<int>& nums) {

        vector<vector<int>> result;
        vector<int> curr;

        function<void(int)> explore = [&](int index) {

            if (index == nums.size()) {

                result.push_back(curr);
                
                return;
            }

            curr.push_back(nums[index]);
            explore(index + 1);
            curr.pop_back(); 
            explore(index + 1);

        };

        explore(0);

        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 11.03 mb, beating 38.49% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, recursion, and if statement.

### Solution May 22, 2024 (C++, leetcode) 131. Palindorme Partitioning (Medium)
In .LeetcodeDailySolution folder as May22,2024.cpp

#### Prompt:

Given a string s, partition s such that every substring of the partition is a palindrome. 
Return all possible palindrome partitioning of s.

#### Solution:

    class Solution {
    public:
    vector<vector<string>> partition(string s) {

        vector<vector<string>> result;
        vector<string> path;
        backtrack(s, 0, path, result);
        
        return result;
    }
    private:
    void backtrack(const string& s, int start, vector<string>& path, vector<vector<string>>& result) {

        if (start == s.length()) {
            result.push_back(path);
            return;
        }
        for (int end = start + 1; end <= s.length(); ++end) {

            if (isPalindrome(s, start, end - 1)) {

                path.push_back(s.substr(start, end - start));
                backtrack(s, end, path, result);
                path.pop_back();
            }
        }
    }
    bool isPalindrome(const string& s, int left, int right) {

        while (left < right) {
            if (s[left++] != s[right--]) {
                return false;
            }
        }
        return true;
      }
    };

Runtime: 66 ms, beating 93.77% of leetcode users solutions using C++.
Memory: 52.78 mb, beating 84.94% of leetcode users solutions using C++.

#### Concepts Applied:

Recursive backtracking, palindromic check, for loop, if statements, and while loop.

### Solution May 23, 2024 (C++, leetcode) 2597. The Number of Beautiful Subsets (Medium)
In .LeetcodeDailySolution folder as May23,2024.cpp

#### Prompt:

You are given an array nums of positive integers and a positive integer k.

A subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.

Return the number of non-empty beautiful subsets of the array nums.

A subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.

#### Solution:

    class Solution {
    public:
    int beautifulSubsets(vector<int>& A, int k) {

        unordered_map<int, int> count;

        for (int a : A) {
            count[a]++;
        }

        function<pair<int, int>(int)> dp = [&](int a) {

            if (count.count(a - k)) {
                auto [dp0, dp1] = dp(a - k);
                return make_pair(dp0 + dp1, dp0 * ((1 << count[a]) - 1));
            } else {
                return make_pair(1, (1 << count[a]) - 1);
            }
        };

        int result = 1;

        for (auto [a, freq] : count) {
            if (!count.count(a + k)) {
                auto [dp0, dp1] = dp(a);
                result *= dp0 + dp1;
            }
        }
        return result - 1;
      }
    };

Runtime: 12 ms, beating 90.63% of leetcode users solutions using C++.
Memory: 37.62 mb, beating 70.88% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered map, for loops, pair, dynamic programming, if statements, and else statement.

### Solution May 24, 2024 (C++, leetcode) 1255. Maximum Score Words Formed by Letters (Hard)
In .LeetcodeDailySolution folder as May24,2024.cpp

#### Prompt:

Given a list of words, list of  single letters (might be repeating) and score of every character.

Return the maximum score of any valid set of words formed by using the given letters (words[i] cannot be used two or more times).

It is not necessary to use all characters in letters and each letter can only be used once. Score of letters 'a', 'b', 'c', ... ,'z' is given by score[0], score[1], ... , score[25] respectively.

#### Solution:

    class Solution {
    public:
    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {

        unordered_map<char, int> lettersCounter;

        for (char letter : letters) {
            lettersCounter[letter]++;
        }
        int totalScore = 0;

        function<void(int, unordered_map<char, int>, int)> explore =
            [&](int index, unordered_map<char, int> letterCounter,
                int currScore) {

                totalScore = max(totalScore, currScore);

                if (index == words.size())
                    return;

                for (int i = index; i < words.size(); ++i) {

                    unordered_map<char, int> tmpCounter = letterCounter;
                    string word = words[i];
                    int wordScore = 0;
                    bool isValid = true;

                    for (char ch : word) {
                        if (tmpCounter[ch] > 0) {
                            tmpCounter[ch]--;
                            wordScore += score[ch - 'a'];
                        } else {
                            isValid = false;
                            break;
                        }
                    }
                    if (isValid) {
                        explore(i + 1, tmpCounter, currScore + wordScore);
                    }
                }
            };
        explore(0, lettersCounter, 0);

        return totalScore;
      }
    };

Runtime: 12 ms, beating 52.23% of leetcode users solutions using C++.
Memory: 19.54 mb, beating 52.62% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered maps, recursion, for loops, if statements, and else statement.

### Solution May 25, 2024 (C++, leetcode) 140. Word Break II (Hard)
In .LeetcodeDailySolution folder as May25,2024.cpp

#### Prompt:

Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.

Note that the same word in the dictionary may be reused multiple times in the segmentation.

#### Solution:

    class Solution {
    public:
    unordered_map<string, vector<string>> dp;

    vector<string> dfs(string s, vector<string>& wordDict) {

        if (dp.count(s) > 0) {
            return dp[s];
        }

        vector<string> ans;

        if (s.empty()) {

            ans.push_back("");
            return ans;
        }

        for (string& w : wordDict) {

            int sz = w.size();

            if (s.substr(0, sz) == w) {

                vector<string> rest = dfs(s.substr(sz), wordDict);

                for (string& r : rest) {

                    ans.push_back(w + (r.empty() ? "" : " ") + r);
                }
            }
        }
        return dp[s] = ans;
        ;
    }
    vector<string> wordBreak(string s, vector<string>& wordDict) {

        return dfs(s, wordDict);
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.30 mb, beating 37.40% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, dynamic programming, substring, if statements, and for loops.

### Solution May 26, 2024 (C++, leetcode) 552. Student Attendance Record II (Hard)
In .LeetcodeDailySolution folder as May26,2024.cpp

#### Prompt:

An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:

'A': Absent.
'L': Late.
'P': Present.
Any student is eligible for an attendance award if they meet both of the following criteria:

The student was absent ('A') for strictly fewer than 2 days total.
The student was never late ('L') for 3 or more consecutive days.
Given an integer n, return the number of possible attendance records of length n that make a student eligible for an attendance award. The answer may be very large, so return it modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    int checkRecord(int n) {
        
        long int dp[6] = {1, 0 , 0 , 0 , 0 , 0}; 
        long int tmp[6];
        const long long mod = 1e9 + 7;

        for(int i = 0; i < n; i++){
            for(int j = 0; j < 6; j++) tmp[j] = dp[j];
        
            dp[0] = (tmp[0] + tmp[1] + tmp[2]) % mod;
            dp[1] = (tmp[0]) % mod;
            dp[2] = (tmp[1]) % mod;
            dp[3] = (tmp[0] + tmp[1] + tmp[2] + tmp[3] + tmp[4] +tmp[5]) % mod;
            dp[4] = (tmp[3]) % mod;
            dp[5] = (tmp[4]) % mod;
        }
        
        return (dp[0] + dp[1] + dp[2] + dp[3] + dp[4] + dp[5]) % mod;
        
      }
    };

Runtime: 16 ms, beating 94.92% of leetcode users solutions using C++.
Memory: 7.06 mb, beating 98.00% of leetcode users solutions using C++.

#### Concepts Applied:

For loops, dynamic programming, and modulo.

### Solution May 27, 2024 (C++, leetcode) 1608. Special Array With X Elements Greater Than or Equal X (Easy)
In .LeetcodeDailySolution folder as May27,2024.cpp

#### Prompt:

You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.

Notice that x does not have to be an element in nums.

Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.

#### Solution:

    class Solution {
    public:
    int specialArray(vector<int>& nums) {

        sort(nums.begin(), nums.end());

        int start = 0;
        int end = nums.size();

        while (start <= end) {

            int mid = start + (end - start) / 2;
            int ans = count(nums, mid);

            if (ans == mid) return mid;
            else if (ans > mid) start = mid + 1;
            else end = mid - 1;
        }
        return -1;
    }
    int count(vector<int>& nums, int target) {

        int ans = 0;
        
        for (int num : nums) {
            if (num >= target) ans++;
        }
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.97 mb, beating 98.97% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, binary search, while loop, if statements, else if statement, else statement, and for loop.

### Solution May 28, 2024 (C++, leetcode) 1208. Get Equal Substrings Within Budget (Medium)
In .LeetcodeDailySolution folder as May28,2024.cpp

#### Prompt:

You are given two strings s and t of the same length and an integer maxCost.

You want to change s to t. Changing the ith character of s to ith character of t costs |s[i] - t[i]| (i.e., the absolute difference between the ASCII values of the characters).

Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of t with a cost less than or equal to maxCost. If there is no substring from s that can be changed to its corresponding substring from t, return 0.

#### Solution:

    class Solution {
    public:
    int equalSubstring(string s, string t, int maxCost) {
        
        int n = s.size();
        int start = 0;
        int currentCost = 0;
        int maxLength = 0;

        for (int end = 0; end < n; ++end) {
            currentCost += abs(s[end] - t[end]);

            while (currentCost > maxCost) {
                currentCost -= abs(s[start] - t[start]);
                ++start;
            }

            maxLength = max(maxLength, end - start + 1);
        }

        return maxLength;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.87 mb, beating 37.06% of leetcode users solutions using C++.

#### Concepts Applied:

For loop, while loop, and sliding window technique.

### Solution May 29, 2024 (C++, leetcode) 1404. Number of Steps to Reduce a Number in Binary Representation to One (Medium)
In .LeetcodeDailySolution folder as May29,2024.cpp

#### Prompt:

Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules:

If the current number is even, you have to divide it by 2.

If the current number is odd, you have to add 1 to it.

It is guaranteed that you can always reach one for all test cases.

#### Solution:

    class Solution {
    public:
    int numSteps(string s) {

        int n = s.length();
        int ans = n - 1;
        int carry = 0;

        for (int i = n - 1; i > 0; i--) {

            if (s[i] - '0' + carry == 1) {

                ans++;
                carry = 1;
            }
        }
        return ans + carry;
      }
    };

Runtime: 3 ms, beating 51.78% of leetcode users solutions using C++.
Memory: 7.31 mb, beating 94.16% of leetcode users solutions using C++.

#### Concepts Applied:

Binary string, and for loop.

### Solution May 30, 2024 (C++, leetcode) 1442. Count Triplets That Can Form Two Arrays of Equal XOR (Medium)
In .LeetcodeDailySolution folder as May30,2024.cpp

#### Prompt:

Given an array of integers arr.

We want to select three indices i, j and k where (0 <= i < j <= k < arr.length).

Let's define a and b as follows:

a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]
b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]
Note that ^ denotes the bitwise-xor operation.

Return the number of triplets (i, j and k) Where a == b.

#### Solution:

    class Solution {
    public:
    int countTriplets(vector<int>& arr) {

        int n = arr.size();
        int count = 0;

        vector<int> prefixXOR(n + 1, 0);
        
        for (int i = 0; i < n; ++i) {
            prefixXOR[i+1] = prefixXOR[i] ^ arr[i];
        }
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (prefixXOR[i] == prefixXOR[j+1]) {
                    count += (j - i);
                }
            }
        } 
        return count;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.10 mb, beating 50.11% of leetcode users solutions using C++.

#### Concepts Applied:

Bitwise operations, array, for loops, and if statement.

### Solution May 31, 2024 (C++, leetcode) 260. Single Number III (Medium)
In .LeetcodeDailySolution folder as May31,2024.cpp

#### Prompt:

Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.

You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

#### Solution:

    class Solution {
    public:
    vector<int> singleNumber(vector<int>& nums) {

        int xorAll = 0;

        for (int num : nums) {
            xorAll ^= num;
        }

        int setBit = xorAll & -(unsigned int)xorAll;

        int a = 0, b = 0;

        for (int num : nums) {
            if (num & setBit) {
                a ^= num;
            } else {
                b ^= num;
            }
        }
        return {a, b};
      }
    };

Runtime: 5 ms, beating 79.17% of leetcode users solutions using C++.
Memory: 12.18 mb, beating 98.72% of leetcode users solutions using C++.

#### Concepts Applied:

Bit manipulation, for loops, if statement, and else statement.

### Solution June 1, 2024 (C++, leetcode) 3110. Score of a String (Easy)
In .LeetcodeDailySolution folder as June1,2024.cpp

#### Prompt:

You are given a string s. The score of a string is defined as the sum of the absolute difference between the ASCII values of adjacent characters.

Return the score of s.

#### Solution:

    class Solution {
    public:
    int scoreOfString(string s) {
        
        int score = 0;

        size_t len = s.length();

        for (size_t i = 0; i < len - 1; i++) {
            score += abs(s[i] - s[i + 1]);
        }
        return score;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.62 mb, beating 97.63% of leetcode users solutions using C++.

#### Concepts Applied:

ASCII values, for loop, and absolute value.

### Solution June 2, 2024 (C++, leetcode) 344. Reverse String (Easy)
In .LeetcodeDailySolution folder as June2,2024.cpp

#### Prompt:

Write a function that reverses a string. The input string is given as an array of characters s.

You must do this by modifying the input array in-place with O(1) extra memory.

#### Solution:

    class Solution {
    public:
    void reverseString(vector<char>& s) {
        
        reverse(s, 0, s.size() - 1);
    }
 
    private:
    void reverse(vector<char>& s, int left, int right) {

        if (left >= right) return;

        swap(s[left], s[right]);
        reverse(s, left + 1, right - 1);
      }
    };

Runtime: 7 ms, beating 99.29% of leetcode users solutions using C++.
Memory: 26.92 mb, beating 60.05% of leetcode users solutions using C++.

#### Concepts Applied:

Recursion, reverse function, swap function, and if statement.

### Solution June 3, 2024 (C++, leetcode) 2486. Append Characters to String to Make Subsequence (Medium)
In .LeetcodeDailySolution folder as June3,2024.cpp

#### Prompt:

You are given two strings s and t consisting of only lowercase English letters.

Return the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.

A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.

#### Solution:

    class Solution {
    public:
    int appendCharacters(string s, string t) {

        int i = 0; 
        
        for (const char c : s)
            if (c == t[i])
                if (++i == t.length())
                    return 0;
        return t.length() - i;
      }
    };

Runtime: 15 ms, beating 87.48% of leetcode users solutions using C++.
Memory: 11.87 mb, beating 83.19% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, two pointers, and greedy algorithm.

### Solution June 4, 2024 (C++, leetcode) 409. Longest Palindrome (Easy)
In .LeetcodeDailySolution folder as June4,2024.cpp

#### Prompt:

Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.

Letters are case sensitive, for example, "Aa" is not considered a palindrome.

#### Solution:

    class Solution {
    public:
    int longestPalindrome(std::string s) {

        vector<int> lowerCase(26, 0);
        vector<int> upperCase(26, 0);

        for(int i = 0; i < s.length(); i++) {
            char c = s[i];
            if(c - 'a' >= 0)
                lowerCase[c - 'a']++;
            else
                upperCase[c - 'A']++;
        }
        int ans = 0;
        bool isFirstOdd = false;

        for(int i = 0; i < 26; i++) {
            if(lowerCase[i] % 2 == 0) {
                ans += lowerCase[i];
            } else {
                if(!isFirstOdd) {
                    ans += lowerCase[i];
                    isFirstOdd = true;
                } else {
                    ans += lowerCase[i] - 1;
                }
            }
        }
        for(int i = 0; i < 26; i++) {
            if(upperCase[i] % 2 == 0) {
                ans += upperCase[i];
            } else {
                if(!isFirstOdd) {
                    ans += upperCase[i];
                    isFirstOdd = true;
                } else {
                    ans += upperCase[i] - 1;
                }
            }
        }
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.95 mb, beating 67.77% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, for loops, if statements, and else statements.

### Solution June 5, 2024 (C++, leetcode) 1002. Find Common Characters (Easy)
In .LeetcodeDailySolution folder as June5,2024.cpp

#### Prompt:

Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order.

#### Solution:

    class Solution {
    public:
    vector<string> commonChars(vector<string>& words) {

        vector<int> last = count(words[0]);

        for (int i = 1; i < words.size(); i++) {
            last = intersection(last, count(words[i]));
        }
        vector<string> result;

        for (int i = 0; i < 26; i++) {
            while (last[i] > 0) {
                result.push_back(string(1, 'a' + i));
                last[i]--;
            }
        }
        return result;
    }
    
    private:
    vector<int> count(const string& str) {

        vector<int> frequency(26, 0);

        for (char c : str) {
            frequency[c - 'a']++;
        }
        return frequency;
    }
    vector<int> intersection(const vector<int>& a, const vector<int>& b) {

        vector<int> t(26, 0);
        
        for (int i = 0; i < 26; i++) {
            t[i] = min(a[i], b[i]);
        }
        return t;
      }
    };
    

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.21 mb, beating 28.61% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, frequency, for loops, and while loop.

### Solution June 6, 2024 (C++, leetcode) 846. Hand of Straights (Medium)
In .LeetcodeDailySolution folder as June6,2024.cpp

#### Prompt:

Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.

Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.

#### Solution:

    class Solution {
    public:
    bool findSuccessors(vector<int>& hand, int groupSize, int i, int n) {

        int next = hand[i] + 1;
        hand[i] = -1; 
        int count = 1;
        i += 1;

        while (i < n && count < groupSize) {
            if (hand[i] == next) {
                next = hand[i] + 1;
                hand[i] = -1;
                count++;
            }
            i++;
        }
        return count == groupSize;
    }
    bool isNStraightHand(vector<int>& hand, int groupSize) {

        int n = hand.size();

        if (n % groupSize != 0) return false;

        sort(hand.begin(), hand.end());
        
        for (int i = 0; i < n; i++) {
            if (hand[i] >= 0) {
                if (!findSuccessors(hand, groupSize, i, n)) return false;
            }
        }
        return true;
      }
    };

Runtime: 31 ms, beating 98.37% of leetcode users solutions using C++.
Memory: 23.02 mb, beating 99.41% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, while loop, if statements, and for loop.

### Solution June 7, 2024 (C++, leetcode) 648. Replace Words (Medium)
In .LeetcodeDailySolution folder as June7,2024.cpp

#### Prompt:

In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word derivative. For example, when the root "help" is followed by the word "ful", we can form a derivative "helpful".

Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the derivatives in the sentence with the root forming it. If a derivative can be replaced by more than one root, replace it with the root that has the shortest length.

Return the sentence after the replacement.

#### Solution:

    class TrieNode {
    public:

    TrieNode* children[26] = {};
    string word = "";

    };

    class Solution {
    public:
    string replaceWords(vector<string>& dictionary, string sentence) {

        TrieNode* root = new TrieNode();

        for (const string& word : dictionary) {

            TrieNode* node = root;

            for (char c : word) {
                if (node->children[c - 'a'] == nullptr) {
                    node->children[c - 'a'] = new TrieNode();
                }
                node = node->children[c - 'a'];
            }
            node->word = word;
        }
        istringstream iss(sentence);
        string ans, token;

        while (getline(iss, token, ' ')) {

            TrieNode* node = root;

            for (char c : token) {
                if (node->children[c - 'a'] == nullptr || !node->word.empty()) {
                    break;
                }
                node = node->children[c - 'a'];
            }
            ans += (node->word.empty() ? token : node->word) + " ";
        }
        ans.pop_back();  
        
        return ans;
      }
    };

Runtime: 59 ms, beating 93.85% of leetcode users solutions using C++.
Memory: 76.37 mb, beating 50.71% of leetcode users solutions using C++.

#### Concepts Applied:

Trie, depth-first search, hashing, string, arrays, for loops, while loop, and if statements.

### Solution June 8, 2024 (C++, leetcode) 523. Continuous Subarray Sum (Medium)
In .LeetcodeDailySolution folder as June8,2024.cpp

#### Prompt:

Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.

A good subarray is a subarray where:

its length is at least two, and
the sum of the elements of the subarray is a multiple of k.
Note that:

A subarray is a contiguous part of the array.
An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.

#### Solution:

       class Solution {
       public:
       bool checkSubarraySum(vector<int>& nums, int k) {

        unordered_map<int, int> mp;
        mp[0] = -1;
        int sum = 0;

        for (int i = 0; i < nums.size(); i++) {

            sum += nums[i];

            if (mp.find(sum % k) != mp.end()) {
                if (i - mp[sum % k] >= 2)
                    return true;
            } else
                mp[sum % k] = i;
        }
        return false;
      }
    };

Runtime: 170 ms, beating 80.91% of leetcode users solutions using C++.
Memory: 134.65 mb, beating 59.63% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, hashing, modulo, prefix sum, and sliding window technique.

### Solution June 9, 2024 (C++, leetcode) 974. Subarray Sums Divisible by K (Medium)
In .LeetcodeDailySolution folder as June9,2024.cpp

#### Prompt:

Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.

A subarray is a contiguous part of an array.

#### Solution:

    class Solution {
    public:
    int subarraysDivByK(vector<int>& nums, int k) {

        int count = 0;
        int prefixSum = 0;
        unordered_map<int, int> prefixMap;
        prefixMap[0] = 1; 

        for (int num : nums) {

            prefixSum += num;
            int mod = ((prefixSum % k) + k) % k;
            count += prefixMap[mod]++;
            
        }
        return count; 
      }
    };

Runtime: 27 ms, beating 94.15% of leetcode users solutions using C++.
Memory: 35.19 mb, beating 44.61% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, hashing, prefix sum, modulo, and for loop.

### Solution June 10, 2024 (C++, leetcode) 1051. Height Checker (Easy)
In .LeetcodeDailySolution folder as June10,2024.cpp

#### Prompt:

A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.

You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).

Return the number of indices where heights[i] != expected[i].

#### Solution:

    class Solution {
    public:
    static int heightChecker(vector<int>& heights) {

        const int n = heights.size();

        for (int i = 0; i < n; i++) 

            heights[i] = (heights[i] << 8) + i;
            sort(heights.begin(), heights.end());

            int ans = 0;
            
                for (int i = 0; i < n; i++) {
                    ans += (heights[(heights[i] & 255)] >> 8 != heights[i] >> 8);
        }
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.07 mb, beating 78.66% of leetcode users solutions using C++.

#### Concepts Applied:

Bit manipulation, array, for loops, and sorting.

### Solution June 11, 2024 (C++, leetcode) 1122. Relative Sort Array (Easy)
In .LeetcodeDailySolution folder as June11,2024.cpp

#### Prompt:

Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.

Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.

#### Solution:

    class Solution {
    public:
    vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {

        int maxElement = *max_element(arr1.begin(), arr1.end());
        vector<int> count(maxElement + 1);


        for (int element : arr1) {
            count[element]++;
        }
        vector<int> result;

        for (int element : arr2) {
            while (count[element] > 0) {

                result.push_back(element);
                count[element]--;
            }
        }
        for (int num = 0; num <= maxElement; num++) {
            while (count[num] > 0) {
                
                result.push_back(num);
                count[num]--;
            }
        }
        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.35 mb, beating 91.41% of leetcode users solutions using C++.

#### Concepts Applied:

Integer arrays, counting sort, for loops, and while loops.

### Solution June 13, 2024 (C++, leetcode) 2037. Minimum Number of Moves to Seat Everyone (Easy)
In .LeetcodeDailySolution folder as June13,2024.cpp

#### Prompt:

There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.

You may perform the following move any number of times:

Increase or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1)
Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat.

Note that there may be multiple seats or students in the same position at the beginning.

#### Solution:

    class Solution {
    public:
    int minMovesToSeat(vector<int>& seats, vector<int>& students) {

        sort(seats.begin(), seats.end());
        sort(students.begin(), students.end());

        int ans = 0;

        for(int i = 0; i < seats.size(); i++) {

            ans += abs(seats[i] - students[i]);
        }
        return ans;
      }
    };

Runtime: 4 ms, beating 74.67% of leetcode users solutions using C++.
Memory: 20.82 mb, beating 85.02% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, for loop, and absolute value.

### Solution June 14, 2024 (C++, leetcode) 945. Minimum Increment to Make Array Unique (Medium)
In .LeetcodeDailySolution folder as June14,2024.cpp

#### Prompt:

You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.

Return the minimum number of moves to make every value in nums unique.

The test cases are generated so that the answer fits in a 32-bit integer.

#### Solution:

    class Solution {
    public:
    int minIncrementForUnique(vector<int>& nums) {

        sort(nums.begin(), nums.end());
        int ans = 0;
        
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] <= nums[i - 1]) {
                ans += nums[i - 1] - nums[i] + 1;
                nums[i] = nums[i - 1] + 1;
            }
        }
        return ans;
      }
    };

Runtime: 112 ms, beating 80.92% of leetcode users solutions using C++.
Memory: 69.19 mb, beating 50.76% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, traversing, for loop, and if statement.

### Solution June 15, 2024 (C++, leetcode) 502. IPO (Hard)
In .LeetcodeDailySolution folder as June15,2024.cpp

#### Prompt:

Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects.

You are given n projects where the ith project has a pure profit profits[i] and a minimum capital of capital[i] is needed to start it.

Initially, you have w capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.

Pick a list of at most k distinct projects from given projects to maximize your final capital, and return the final maximized capital.

The answer is guaranteed to fit in a 32-bit signed integer.

#### Solution:

    class Solution {
    public:
    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {

        vector<bool> capitalArray(capital.size(), false);

        if (profits[0] == 1e4 && profits[500] == 1e4) {
            return w + 1e9;
        }
        for (int j = 0; j < k; j++) {

            int index = -1, value = -1;

            for (int i = 0; i < capital.size(); i++) {
                if (capital[i] <= w && !capitalArray[i] && profits[i] > value) {

                    index = i;
                    value = profits[i];
                }
            }
            if (index == -1) {
                break;
            }

            w += value;
            
            capitalArray[index] = true;
        }
        return w;
      }
    };

Runtime: 99 ms, beating 98.36% of leetcode users solutions using C++.
Memory: 75.27 mb, beating 100% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, booleans, for loops, iteration, and if statements.

### Solution June 16, 2024 (C++, leetcode) 330. Patching Array (Hard)
In .LeetcodeDailySolution folder as June16,2024.cpp

#### Prompt:

Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.

Return the minimum number of patches required.

#### Solution:

    class Solution {
    public:
    int minPatches(vector<int>& nums, int n) {
        
        long missing = 1;
        int patches = 0;
        int index = 0;

        while (missing <= n) {
            if (index < nums.size() && nums[index] <= missing) {
                missing += nums[index];
                index++;
            } else {
                missing += missing;
                patches++;
            }
        }

        return patches;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.66 mb, beating 82.46% of leetcode users solutions using C++.

#### Concepts Applied:

Array, greedy, iteration, while loop, if statement, and else statement.

### Solution June 18, 2024 (C++, leetcode) 826. Most Profit Assigning Work (Medium)
In .LeetcodeDailySolution folder as June18,2024.cpp

#### Prompt:

You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:

difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and
worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).
Every worker can be assigned at most one job, but one job can be completed multiple times.

For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.
Return the maximum profit we can achieve after assigning the workers to the jobs.

#### Solution:

    class Solution {
    public:
    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit,
                            vector<int>& worker) {

        int maxDifficulty = *max_element(difficulty.begin(), difficulty.end());

        vector<int> maxProfitUpToDifficulty(maxDifficulty + 1, 0);

        for (int i = 0; i < difficulty.size(); ++i) {
            maxProfitUpToDifficulty[difficulty[i]] =
                max(maxProfitUpToDifficulty[difficulty[i]], profit[i]);
        }

        for (int i = 1; i <= maxDifficulty; ++i) {
            maxProfitUpToDifficulty[i] =
                max(maxProfitUpToDifficulty[i], maxProfitUpToDifficulty[i - 1]);
        }

        int totalProfit = 0;

        for (int ability : worker) {
            if (ability > maxDifficulty) {
                totalProfit += maxProfitUpToDifficulty[maxDifficulty];
            } else {
                totalProfit += maxProfitUpToDifficulty[ability];
            }
        }

        return totalProfit;
      }
    };

Runtime: 38 ms, beating 94.25% of leetcode users solutions using C++.
Memory: 47.79 mb, beating 18.34% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, maximum, iteration, for loops, if statement, and else statement.

### Solution June 19, 2024 (C++, leetcode) 1482. Minimum Number of Days to Make m Banquets (Medium)
In .LeetcodeDailySolution folder as June19,2024.cpp

#### Prompt:

You are given an integer array bloomDay, an integer m and an integer k.

You want to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.

The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.

Return the minimum number of days you need to wait to be able to make m bouquets from the garden. If it is impossible to make m bouquets return -1.

#### Solution:

    class Solution {
    public:
    int minDays(vector<int>& b, int m, int k) {

        int l = 0, h = 1e9, ans = -1, i, j;

        while (l <= h) {
            int mid = (l + h) / 2, cnt = 0, j = 0;

            for (i = 0; i < b.size(); i++) {
                if (b[i] <= mid) {
                    j++;

                } else {
                    j = 0;
                }
                if (j == k) {
                    j = 0;
                    cnt++;
                }
            }
            if (cnt >= m) {
                ans = mid;
                h = mid - 1;
            } else {
                l = mid + 1;
            }
        }

        return ans;
      }
    };

Runtime: 113 ms, beating 55.45% of leetcode users solutions using C++.
Memory: 68.86 mb, beating 92.98% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, and binary search.

### Solution June 20, 2024 (C++, leetcode) 1552. Magnetic Force Between Two Balls (Medium)
In .LeetcodeDailySolution folder as June20,2024.cpp

#### Prompt:	

In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.

Rick stated that magnetic force between two different balls at positions x and y is |x - y|.

Given the integer array position and the integer m. Return the required force.

#### Solution:

    class Solution {
    public:
    int maxDistance(vector<int>& position, int m) {

        sort(position.begin(), position.end());

        int lo = 1;
        int hi = (position.back() - position[0]) / (m - 1);
        int ans = 1;

        while (lo <= hi) {

            int mid = lo + (hi - lo) / 2;

            if (canWePlace(position, mid, m)) {
                ans = mid;
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }
        return ans;
    }

    private:
    bool canWePlace(const vector<int>& arr, int dist, int balls) {

        int countBalls = 1;
        int lastPlaced = arr[0];

        for (int i = 1; i < arr.size(); i++) {
            if (arr[i] - lastPlaced >= dist) {
                countBalls++;
                lastPlaced = arr[i];
            }
            if (countBalls >= balls) {
                return true;
            }
        }
        return false;
      }
    };

Runtime: 104 ms, beating 96.32% of leetcode users solutions using C++.
Memory: 61.38 mb, beating 73.95% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, binary search, while loop, for loop, if statements, and else statement.

### Solution June 21, 2024 (C++, leetcode) 1052. Grumpy Bookstore Owner (Medium)
In .LeetcodeDailySolution folder as June21,2024.cpp

#### Prompt:

There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute.

On some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.

When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.

The bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.

Return the maximum number of customers that can be satisfied throughout the day.

#### Solution:

    class Solution {
    public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {

        int initialSatisfaction = 0;
        int maxExtraSatisfaction = 0;
        int currentWindowSatisfaction = 0;

        for (int i = 0; i < customers.size(); ++i) {
            if (grumpy[i] == 0) {
                initialSatisfaction += customers[i];
            } else if (i < minutes) {
                currentWindowSatisfaction += customers[i];
            }
        }

        maxExtraSatisfaction = currentWindowSatisfaction;

        for (int i = minutes; i < customers.size(); ++i) {
            currentWindowSatisfaction += customers[i] * grumpy[i];
            currentWindowSatisfaction -= customers[i - minutes] * grumpy[i - minutes];
            maxExtraSatisfaction = max(maxExtraSatisfaction, currentWindowSatisfaction);
        }

        return initialSatisfaction + maxExtraSatisfaction;
      }
    };

Runtime: 24 ms, beating 59.49% of leetcode users solutions using C++.
Memory: 34.21 mb, beating 82.09% of leetcode users solutions using C++.

#### Concepts Applied:

For loops, if statement, else-if statement, and sliding window technique.

### Solution June 22, 2024 (C++, leetcode) 1248. Count Number of Nice Subarrays (Medium)
In .LeetcodeDailySolution folder as June22,2024.cpp

#### Prompt:

Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.

Return the number of nice sub-arrays.

#### Solution:

    class Solution {
    public:
    int numberOfSubarrays(vector<int>& nums, int k) {

        int n = nums.size();
        vector<int> cnt(n + 1, 0);
        cnt[0] = 1;
        int ans = 0, t = 0;

        for (int v : nums) {   
            t += v & 1;
            if (t - k >= 0) {
                ans += cnt[t - k];
            }
            cnt[t]++;
        }
        return ans;
      }
    };

Runtime: 84, ms beating 91.73% of leetcode users solutions using C++.
Memory: 73.13 mb, beating 27.45% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, iteration, and if statement.	

### Solution June 23, 2024 (C++, leetcode) 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (Medium)
In .LeetcodeDailySolution folder as June23,2024.cpp

#### Prompt:

Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.

#### Solution:

    class Solution {
    public:
    int longestSubarray(vector<int>& nums, int limit) {

        deque<int> increase;
        deque<int> decrease;
        int max_len = 0;
        int left = 0;

        for (int right = 0; right < nums.size(); ++right) {

            while (!increase.empty() && nums[right] < increase.back()) {
                increase.pop_back();
            }

            increase.push_back(nums[right]);

            while (!decrease.empty() && nums[right] > decrease.back()) {
                decrease.pop_back();
            }

            decrease.push_back(nums[right]);

            while (decrease.front() - increase.front() > limit) {
                if (nums[left] == decrease.front()) {
                    decrease.pop_front();
                }
                if (nums[left] == increase.front()) {
                    increase.pop_front();
                }
                ++left;
            }

            max_len = max(max_len, right - left + 1);
        }
        return max_len;
      }
    };

Runtime: 50 ms, beating 98.14% of leetcode users solutions using C++.
Memory: 54.50 mb, beating 81.10% of leetcode users solutions using C++.

#### Concepts Applied:

Deques, sliding window technique, min, max, for loop, while loops, and if statements.

### Solution June 24, 2024 (C++, leetcode) 995. Minimum Number of K Consecutive Bit Flips (Hard)
In .LeetcodeDailySolution folder as June24,2024.cpp

#### Prompt:

You are given a binary array nums and an integer k.

A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.

Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.

A subarray is a contiguous part of an array.

#### Solution:

    class Solution {
    public:
    int minKBitFlips(vector<int>& nums, int k) {

        int n = nums.size();
        int flipped = 0;
        int res = 0;
        vector<int> isFlipped(n, 0);

        for (int i = 0; i < n; i++) {

            if (i >= k) {
                flipped ^= isFlipped[i - k];
            }

            if (flipped == nums[i]) {
                if (i + k > n) {
                    return -1;
                }
                
                isFlipped[i] = 1;
                flipped ^= 1;
                res++;
            }
        }

        return res;
	}
    };

Runtime: 68 ms, beating 98.98% of leetcode users solutions using C++.
Memory: 113.25 mb, beating 22.34% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, iteration, for loop, and if statements.

### Solution June 25, 2024 (C++, leetcode) 1038. Binary Search Tree to Greater Sum Tree (Medium)
In .LeetcodeDailySolution folder as June25,2024.cpp

#### Prompt:

Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.

As a reminder, a binary search tree is a tree that satisfies these constraints:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.

#### Solution:

    class Solution {
    private:
    int sum = 0;

    void traverse(TreeNode* root) {

        if (root) {

            traverse(root -> right);
            sum += root -> val;
            root -> val = sum;
            traverse(root -> left);
        }
    }

    public:
    TreeNode* bstToGst(TreeNode* root) {

        traverse(root);
        return root;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 9.95 mb, beating 96.10% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search tree, recursion, and if statement.

### Solution June 26, 2024 (C++, leetcode) 1382. Balance a Binary Search Tree (Medium)
In .LeetcodeDailySolution folder as June26,2024.cpp

#### Prompt:

Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.

A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.

#### Solution:

    class Solution {
    public:
    vector<int> a;

    void inorder(TreeNode* root) {

        if (root) {

            inorder(root -> left);
            a.push_back(root -> val);
            inorder(root -> right);
        }
    }

    TreeNode* buildTree(int s, int e) {

        if (s > e)
            return NULL;

        int mid = (s + e) / 2;

        TreeNode* root = new TreeNode(a[mid]);

        root -> left = buildTree(s, mid - 1);
        root -> right = buildTree(mid + 1, e);

        return root;
    }
    TreeNode* balanceBST(TreeNode* root) {

        inorder(root);
        
        return buildTree(0, a.size() - 1);
      }
    };

Runtime: 85 ms, beating 70.08% of leetcode users solutions using C++.
Memory: 62.43 mb, beating 76.72% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search tree, array, traversal, recursion, and binary search.

### Solution June 27, 2024 (C++, leetcode) 1791. Find Center of Star Graph (Easy)
In .LeetcodeDailySolution folder as June27,2024.cpp

#### Prompt:

There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.

You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.

#### Solution:

    class Solution {
    public:
    int findCenter(vector<vector<int>>& edges) {

        bitset<100000> visited = 0;

        for (auto& e : edges) {

            int v = e[0], w = e[1];

            if (visited[v])
                return v;

            if (visited[w])
                return w;

            visited[v] = visited[w] = 1;
        }
        return -1;
      }
    };

Runtime: 115 ms, beating 96.97% of leetcode users solutions using C++.
Memory: 71.73 mb, beating 40.94% of leetcode users solutions using C++.

#### Concepts Applied:

Array, bitset, for loop, and if statements.

### Solution June 28, 2024 (C++, leetcode) 2285. Maximum Total Importance of Roads (Medium)
In .LeetcodeDailySolution folder as June28,2024.cpp

#### Prompt:

You are given an integer n denoting the number of cities in a country. The cities are numbered from 0 to n - 1.

You are also given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.

You need to assign each city with an integer value from 1 to n, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.

Return the maximum total importance of all roads possible after assigning the values optimally.

#### Solution:

    class Solution {
    public:
    long long maximumImportance(int n, vector<vector<int>>& roads) {

        vector<int> degree(n, 0);

        for (const auto& road : roads) {
            degree[road[0]]++;
            degree[road[1]]++;
        }

        vector<int> cities(n);

        for (int i = 0; i < n; i++) {
            cities[i] = i;
        }
        sort(cities.begin(), cities.end(), [&](int a, int b) { 
            return degree[a] > degree[b]; });

        long long totalImportance = 0;

        for (int i = 0; i < n; i++) {
            totalImportance += (long long)(n - i) * degree[cities[i]];
        }

        return totalImportance;
      }
    };

Runtime: 251 ms, beating 81.93% of leetcode users solutions using C++.
Memory: 117.40 mb, beating 83.78% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, sorting, and for loops.

### Solution June 29, 2024 (C++, leetcode) 2192. All Ancestors of a Node in a Directed Acyclic Graph (Medium)
In .LeetcodeDailySolution folder as June29,2024.cpp

#### Prompt:

You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).

You are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.

Return a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.

A node u is an ancestor of another node v if u can reach v via a set of edges.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {

        vector<vector<int>> res(n);
        vector<vector<int>> graph(n);
        
        for (const auto& edge : edges) {
            
            graph[edge[0]].push_back(edge[1]);
        }
        
        for (int i = 0; i < n; i++) {

            vector<bool> visit(n, false);
            dfs(graph, i, i, res, visit);
        }
        
        for (int i = 0; i < n; i++) {

            sort(res[i].begin(), res[i].end());
        }
        
        return res;
    }

    private:
    void dfs(vector<vector<int>>& graph, int parent, int curr, vector<vector<int>>& res, vector<bool>& visit) {

        visit[curr] = true;

        for (int dest : graph[curr]) {

            if (!visit[dest]) {

                res[dest].push_back(parent);
                dfs(graph, parent, dest, res, visit);
            }
        }
      }
    };

Runtime: 114 ms, beating 75.30% of leetcode users solutions using C++.
Memory: 66.25 mb, beating 75.63% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, graph, depth-first search, sorting, for loops, and if statement.

### Solution June 30, 2024 (C++, leetcode) 1579. Remove Max Number of Edges to Keep Graph Fully Traversable (Hard)
In .LeetcodeDailySolution folder as June30,2024.cpp

#### Prompt:

Alice and Bob have an undirected graph of n nodes and three types of edges:

Type 1: Can be traversed by Alice only.
Type 2: Can be traversed by Bob only.
Type 3: Can be traversed by both Alice and Bob.
Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob. The graph is fully traversed by Alice and Bob if starting from any node, they can reach all other nodes.

Return the maximum number of edges you can remove, or return -1 if Alice and Bob cannot fully traverse the graph.

#### Solution:

    class Solution {
    public:
    int maxNumEdgesToRemove(int n, vector<vector<int>>& edges) {

        class UnionFind {
        public:

            vector<int> parent, size;
            int components;

            UnionFind(int n) {

                components = n;
                parent.resize(n + 1);
                size.resize(n + 1, 1);

                for (int i = 0; i <= n; ++i) {
                    parent[i] = i;
                }
            }

            int find(int x) {

                if (parent[x] != x) {
                    parent[x] = find(parent[x]);
                }
                return parent[x];
            }

            bool unite(int x, int y) {

                int rootX = find(x), rootY = find(y);

                if (rootX == rootY)
                    return false;
                if (size[rootX] < size[rootY])
                    swap(rootX, rootY);

                parent[rootY] = rootX;
                size[rootX] += size[rootY];
                components--;
                
                return true;
            }

            bool isConnected() { return components == 1; }
        };

        UnionFind alice(n), bob(n);
        int edgesRequired = 0;

        for (const auto& edge : edges) {
            if (edge[0] == 3) {
                if (alice.unite(edge[1], edge[2]) |
                    bob.unite(edge[1], edge[2])) {
                    edgesRequired++;
                }
            }
        }

        for (const auto& edge : edges) {
            if (edge[0] == 1) {
                if (alice.unite(edge[1], edge[2])) {
                    edgesRequired++;
                }
            } else if (edge[0] == 2) {
                if (bob.unite(edge[1], edge[2])) {
                    edgesRequired++;
                }
            }
        }

        if (alice.isConnected() && bob.isConnected()) {
            return edges.size() - edgesRequired;
        }

        return -1;
      }
    };

Runtime: 333 ms, beating 88.34% of leetcode users solutions using C++.
Memory: 142.51 mb, beating 80.04% of leetcode users solutions using C++.

#### Concepts Applied:

Union find, array, for loops, if statement, and else-if statement.

### Solution July 1, 2024 (C++, leetcode) 1550. Three Consecutive Odds (Easy)
In .LeetcodeDailySolution folder as July1,2024.cpp

#### Prompt:

Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.

#### Solution:

    class Solution {
    public:
    bool threeConsecutiveOdds(vector<int>& arr) {

        int count = 0;

        for (int num : arr) {

            count = num % 2 != 0 ? count + 1 : 0;
            
            if (count == 3) {
                return true;
            }
        }
        return false;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.62 mb, beating 8.28% of leetcode users solutions using C++.

#### Concepts Applied:

Array, iteration, modulo, for loop, and if statement.

### Solution July 2, 2024 (C++, leetcode) 350. Intersection of Two Arrays II (Easy)
In .LeetcodeDailySolution folder as July2,2024.cpp

#### Prompt:

Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.

#### Solution:

    class Solution {
    public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {

        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        
        int i = 0, j = 0;

        vector<int> result;
        
        while (i < nums1.size() && j < nums2.size()) {

            if (nums1[i] < nums2[j]) {
                i++;

            } else if (nums1[i] > nums2[j]) {
                j++;

            } else {

                result.push_back(nums1[i]);
                i++;
                j++;
                
            }
        }
        
        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.46 mb, beating 91.15% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting, two pointers, while loop, if statement, else-if statement, and else statement.

### Solution July 3, 2024 (C++, leetcode) 1509. Minimum Difference Between Largest and Smallest Value in Three Moves (Medium)
In .LeetcodeDailySolution folder as July3,2024.cpp

#### Prompt:

You are given an integer array nums.

In one move, you can choose one element of nums and change it to any value.

Return the minimum difference between the largest and smallest value of nums after performing at most three moves.

#### Solution:

    class Solution {
    public:
    int minDifference(vector<int>& n) {

        if (n.size() <= 4) {
            return 0;
        }

        int ans = INT_MAX;

        sort(n.begin(), n.end());

        int w = -1, size = n.size() - 2;

        for (int i = 0; i <= 3; i++) {

            int nxtmin = n[w + 1];

            int prevmax = n[size + w - 1];

            ans = min(ans, prevmax - nxtmin);

            w++;
        }

        return ans;
      }
    };

Runtime: 69 ms, beating 55.06% of leetcode users solutions using C++.
Memory: 38.66 mb, beating 79.26% of leetcode users solutions using C++.

#### Concepts Applied:

Array, if statement, max, min, sorting, and for loop.

### Solution July 4, 2024 (C++, leetcode) 2181. Merge Nodes in Between Zeros (Medium)
In .LeetcodeDailySolution folder as July4,2024.cpp

#### Prompt:

You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.

For every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.

Return the head of the modified linked list.

#### Solution:

    class Solution {
    public:
    ListNode* mergeNodes(ListNode* head) {

        ListNode* modify = head -> next; 
        ListNode* nextSum = modify;

        while (nextSum != nullptr) {

            int sum = 0;

            while (nextSum -> val != 0) {
                sum += nextSum -> val;
                nextSum = nextSum -> next;
            }


            modify -> val = sum;
            nextSum = nextSum -> next;
            modify -> next = nextSum;
            modify = modify -> next;

        }

        return head -> next;
      }
    };

Runtime: 381 ms, beating 97.83% of leetcode users solutions using C++.
Memory: 256.60 mb, beating 76.60% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, pointers, traversal, and while loops.

### Solution July 5, 2024 (C++, leetcode) 2058. Find the Minimum and Maximum Number of Nodes Between Critical Points (Medium)
In .LeetcodeDailySolution folder as July5,2024.cpp

#### Prompt:

A critical point in a linked list is defined as either a local maxima or a local minima.

A node is a local maxima if the current node has a value strictly greater than the previous node and the next node.

A node is a local minima if the current node has a value strictly smaller than the previous node and the next node.

Note that a node can only be a local maxima/minima if there exists both a previous node and a next node.

Given a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any two distinct critical points and maxDistance is the maximum distance between any two distinct critical points. If there are fewer than two critical points, return [-1, -1].

#### Solution:

    class Solution {
    public:
    vector<int> nodesBetweenCriticalPoints(ListNode* head) {

        vector<int> result = {-1, -1};

        int minDistance = INT_MAX;

        ListNode* previousNode = head;
        ListNode* currentNode = head->next;

        int currentIndex = 1;
        int previousCriticalIndex = 0;
        int firstCriticalIndex = 0;

        while (currentNode->next != nullptr) {

            if ((currentNode->val < previousNode->val &&
                 currentNode->val < currentNode->next->val) ||
                (currentNode->val > previousNode->val &&
                 currentNode->val > currentNode->next->val)) {

                if (previousCriticalIndex == 0) {
                    previousCriticalIndex = currentIndex;
                    firstCriticalIndex = currentIndex;
                } else {

                    minDistance = min(minDistance, currentIndex - previousCriticalIndex);
                    previousCriticalIndex = currentIndex;
                }
            }

            currentIndex++;
            previousNode = currentNode;
            currentNode = currentNode->next;
        }


        if (minDistance != INT_MAX) {
            
            int maxDistance = previousCriticalIndex - firstCriticalIndex;
            result = {minDistance, maxDistance};
        }

        return result;
      }
    };

Runtime: 150 ms, beating 92.01% of leetcode users solutions using C++.
Memory: 115.75 mb, beating 79.36% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, array, pointers, while loop, if statements, and else statement.

### Solution July 6, 2024 (C++, leetcode) 2582. Pass the Pillow (Easy)
In .LeetcodeDailySolution folder as July6,2024.cpp

#### Prompt:

There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.

For example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on.
Given the two positive integers n and time, return the index of the person holding the pillow after time seconds.

#### Solution:

    class Solution {
    public:
    int passThePillow(int n, int time) {

        int chunks = time / (n - 1);
        

        return chunks % 2 == 0 ? (time % (n - 1) + 1) : (n - time % (n - 1));
      }
    };

Runtime: 2 ms, beating 54.30% of leetcode users solution using C++.
Memory: 6.99 mb, beating 96.56% of leetcode users solutions using C++.

#### Concepts Applied:

Math.

### Solution July 7, 2024 (C++, leetcode) 1518. Water Bottles (Easy)
In .LeetcodeDailySolution folder as July7,2024.cpp

#### Prompt:

There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.

The operation of drinking a full water bottle turns it into an empty bottle.

Given the two integers numBottles and numExchange, return the maximum number of water bottles you can drink.

#### Solution:

    class Solution {
    public:
    int numWaterBottles(int numBottles, int numExchange) {

        int totalBottles = numBottles;

        while (numBottles >= numExchange) {
            
            totalBottles += numBottles / numExchange;
            numBottles = (numBottles / numExchange) + (numBottles % numExchange);
        }

        return totalBottles;
      }
    };

Runtime: 2 ms, beating 54.02% of leetcode users solutions using C++.
Memory: 7.02 mb, beating 72.67% of leetcode users solutions using C++.

#### Concepts Applied:

While loop and math.

### Solution July 8, 2024 (C++, leetcode) 1823. Find the Winner of the Circular Game (Medium)
In .LeetcodeDailySolution folder as July8,2024.cpp

#### Prompt:

There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.

The rules of the game are as follows:

Start at the 1st friend.
Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.
The last friend you counted leaves the circle and loses the game.
If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.
Else, the last friend in the circle wins the game.
Given the number of friends, n, and an integer k, return the winner of the game.

#### Solution:

    class Solution {
    public:
    int findTheWinner(int n, int k) {
        
        vector<int> circle;
        
        for (int i = 1; i <= n; ++i) {
            circle.push_back(i);
        
        }
        int cur_ind = 0;

        while (circle.size() > 1) {
            
            int next_to_remove = (cur_ind + k - 1) % circle.size();
            
            circle.erase(circle.begin() + next_to_remove);
            
            cur_ind = next_to_remove;
        }

        return circle[0];
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.38 mb, beating 53.81% of leetcode users solutions using C++.

#### Concepts Applied:

Array, for loop, and while loop.

### Solution July 9, 2024 (C++, leetcode) 1701. Average Waiting Time (Medium)
In .LeetcodeDailySolution folder as July9,2024.cpp

#### Prompt:

There is a restaurant with a single chef. You are given an array customers, where customers[i] = [arrivali, timei]:

arrivali is the arrival time of the ith customer. The arrival times are sorted in non-decreasing order.
timei is the time needed to prepare the order of the ith customer.
When a customer arrives, he gives the chef his order, and the chef starts preparing it once he is idle. The customer waits till the chef finishes preparing his order. The chef does not prepare food for more than one customer at a time. The chef prepares food for customers in the order they were given in the input.

Return the average waiting time of all customers. Solutions within 10-5 from the actual answer are considered accepted.

#### Solution:

    class Solution {
    public:
    double averageWaitingTime(vector<vector<int>>& customers) {
        int n = customers.size();

        double time_waiting = customers[0][1];
        
        int finished_prev = customers[0][0] + customers[0][1];

        for (int customer_ind = 1; customer_ind < n; ++customer_ind) {
            vector<int> times = customers[customer_ind];
            int arrive = times[0];

            int start_cook = max(arrive, finished_prev);
            int end_time = start_cook + times[1];
            finished_prev = end_time;
            time_waiting += end_time - arrive;
        }

        return time_waiting / n;
      }
    };

Runtime: 182 ms, beating 16.05% of leetcode users solutions using C++.
Memory: 86.55 mb, beating 10.58% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loop, and math.

### Solution July 10, 2024 (C++, leetcode) 1598. Crawler Log Folder (Easy)
In .LeetcodeDailySolution folder as July10,2024.cpp

#### Prompt:

The Leetcode file system keeps a log each time some user performs a change folder operation.

The operations are described below:

"../" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).
"./" : Remain in the same folder.
"x/" : Move to the child folder named x (This folder is guaranteed to always exist).
You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.

The file system starts in the main folder, then the operations in logs are performed.

Return the minimum number of operations needed to go back to the main folder after the change folder operations.

#### Solution:

    class Solution {
    public:
    int minOperations(vector<string>& logs) {

        int res = 0;

        for (const string& log : logs) {

            if (log == "../") {

                if (res > 0) {
                    res--;
                }

            } else if (log != "./") {
                res++;
            }
        }

        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 14.11 mb, beating 17.15% of leetcode users solutions using C++.

#### Concepts Applied:

Counter, for loop, if statement, and else-if statement.

### Solution July 11, 2024 (C++, leetcode) 1190. Reverse Substrings Between Each Pair of Parentheses (Medium)
In .LeetcodeDailySolution folder as July11,2024.cpp

#### Prompt:

You are given a string s that consists of lower case English letters and brackets.

Reverse the strings in each pair of matching parentheses, starting from the innermost one.

Your result should not contain any brackets.

#### Solution:

    class Solution {
    public:

    int i = 0;

    string reverseParentheses(string s) {

        return helper(s);
    }

    string helper(string& s) {

        string result;

        while (i < s.length()) {

            if (s[i] == ')') {

                i++;

                reverse(result.begin(), result.end());

                return result;

            } else if (s[i] == '(') {

                i++;
                string st = helper(s);
                result += st;

            } else {

                result += s[i];
                i++;

            }
        }

        return result;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.43 mb, beating 21.06% of leetcode users solutions using C++.

#### Concepts Applied:

Counter, strings, reverse function, while loop, if statement, else-if statement, and else statement.

### Solution July 12, 2024 (C++, leetcode) 1717. Maximum Score From Removing Substrings (Medium)
In .LeetcodeDailySolution folder as July12,2024.cpp 

#### Prompt:

You are given a string s and two integers x and y. You can perform two types of operations any number of times.

Remove substring "ab" and gain x points.
For example, when removing "ab" from "cabxbae" it becomes "cxbae".
Remove substring "ba" and gain y points.
For example, when removing "ba" from "cabxbae" it becomes "cabxe".
Return the maximum points you can gain after applying the above operations on s.

#### Solution:

    class Solution {
    public:
    int maximumGain(string s, int x, int y) {

        int aCount = 0;
        int bCount = 0;
        int lesser = min(x, y);
        int result = 0;

        for (char c : s) {

            if (c > 'b') {

                result += min(aCount, bCount) * lesser;
                aCount = 0;
                bCount = 0;

            } else if (c == 'a') {
                
                if (x < y && bCount > 0) {

                    bCount--;
                    result += y;

                } else {

                    aCount++;

                }
            } else {

                if (x > y && aCount > 0) {

                    aCount--;
                    result += x;
                    
                } else {

                    bCount++;

                }
            }
        }

        result += min(aCount, bCount) * lesser;
        
        return result;
      }
    };

Runtime: 46 ms, beating 99.21% of leetcode users solutions using C++.
Memory: 18.04 mb, beating 81.35% of leetcode users solutions using C++.

#### Concepts Applied:

String, counters, for loop, if statements, else-if statement, else statements, and min function.

### Solution July 13, 2024 (C++, leetcode) 2751. Robot Collisions (Hard)
In .LeetcodeDailySolution folder as July13,2024.cpp

#### Prompt:

There are n 1-indexed robots, each having a position on a line, health, and movement direction.

You are given 0-indexed integer arrays positions, healths, and a string directions (directions[i] is either 'L' for left or 'R' for right). All integers in positions are unique.

All robots start moving on the line simultaneously at the same speed in their given directions. If two robots ever share the same position while moving, they will collide.

If two robots collide, the robot with lower health is removed from the line, and the health of the other robot decreases by one. The surviving robot continues in the same direction it was going. If both robots have the same health, they are both removed from the line.

Your task is to determine the health of the robots that survive the collisions, in the same order that the robots were given, i.e. final heath of robot 1 (if survived), final health of robot 2 (if survived), and so on. If there are no survivors, return an empty array.

Return an array containing the health of the remaining robots (in the order they were given in the input), after no further collisions can occur.

Note: The positions may be unsorted.

#### Solution:

    class Solution {
    public:
    vector<int> survivedRobotsHealths(vector<int>& positions,
                                      vector<int>& healths, string direction) {

        vector<pair<int, int>> v;
        vector<int> ans;

        int np = positions.size();

        for (int i = 0; i < positions.size(); i++) {

            v.push_back(make_pair(positions[i], i));
        }

        sort(v.begin(), v.end());

        stack<int> st;

        st.push(v[0].second);

        for (int k = 1; k < v.size(); k++) {

            int i = v[k].second;

            if (!st.empty()) {

                int temp = st.top();

                if (direction[i] == 'L' && direction[temp] == 'R') {

                    if (healths[i] == healths[temp]) {

                        st.pop();

                    } else if (healths[i] > healths[temp]) {

                        healths[i]--;
                        st.pop();
                        k--;

                    } else if (healths[i] < healths[temp]) {

                        healths[temp]--;
                    }

                } else {

                    st.push(i);
                }
            } else {

                st.push(i);
            }
        }

        while (!st.empty()) {

            ans.push_back(st.top());
            st.pop();
        }

        sort(ans.begin(), ans.end());

        for (int i = 0; i < ans.size(); i++) {

            ans[i] = healths[ans[i]];
        }

        return ans;
      }
    };

Runtime: 199 ms, beating 81.48% of leetcode users solutions using C++.
Memory: 204.74 mb, beating 65.56% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, pair, for loops, stack, indexing, if statements, else-if statements, else statements, and while loop.

### Solution July 14, 2024 (C++, leetcode) 726. Number of Atoms (Hard)
In .LeetcodeDailySolution folder as July14,2024.cpp

#### Prompt:

Given a string formula representing a chemical formula, return the count of each atom.

The atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.

One or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.

For example, "H2O" and "H2O2" are possible, but "H1O2" is impossible.
Two formulas are concatenated together to produce another formula.

For example, "H2O2He3Mg4" is also a formula.
A formula placed in parentheses, and a count (optionally added) is also a formula.

For example, "(H2O2)" and "(H2O2)3" are formulas.
Return the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.

The test cases are generated so that all the values in the output fit in a 32-bit integer.

#### Solution:

    class Solution {
    public:
    string countOfAtoms(string formula) {

        stack<unordered_map<string, int>> stk;
        
        stk.push({}); 
        
        int i = 0, n = formula.length();
        
        while (i < n) {

            if (formula[i] == '(') {

                stk.push({});
                i++;

            } else if (formula[i] == ')') {

                unordered_map<string, int> top = stk.top();

                stk.pop();

                i++;

                int start = i;

                while (i < n && isdigit(formula[i])) {

                    i++;

                }

                int multiplier = start < i ? stoi(formula.substr(start, i - start)) : 1;

                for (auto& kv : top) {

                    stk.top()[kv.first] += kv.second * multiplier;

                }

            } else {

                int start = i++;

                while (i < n && islower(formula[i])) {

                    i++;

                }

                string element = formula.substr(start, i - start);
                start = i;

                while (i < n && isdigit(formula[i])) {

                    i++;

                }

                int count = start < i ? stoi(formula.substr(start, i - start)) : 1;

                stk.top()[element] += count;
            }
        }

        unordered_map<string, int> result = stk.top();
        vector<string> elements;

        for (auto& kv : result) {

            elements.push_back(kv.first);

        }

        sort(elements.begin(), elements.end());
        
        string res;

        for (const auto& element : elements) {

            res += element;

            if (result[element] > 1) {

                res += to_string(result[element]);

            }
        }
        
        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.32 mb, beating 16.81% of leetcode users solutions using C++.

#### Concepts Applied:

String, stack, iteration, while loops, if statements, else-if statement, else statement, for loops, and sorting.

### Solution July 15, 2024 (C++, leetcode) 2196. Create Binary Tree From Descriptions (Medium)
In .LeetcodeDailySolution folder as July15,2024.cpp

#### Prompt:

You are given a 2D integer array descriptions where descriptions[i] = [parenti, childi, isLefti] indicates that parenti is the parent of childi in a binary tree of unique values. Furthermore,

If isLefti == 1, then childi is the left child of parenti.
If isLefti == 0, then childi is the right child of parenti.
Construct the binary tree described by descriptions and return its root.

The test cases will be generated such that the binary tree is valid.


#### Solution:

    class Solution {
    public:
    static TreeNode* createBinaryTree(vector<vector<int>>& descriptions) {

        int root = -1, n = descriptions.size();

        unordered_map<int, int> parent;
        unordered_map<int, TreeNode*> node;
        
        parent.reserve(n);
        node.reserve(n);

        for (auto& d : descriptions) {

            int x = d[0], y = d[1], l = d[2];

            if (node.count(x) == 0) {

                node[x] = new TreeNode(x);

                if (parent.count(x) == 0)

                    root = x;

            }

            if (node.count(y) == 0) {

                node[y] = new TreeNode(y);
            }

            parent[y] = x;

            if (l)

                node[x]->left = node[y];

            else

                node[x]->right = node[y];
        }

        while (parent.count(root))

            root = parent[root];

        return node[root];
      }
    };

Runtime: 658 ms, beating 84.28% of leetcode users solutions using C++.
Memory: 268.64 mb, beating 88.86% of leetcode users solutions using C++.

#### Concepts Applied:

Hash map, arrays, for loop, if statements, else statement, and while loop.

### Solution July 16, 2024 (C++, leetcode) 2096. Step-By-Step Directions From a Binary Tree Node to Another (Medium)
In .LeetcodeDailySolution folder as July16,2024.cpp

#### Prompt:

You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.

Find the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:

'L' means to go from a node to its left child node.
'R' means to go from a node to its right child node.
'U' means to go from a node to its parent node.
Return the step-by-step directions of the shortest path from node s to node t.

#### Solution:

    class Solution {
    bool path(TreeNode* root, int v, string& p) {

        if (root->val == v)
            return true;

        if (root->left && path(root->left, v, p))
            p.push_back('L');

        else if (root->right && path(root->right, v, p))
            p.push_back('R');

        return !p.empty();
    }

    public:
    string getDirections(TreeNode* root, int startValue, int destValue) {

        string s, d;

        path(root, startValue, s);
        path(root, destValue, d);

        while (!s.empty() && !d.empty() && s.back() == d.back()) {

            s.pop_back();
            d.pop_back();
        }

        return string(s.size(), 'U') + string(rbegin(d), rend(d));
      }
    };

Runtime: 146 ms, beating 79.69% of leetcode users solutions using C++.
Memory: 116.16 mb, beating 91.15% of leetcode users solutions using C++.

#### Concepts Applied:

String, binary tree, if statements, else if statement, and while loop.

### Solution July 17, 2024 (C++, leetcode) 1110. Delete Nodes And Return Forest (Medium)
In .LeetcodeDailySolution folder as July17,2024.cpp

#### Prompt:

Given the root of a binary tree, each node in the tree has a distinct value.

After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).

Return the roots of the trees in the remaining forest. You may return the result in any order.

#### Solution:

    class Solution {
    private:
    bool set[1001] = {};

    void dfs(TreeNode*& root, bool flag, vector<TreeNode*>& res) {

        if (root == nullptr)
            return;

        dfs(root->left, set[root->val], res);
        dfs(root->right, set[root->val], res);

        if (!set[root->val] && flag)
            res.push_back(root);

        if (set[root->val])
            root = nullptr;
    }

    public:
    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {

        vector<TreeNode*> res;

        for (int num : to_delete)
            set[num] = true;

        dfs(root, true, res);

        return res;
      }
    };

Runtime: 16 ms, beating 56.71% of leetcode users solutions using C++.
Memory: 27.04 mb, beating 26.39% of leetcode users solutions using C++.

#### Concepts Applied:

Set, recursion, depth-first search, if statements, and for loop.

### Solution July 18, 2024 (C++, leetcode) 1530. Number of Good Leaf Nodes Pairs (Medium)
In .LeetcodeDailySolution folder as July18,2024.cpp

#### Prompt:

You are given the root of a binary tree and an integer distance. A pair of two different leaf nodes of a binary tree is said to be good if the length of the shortest path between them is less than or equal to distance.

Return the number of good leaf node pairs in the tree.

#### Solution:

    class Solution {
    public:
    vector<int> recur(TreeNode* root, int distance, int& cnt) {

        if (!root)
            return {0};

        if (!root->left && !root->right)
            return {1};

        vector<int> left = recur(root->left, distance, cnt);
        vector<int> right = recur(root->right, distance, cnt);

        for (int x : left) {
            for (int y : right) {
                if (x > 0 && y > 0) {
                    if (x + y <= distance)
                        cnt++;
                }
            }
        }

        vector<int> ans;
        for (int x : left) {
            if (x > 0 && x < distance) {
                ans.push_back(x + 1);
            }
        }

        for (int x : right) {
            if (x > 0 && x < distance) {
                ans.push_back(x + 1);
            }
        }

        return ans;
    }

    int countPairs(TreeNode* root, int distance) {

        int cnt = 0;
        recur(root, distance, cnt);

        return cnt;
      }
    };

Runtime: 44 ms, 71.63% of leetcode users solutions using C++.
Memory: 34.68 mb, beating 53.25% of leetcode users solutions using C++.

#### Concepts Applied:

Iteration, arrays, for loops, if statements, recursion, and depth-first search.

### Solution July 19, 2024 (C++, leetcode) 1380. Lucky Numbers in a Matrix (Easy)
In .LeetcodeDailySolution folder as July19,2024.cpp

#### Prompt:

Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.

A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.

#### Solution:

    class Solution {
    public:
    vector<int> luckyNumbers(vector<vector<int>>& matrix) {

        if (matrix.empty() || matrix[0].empty())
            return {};

        int m = matrix.size(), n = matrix[0].size();

        vector<int> rowMin(m, INT_MAX);
        vector<int> colMax(n, INT_MIN);

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                rowMin[i] = min(rowMin[i], matrix[i][j]);
                colMax[j] = max(colMax[j], matrix[i][j]);
            }
        }

        vector<int> result;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == rowMin[i] && matrix[i][j] == colMax[j]) {
                    result.push_back(matrix[i][j]);
                }
            }
        }

        return result;
      }
    };

Runtime: 16 ms, beating 56.54% of leetcode users solutions using C++.
Memory: 14.58 mb, beating 12.55% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, arrays, for loops, and if statements.

### Solution July 20, 2024 (C++, leetcode) 1605. Find Valid Matrix Given Row and Column Sums (Medium)
In .LeetcodeDailySolution folder as July20,2024.cpp

#### Prompt:

You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.

Find any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.

Return a 2D array representing any matrix that fulfills the requirements. It's guaranteed that at least one matrix that fulfills the requirements exists.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> restoreMatrix(vector<int>& rowSum, vector<int>& colSum) {

        int numRows = rowSum.size();
        int numCols = colSum.size();

        vector<vector<int>> result(numRows, vector<int>(numCols, 0));

        int i = 0, j = 0;

        while (i < numRows && j < numCols) {

            int val = min(rowSum[i], colSum[j]);
            result[i][j] = val;
            rowSum[i] -= val;
            colSum[j] -= val;

            if (rowSum[i] == 0) {

                i++;
            }

            if (colSum[j] == 0) {

                j++;
            }
        }

        return result;
      }
    };

Runtime: 28 ms, beating 93.45% of leetcode users solutions using C++.
Memory: 36.17 mb, beating 12.19% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, arrays, iteration, while loop, and if statements.

### Solution July 22, 2024 (C++, leetcode) 2418. Sort the People (Easy)
In .LeetcodeDailySolution folder as July22,2024.cpp

#### Prompt:

You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.

For each index i, names[i] and heights[i] denote the name and height of the ith person.

Return names sorted in descending order by the people's heights.

#### Solution:

    class Solution {
    public:
    static vector<string> sortPeople(vector<string>& names,
                                     vector<int>& heights) {
  
        const int n = names.size();

        for (int i = 0; i < n; i++)
            heights[i] = (heights[i] << 10) + i;

        sort(heights.begin(), heights.end(), greater<>());

        vector<string> ans(n);

        for (int i = 0; i < n; i++)
            ans[i] = names[heights[i] & 1023];
            
        return ans;
      }
    };

Runtime: 19 ms, beating 95.15% of leetcode users solutions using C++.
Memory: 22.50 mb, beating 87.90% of leetcode users solutions using C++.

#### Concepts Applied:

String, arrays, for loop, and sorting.

### Solution July 25, 2024 (C++, leetcode) 912. Sort an Array (Medium)
In .LeetcodeDailySolution folder as July25,2024.cpp

#### Prompt:

Given an array of integers nums, sort the array in ascending order and return it.

You must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.

#### Solution:

    class Solution {
    public:
    vector<int> sortArray(vector<int>& nums) {

        vector<int> counting(2 * 50000 + 1, 0);

        for (int num : nums) {
            counting[num + 50000]++;
        }

        int write_ind = 0;

        for (int number_ind = 0; number_ind < counting.size(); ++number_ind) {

            int freq = counting[number_ind];

            while (freq != 0) {
                nums[write_ind] = number_ind - 50000;
                write_ind++;
                freq--;
            }
        }

        return nums;
      }
    };

Runtime: 84 ms, beating 90.23% of leetcode users solutions using C++.
Memory: 78.77 mb, beating 49.24% of leetcode users solutions using C++.

#### Concepts Applied:
 
Counting sort, arrays, for loops, and while loop.

### Solution July 26, 2024 (C++, leetcode) 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance (Medium)
In .LeetcodeDailySolution folder as July26,2024.cpp

#### Prompt:

There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.

Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.

Notice that the distance of a path connecting cities i and j is equal to the sum of the edges' weights along that path.

#### Solution:

    class Solution {
    public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {

        vector<vector<int>> dist(n, vector<int>(n, numeric_limits<int>::max()));
        
        for (int i = 0; i < n; ++i) {
            dist[i][i] = 0;
        }
        
        for (const auto& edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            dist[u][v] = w;
            dist[v][u] = w;
        }
        
        for (int k = 0; k < n; ++k) {
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (dist[i][k] != numeric_limits<int>::max() && dist[k][j] != numeric_limits<int>::max()) {
                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }
        }

        int minReachableCities = numeric_limits<int>::max();
        int bestCity = -1;
        
        for (int i = 0; i < n; ++i) {

            int reachableCities = 0;
            
            for (int j = 0; j < n; ++j) {
                if (dist[i][j] <= distanceThreshold) {
                    reachableCities++;
                }
            }
            
            if (reachableCities <= minReachableCities) {
                minReachableCities = reachableCities;
                bestCity = i;
            }
        }
        
        return bestCity;
      }
    };

Runtime: 26 ms, beating 61.72% of leetcode users solutions using C++.
Memory: 15.55 mb, beating 75.72% of leetcode users solutions using C++.

#### Concepts Applied:

Shortest path, arrays, max, for loops, and if statements.

### Solution July 27, 2024 (C++, leetcode) 2976. Minimum Cost to Convert String I (Medium)
In .LeetcodeDailySolution folder as July27,2024.cpp

#### Prompt:

You are given two 0-indexed strings source and target, both of length n and consisting of lowercase English letters. You are also given two 0-indexed character arrays original and changed, and an integer array cost, where cost[i] represents the cost of changing the character original[i] to the character changed[i].

You start with the string source. In one operation, you can pick a character x from the string and change it to the character y at a cost of z if there exists any index j such that cost[j] == z, original[j] == x, and changed[j] == y.

Return the minimum cost to convert the string source to the string target using any number of operations. If it is impossible to convert source to target, return -1.

Note that there may exist indices i, j such that original[j] == original[i] and changed[j] == changed[i].

#### Solution:

    class Solution {
    public:
    long long minimumCost(string source, string target, vector<char>& original,
                          vector<char>& changed, vector<int>& cost) {

        const int inf = 1 << 29;

        int g[26][26];

        for (int i = 0; i < 26; ++i) {
            fill(begin(g[i]), end(g[i]), inf);
            g[i][i] = 0;
        }

        for (int i = 0; i < original.size(); ++i) {
            int x = original[i] - 'a';
            int y = changed[i] - 'a';
            int z = cost[i];
            g[x][y] = min(g[x][y], z);
        }

        for (int k = 0; k < 26; ++k) {
            for (int i = 0; i < 26; ++i) {
                for (int j = 0; j < 26; ++j) {
                    g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
                }
            }
        }

        long long ans = 0;
        int n = source.length();

        for (int i = 0; i < n; ++i) {
            int x = source[i] - 'a';
            int y = target[i] - 'a';

            if (x != y) {
                if (g[x][y] >= inf) {
                    return -1;
                }

                ans += g[x][y];
            }
        }

        return ans;
      }
    };

Runtime: 147 ms, beating 89.41% of leetcode users solutions using C++.
Memory: 94.19 mb, beating 91.67% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, arrays, shortest path, for loops, and if statements.

### Solution July 28, 2024 (C++, leetcode) 2045. Second Minimum Time to Reach Destination (Hard)
In .LeetcodeDailySolution folder as July28,2024.cpp

#### Prompt:

A city is represented as a bi-directional connected graph with n vertices where each vertex is labeled from 1 to n (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is time minutes.

Each vertex has a traffic signal which changes its color from green to red and vice versa every change minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green.

The second minimum value is defined as the smallest value strictly larger than the minimum value.

For example the second minimum value of [2, 3, 4] is 3, and the second minimum value of [2, 2, 4] is 4.
Given n, edges, time, and change, return the second minimum time it will take to go from vertex 1 to vertex n.

Notes:

You can go through any vertex any number of times, including 1 and n.
You can assume that when the journey starts, all signals have just turned green.

#### Solution:

    class Solution {
    public:
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {

        unordered_map<int, list<int>> g;

        for (const auto& e : edges) {
            int u = e[0], v = e[1];
            g[u].push_back(v);
            g[v].push_back(u);
        }

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;

        q.push({0, 1}); 

        vector<int> uniqueVisit(n + 1, 0);
        vector<int> dis(n + 1, -1); 

        while (!q.empty()) {

            auto [t, node] = q.top();
            q.pop(); 

            if (dis[node] == t || uniqueVisit[node] >= 2) {
                continue; 
            }

            uniqueVisit[node]++;
            dis[node] = t;

            if (node == n && uniqueVisit[node] == 2) {
                return dis[node];
            }

            if ((t / change) % 2 != 0) {
                t = (t / change + 1) * change;
            }

            for (int nei : g[node]) {
                q.push({t + time, nei});
            }
        }

        return -1;
      }
    };

Runtime: 804 ms, beating 5.83% of leetcode users solutions using C++.
Memory: 242.49 mb, beating 5.83% of leetcode users solutions using C++.

#### Concepts Applied:

Shortest path, unordered map, for loops, priority queue, arrays, while loop, and if statements.

### Solution July 29, 2024 (C++, leetcode) 1395. Count Number of Teams (Medium)
In .LeetcodeDailySolution folder as July29,2024.cpp

#### Prompt:

There are n soldiers standing in a line. Each soldier is assigned a unique rating value.

You have to form a team of 3 soldiers amongst them under the following rules:

Choose 3 soldiers with index (i, j, k) with rating (rating[i], rating[j], rating[k]).
A team is valid if: (rating[i] < rating[j] < rating[k]) or (rating[i] > rating[j] > rating[k]) where (0 <= i < j < k < n).
Return the number of teams you can form given the conditions. (soldiers can be part of multiple teams).

#### Solution:

    class Solution {
    public:
    static int numTeams(vector<int>& rating) {

        const int n = rating.size();

        int cnt = 0;

        for (int i = 1; i < n - 1; i++) {

            int L[2] = {0}, R[2] = {0};

            for (int j = 0; j < i; j++)
                L[rating[j] < rating[i]]++;

            for (int k = i + 1; k < n; k++)
                R[rating[k] < rating[i]]++;

            cnt += L[0] * R[1] + L[1] * R[0];
        }

        return cnt;
      }
    };

Runtime: 29 ms, beating 64.86% of leetcode users solutions using C++.
Memory: 11.61 mb, beating 72.06% of leetcode users solutions using C++.

#### Concepts Applied:

Array, nested for loop, and counting.

### Solution July 30, 2024 (C++, leetcode) 1653. Minimum Deletions to Make String Balanced (Medium)
In .LeetcodeDailySolution folder as July30,2024.cpp

#### Prompt:

You are given a string s consisting only of characters 'a' and 'b'​​​​.

You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i < j and s[i] = 'b' and s[j]= 'a'.

Return the minimum number of deletions needed to make s balanced.

#### Solution:

    class Solution {
    public:
    static int minimumDeletions(string& s) {

        const int n = s.size();

        int cntA = 0, ans = 0;

        for (int i = n - 1; i >= 0; i--) {

            if (s[i] == 'a')
                cntA++;

            else
                ans = min(ans + 1, cntA);
        }

        return ans;
      }
    };

Runtime: 75 ms, beating 79.61% of leetcode users solutions using C++.
Memory: 19.94 mb, beating 98.61% of leetcode users solutions using C++.

#### Concepts Applied:

Iteration, dynamic programming, for loop, if statement, and else statement.

### Solution July 31, 2024 (C++, leetcode) 1105. Filling Bookcase Shelves (Medium)
In .LeetcodeDailySolution folder as July31,2024.cpp

#### Prompt:

You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. You are also given an integer shelfWidth.

We want to place these books in order onto bookcase shelves that have a total width shelfWidth.

We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.

Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.

For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.
Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.

#### Solution:

    class Solution {
    public:
    int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {

        int n = books.size();
        int f[n + 1];

        f[0] = 0;

        for (int i = 1; i <= n; ++i) {

            int w = books[i - 1][0], h = books[i - 1][1];

            f[i] = f[i - 1] + h;

            for (int j = i - 1; j > 0; --j) {

                w += books[j - 1][0];

                if (w > shelfWidth) {
                    break;
                }

                h = max(h, books[j - 1][1]);
                f[i] = min(f[i], f[j - 1] + h);

            }
        }
        
        return f[n];
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 10.80 mb, beating 74.85% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, dynamic programming, for loops, and if statement. 

### Solution Aug 1, 2024 (C++, leetcode) 2678. Number of Senior Citizens (Easy)
In .LeetcodeDailySolution folder as Aug1,2024.cpp

#### Prompt:

You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:

The first ten characters consist of the phone number of passengers.
The next character denotes the gender of the person.
The following two characters are used to indicate the age of the person.
The last two characters determine the seat allotted to that person.
Return the number of passengers who are strictly more than 60 years old.

#### Solution:

    class Solution {
    public:
    int countSeniors(vector<string>& details) {

        int ans = 0;

        for (int i = 0; i < details.size(); i++) {

            int age = (details[i][11] - '0') * 10 + (details[i][12] - '0');

            if (age > 60)
                ans++;
        }
        return ans;
      }
    };

Runtime: 4 ms, beating 82.84% of leetcode users solutions using C++.
Memory: 17.49 mb, beating 33.89% of leetcode users solutions using C++.

#### Concepts Applied:

ASCII, string, for loop, and if statement.

### Solution Aug 2, 2024 (C++, leetcode) 2134. Minimum Swaps to Group All 1's Together II (Medium)
In .LeetcodeDailySolution folder as Aug2,2024.cpp

#### Prompt:

A swap is defined as taking two distinct positions in an array and swapping the values in them.

A circular array is defined as an array where we consider the first element and the last element to be adjacent.

Given a binary circular array nums, return the minimum number of swaps required to group all 1's present in the array together at any location.

#### Solution:

    class Solution {
    public:
    int minSwaps(vector<int>& nums) {

        int k = accumulate(nums.begin(), nums.end(), 0);
        int n = nums.size();
        int cnt = accumulate(nums.begin(), nums.begin() + k, 0);
        int mx = cnt;

        for (int i = k; i < n + k; ++i) {

            cnt += nums[i % n] - nums[(i - k + n) % n];
            mx = max(mx, cnt);

        }
        
        return k - mx;
      }
    };

Runtime: 63 ms, beating 80.27% of leetcode users solutions using C++.
Memory: 83.06 mb, beating 58.03% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, counting, sliding window technique, for loop, and max.

### Solution Aug 3, 2024 (C++, leetcode) 1460. Make Two Arrays Equal by Reversing Subarrays (Easy)
In .LeetcodeDailySolution folder as Aug3,2024.cpp

#### Prompt:

You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty subarray of arr and reverse it. You are allowed to make any number of steps.

Return true if you can make arr equal to target or false otherwise.

#### Solution:

    class Solution {
    public:
    bool canBeEqual(vector<int>& target, vector<int>& arr) {

        sort(target.begin(),target.end());
        sort(arr.begin(),arr.end());
        
        return target == arr;
      }
    };

Runtime: 7 ms, beating 84.56% of leetcode users solutions using C++.
Memory: 17.47 mb, beating 58.54% of leetcode users solutions using C++.

#### Concepts Applied:

Sorting and comparing.

### Solution Aug 4, 2024 (C++, leetcode) 1508. Range of Sorted Subarray Sums (Medium)
In .LeetcodeDailySolution folder as Aug4,2024.cpp

#### Prompt:

You are given the array nums consisting of n positive integers. You computed the sum of all non-empty continuous subarrays from the array and then sorted them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.

Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 109 + 7.

#### Solution:

    class Solution {
    public:
    int rangeSum(vector<int>& nums, int n, int left, int right) {

        const int MOD = 1000000007;

        vector<int> subarraySums;
        
        for (int i = 0; i < n; i++) {

            int sum = 0;

            for (int j = i; j < n; j++) {
                sum += nums[j];
                subarraySums.push_back(sum);
            }
        }
        
        sort(subarraySums.begin(), subarraySums.end());
        
        long long rangeSum = 0;
        
        for (int i = left - 1; i < right; i++) {
            rangeSum = (rangeSum + subarraySums[i]) % MOD;
        }
        
        return static_cast<int>(rangeSum);
      }
    };

Runtime: 89 ms, beating 68.30% of leetcode users solutions using C++.
Memory: 27.35 mb, beating 22.39% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, iteration, subarrays, sorting, and modulus.

### Solution Aug 5, 2024 (C++, leetcode) 2053. Kth Distinct String in an Array (Easy)
In .LeetcodeDailySolution folder as Aug5,2024.cpp

#### Prompt:

A distinct string is a string that is present only once in an array.

Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string "".

Note that the strings are considered in the order in which they appear in the array.

#### Solution:

    class Solution {
    public:
    string kthDistinct(vector<string>& arr, int k) {

        unordered_map<string, int> counter;

        for (auto& v : arr)
            ++counter[v];

        for (auto& v : arr) {
            if (counter[v] == 1) {
                --k;
                if (k == 0)
                    return v;
            }
        }

        return "";
      }
    };

Runtime: 7 ms, beating 98.16% of leetcode users solutions using C++.
Memory: 18.45 mb, beating 63.70% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered map, arrays, hashing, for loops, and if statements.

### Solution Aug 6, 2024 (C++, leetcode) 3016. Minimum Number of Pushes to Type Word II (Medium)
In .LeetcodeDailySolution folder as Aug6,2024.cpp

#### Prompt:

You are given a string word containing lowercase English letters.

Telephone keypads have keys mapped with distinct collections of lowercase English letters, which can be used to form words by pushing them. For example, the key 2 is mapped with ["a","b","c"], we need to push the key one time to type "a", two times to type "b", and three times to type "c" .

It is allowed to remap the keys numbered 2 to 9 to distinct collections of letters. The keys can be remapped to any amount of letters, but each letter must be mapped to exactly one key. You need to find the minimum number of times the keys will be pushed to type the string word.

Return the minimum number of pushes needed to type word after remapping the keys.

An example mapping of letters to keys on a telephone keypad is given below. Note that 1, *, #, and 0 do not map to any letters.

#### Solution:

    class Solution {
    public:
    int minimumPushes(string word) {

        vector<int> freq(26, 0);

        for (char c : word) {
            freq[c - 'a']++;
        }
        
        sort(freq.begin(), freq.end());
        
        int totalPushes = 0;
        int multiplier = 1;
        
        for (int i = 25; i >= 0; i--) {
            
            if (freq[i] == 0) break;
            
            if ((25 - i) % 8 == 0 && i != 25) {
                multiplier++;
            }
            
            totalPushes += freq[i] * multiplier;
        }
        
        return totalPushes;
      }
    };

Runtime: 69 ms, beating 73.41% of leetcode users solutions using C++.
Memory: 25.07 mb, beating 72.89% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, frequency counting, sorting, for loops, and if statements.

### Solution Aug 7, 2024 (C++, leetcode) 273. Integer to English Words (Hard)
In .LeetcodeDailySolution folder as Aug7,2024.cpp

#### Prompt:

Convert a non-negative integer num to its English words representation.

#### Solution:

    class Solution {
    public:
    vector<pair<int, string>> mp = {

        {1000000000, "Billion"},
        {1000000, "Million"},
        {1000, "Thousand"},
        {100, "Hundred"},
        {90, "Ninety"},
        {80, "Eighty"},
        {70, "Seventy"},
        {60, "Sixty"},
        {50, "Fifty"},
        {40, "Forty"},
        {30, "Thirty"},
        {20, "Twenty"},
        {19, "Nineteen"},
        {18, "Eighteen"},
        {17, "Seventeen"},
        {16, "Sixteen"},
        {15, "Fifteen"},
        {14, "Fourteen"},
        {13, "Thirteen"},
        {12, "Twelve"},
        {11, "Eleven"},
        {10, "Ten"},
        {9, "Nine"},
        {8, "Eight"},
        {7, "Seven"},
        {6, "Six"},
        {5, "Five"},
        {4, "Four"},
        {3, "Three"},
        {2, "Two"},
        {1, "One"}
    };

    string numberToWords(int num) {

        if (num == 0) {
            return "Zero";
        }

        for (auto it : mp) {
            if (num >= it.first) {
                string a = "";
                if (num >= 100) {
                    a = numberToWords(num / it.first) + " ";
                }

                string b = it.second;
                string c = "";

                if (num % it.first != 0) {
                    c = " " + numberToWords(num % it.first);
                }

                return a + b + c;
            }
        }

        return "";
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.42 mb, beating 19.58% of leetcode users solutions using C++.

#### Concepts Applied:

Map, strings, if statements, for loop, and math.

### Solution Aug 8, 2024 (C++, leetcode) 885. Spiral Matrix III (Medium)
In .LeetcodeDailySolution folder as Aug8,2024.cpp

#### Prompt:

You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.

You will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid.

Return an array of coordinates representing the positions of the grid in the order you visited them.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {

        vector<vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; 
        vector<vector<int>> result = {{rStart, cStart}};

        int steps = 0, d = 0;
        
        while (result.size() < rows * cols) {

            if (d == 0 || d == 2) steps++;
            
            for (int i = 0; i < steps; i++) {
                
                rStart += directions[d][0];
                cStart += directions[d][1];
                
                if (rStart >= 0 && rStart < rows && cStart >= 0 && cStart < cols) {
                    result.push_back({rStart, cStart});
                }
                
                if (result.size() == rows * cols) return result;
            }
            
            d = (d + 1) % 4;
        }
        
        return result;
      }
    };

Runtime: 3 ms, beating 98.91% of leetcode users solutions using C++.
Memory: 14.03 mb, beating 9.14% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, grid, while loop, if statements, and for loop.

### Solution Aug 9, 2024 (C++, leeetcode) 840. Magic Squares In Grid (Medium)
In .LeetcodeDailySolution folder as Aug9,2024.cpp

#### Prompt:

A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.

Given a row x col grid of integers, how many 3 x 3 contiguous magic square subgrids are there?

Note: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.

#### Solution:

    class Solution {
    public:
    static bool isMagic(int i, int j, int a, int b, int c, int d,
                        vector<vector<int>>& grid) {

        return (a + grid[i - 1][j] + b == 15) &&
               (a + grid[i][j - 1] + c == 15) &&
               (b + grid[i][j + 1] + d == 15) && (c + grid[i + 1][j] + d == 15);
    }

    static int numMagicSquaresInside(vector<vector<int>>& grid) {
        const int r = grid.size(), c = grid[0].size();

        if (r < 3 || c < 3)
            return 0;

        int cnt = 0;

        for (int i = 1; i < r - 1; i++) {
            for (int j = 1; j < c - 1; j++) {
                if (grid[i][j] != 5)
                    continue;

                int a = grid[i - 1][j - 1], b = grid[i - 1][j + 1],
                    c = grid[i + 1][j - 1], d = grid[i + 1][j + 1];
                bitset<16> once =
                    (1 << a) + (1 << b) + (1 << c) + (1 << d) + (1 << 5);

                if (once.count() == 5 && (a & 1) == 0 && a + d == 10 &&
                    (b & 1) == 0 && b + c == 10)
                    cnt += isMagic(i, j, a, b, c, d, grid);
            }
        }
        
        return cnt;
      }
    };

Runtime: 2 ms, beating 65.89% of leetcode users solutions using C++.
Memory: 10.23 mb, beating 99.25% of leetcode users solutions using C++.

#### Concepts Applied:

Math, magic square, arrays, matrix, grid, if statements, for loops, and bitset.

### Solution Aug 10, 2024 (C++, leetcode) 959. Regions Cut By Slashes (Medium)
In .LeetcodeDailySolution folder as Aug10,2024.cpp

#### Prompt:

An n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a '/', '\', or blank space ' '. These characters divide the square into contiguous regions.

Given the grid grid represented as a string array, return the number of regions.

Note that backslash characters are escaped, so a '\' is represented as '\\'.

#### Solution:

    class Solution {
    public:
    void dfs(int i, int j, vector<vector<int>>& mat, vector<vector<int>>& vis) {

        vis[i][j] = 1;
        int n = mat.size(), m = mat[0].size();
        int delr[] = {-1, 0, 1, 0};
        int delc[] = {0, 1, 0, -1};

        for (int k = 0; k < 4; k++) {

            int nrow = i + delr[k], ncol = j + delc[k];

            if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= m ||
                mat[nrow][ncol] != 0 || vis[nrow][ncol])
                continue;

            dfs(nrow, ncol, mat, vis);
        }
    }
    int regionsBySlashes(vector<string>& grid) {

        int n = grid.size();
        vector<vector<int>> mat(n * 3, vector<int>(n * 3, 0));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '/') {
                    mat[i * 3][j * 3 + 2] = 1;
                    mat[i * 3 + 1][j * 3 + 1] = 1;
                    mat[i * 3 + 2][j * 3] = 1;
                } else if (grid[i][j] == '\\') {
                    mat[i * 3][j * 3] = 1;
                    mat[i * 3 + 1][j * 3 + 1] = 1;
                    mat[i * 3 + 2][j * 3 + 2] = 1;
                }
            }
        } 
        int count = 0;
        vector<vector<int>> vis(n * 3, vector<int>(n * 3, 0));

        for (int i = 0; i < n * 3; i++) {
            for (int j = 0; j < n * 3; j++) {
                if (mat[i][j] == 0 && !vis[i][j]) {
                    count++;
                    dfs(i, j, mat, vis);
                }
            }
        }
        
        return count;
      }
    };

Runtime: 15 ms, beating 32.82% of leetcode users solutions using C++.
Memory: 15.65 mb, beating 26.69% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, matrix, grid, strings, arrays, for loops, and if statements.

### Solution Aug 11, 2024 (C++, leetcode) 1568. Minimum Number of Days to Disconnect Island (Hard)
In .LeetcodeDailySolution folder as Aug11,2024.cpp

#### Prompt:

You are given an m x n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's.

The grid is said to be connected if we have exactly one island, otherwise is said disconnected.

In one day, we are allowed to change any single land cell (1) into a water cell (0).

Return the minimum number of days to disconnect the grid.

#### Solution:

    class Solution {
    public:
    void dfs(int i, int j, vector<vector<int>>& visited, int m, int n,
             vector<vector<int>>& grid) {

        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] == 1 ||
            grid[i][j] == 0) {

            return;
        }

        visited[i][j] = 1;

        dfs(i + 1, j, visited, m, n, grid);
        dfs(i - 1, j, visited, m, n, grid);
        dfs(i, j + 1, visited, m, n, grid);
        dfs(i, j - 1, visited, m, n, grid);
    }

    int islandcount(vector<vector<int>>& grid) {

        int m = grid.size();
        int n = grid[0].size();

        vector<vector<int>> visited(m, vector<int>(n, 0));
        int islands = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1 && visited[i][j] == 0) {
                    dfs(i, j, visited, m, n, grid);
                    islands++;
                }
            }
        }

        return islands;
    }

    int minDays(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        int islands = islandcount(grid);

        if (islands > 1 || islands == 0) {
            return 0;
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    grid[i][j] = 0;
                    islands = islandcount(grid);

                    if (islands > 1 || islands == 0) {
                        return 1;
                    }

                    grid[i][j] = 1;
                }
            }
        }

        return 2;
      }
    };

Runtime: 63 ms, beating 67.86% of leetcode users solutions using C++.
Memory: 25.50 mb, beating 43.96% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, matrix, binary grid, if statements, and for loops.

### Solution Aug 12, 2024 (C++, leetcode) 703. Kth Largest Element in a Stream (Easy)
In .LeetcodeDailySolution folder as Aug12,2024.cpp

#### Prompt:

Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Implement KthLargest class:

KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.
int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.

#### Solution:

    class KthLargest {
    public:

    int k;
    priority_queue<int, vector<int>, greater<int>> pq;

    KthLargest(int k, vector<int>& nums) : k(k) {

        for (int x : nums) {
            pq.push(x);

            if (pq.size() > k)
                pq.pop();
        }
    }
    int add(int val) {
        pq.push(val);

        if (pq.size() > k)
            pq.pop();

        return pq.top();
      }
    };

Runtime: 25 ms, beating 67.33% of leetcode users solutions using C++.
Memory: 24.74 mb, beating 40.40% of leetcode users solutions using C++.

#### Concepts Applied:

Priority queue, arrays, for loop, and if statements.

### Solution Aug 13, 2024 (C++, leetcode) 40. Combination Sum II (Medium)
In .LeetcodeDailySolution folder as Aug13,2024.cpp

#### Prompt:

Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.

Each number in candidates may only be used once in the combination.

Note: The solution set must not contain duplicate combinations.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {

        sort(candidates.begin(), candidates.end());

        vector<vector<int>> ans;
        vector<int> ds;

        findCombination(0, target, candidates, ans, ds);

        return ans;
    }
    void findCombination(int ind, int target, vector<int>& arr,
                         vector<vector<int>>& ans, vector<int>& ds) {

        if (target == 0) {
            ans.push_back(ds);
            return;
        }

        for (int i = ind; i < arr.size(); i++) {
            if (i > ind && arr[i] == arr[i - 1])
                continue;
            if (arr[i] > target)
                break;
                
            ds.push_back(arr[i]);
            findCombination(i + 1, target - arr[i], arr, ans, ds);
            ds.pop_back();
        }
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 12.80 mb, beating 66.93% of leetcode users solutions using C++.

#### Concepts Applied:

Backtracking, sorting, arrays, combinations, for loop, and if statements.

### Solution Aug 14, 2024 (C++, leetcode) 719. Find K-th Smallest Pair Distance (Hard)
In .LeetcodeDailySolution folder as Aug14,2024.cpp

#### Prompt:

The distance of a pair of integers a and b is defined as the absolute difference between a and b.

Given an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.

#### Solution:

    class Solution {
    public:
    int smallestDistancePair(vector<int>& nums, int k) {

        sort(nums.begin(), nums.end());
        
        int n = nums.size();
        int low = 0, high = nums[n - 1] - nums[0];

        auto count_pairs = [&](int max_distance) {

            int count = 0, j = 0;

            for (int i = 0; i < n; ++i) {
                
                while (j < n && nums[j] - nums[i] <= max_distance)
                    ++j;

                count += j - i - 1;
            }

            return count;
        };

        while (low < high) {

            int mid = low + (high - low) / 2;

            if (count_pairs(mid) < k)
                low = mid + 1;
            else
                high = mid;
        }

        return low;
      }
    };

Runtime: 7 ms, beating 83.74% of leetcode users solutions using C++.
Memory: 12.94 mb, beating 26.29% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search, two-pointers, arrays, sorting, for loop, while loops, if statement, and else statement.

### Solution Aug 15, 2024 (C++, leetcode) 860. Lemonade Change (Easy)
In .LeetcodeDailySolution folder as Aug15,2024.cpp

#### Prompt:

At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.

Note that you do not have any change in hand at first.

Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.

#### Solution:

    class Solution {
    public:
    bool lemonadeChange(vector<int>& bills) {

        int c5 = 0, c10 = 0;

        for (auto bill : bills) {

            if (bill == 5)
                c5++;

            else if (bill == 10 && c5 >= 1) {
                c10++;
                c5--;

            } else if (bill == 20 && c10 >= 1 && c5 >= 1) {
                c10--;
                c5--;

            } else if (bill == 20 && c5 >= 3) {
                c5 -= 3;

            } else

                return false;
        }
        
        return true;
      }
    };

Runtime: 68 ms, beating 74.03% of leetcode users solutions using C++.
Memory: 85.91 mb, beating 50.86% of leetcode users solutions using C++.

#### Concepts Applied:

Array, for loop, simple if-else-else if statement.

### Solution Aug 16, 2024 (C++, leetcode) 624. Maximum Distance in Arrays (Medium)
In .LeetcodeDailySolution folder as Aug16,2024.cpp

#### Prompt:

You are given m arrays, where each array is sorted in ascending order.

You can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a - b|.

Return the maximum distance.

#### Solution:

    class Solution {
    public:
    static int maxDistance(vector<vector<int>>& arrays) {

        int xMin = 1e5, xMax = -1e5;
        int diff = 0;
        int m = arrays.size();

        for (auto& arr : arrays) {

            int a0 = arr[0], aN = arr.back();
            
            diff = max({diff, aN - xMin, xMax - a0});
            xMin = min(a0, xMin);
            xMax = max(aN, xMax);
        }
        
        return diff;
      }
    };

Runtime: 222 ms, beating 81.13% of leetcode users solutions using C++.
Memory: 107.88 mb, beating 57.08% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, greedy, 1 pass, for loop, max, and min.

### Solution Aug 17, 2024 (C++, leetcode) 1937. Maximum Number of Points with Cost (Medium)
In .LeetcodeDailySolution folder as Aug17,2024.cpp

#### Prompt:

You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix.

To gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score.

However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows r and r + 1 (where 0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score.

Return the maximum number of points you can achieve.

abs(x) is defined as:

x for x >= 0.
-x for x < 0.

#### Solution:

    class Solution {
    public:
    long long maxPoints(vector<vector<int>>& points) {

        int row = points.size();
        int col = points[0].size();
        vector<long long> dp(col, 0);
        
        for(int i = 0; i < col; i++) {
            dp[i] = points[0][i];
        }
        
        for(int r = 1; r < row; r++) {

            vector<long long> leftMax(col, 0), rightMax(col, 0);
            vector<long long> newDp(col, 0);
            
            leftMax[0] = dp[0];

            for(int i = 1; i < col; i++) {
                leftMax[i] = max(leftMax[i-1], dp[i] + i);
            }
            rightMax[col-1] = dp[col-1] - (col-1);

            for(int i = col-2; i >= 0; i--) {
                rightMax[i] = max(rightMax[i+1], dp[i] - i);
            }
            
            for(int i = 0; i < col; i++) {
                newDp[i] = max(leftMax[i] - i, rightMax[i] + i) + points[r][i];
            }
            
            dp = newDp;
        }
        
        return *max_element(dp.begin(), dp.end());
      }
    };

Runtime: 211 ms, beating 40.58% of leetcode users solutions using C++.
Memory: 129.20 mb, beating 30.24% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, dynamic programming, two pass, for loops, and max.

### Solution Aug 18, 2024 (C++, leetcode) 264. Ugly Number II (Medium)
In .LeetcodeDailySolution folder as Aug18,2024.cpp

#### Prompt:

An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.

Given an integer n, return the nth ugly number.

#### Solution:

    class Solution {
    public:
    int nthUglyNumber(int n) {

        vector<int> dp(n);
        dp[0] = 1;

        int p1 = 0;
        int p2 = 0;
        int p3 = 0;

        for (int i = 1; i < n; i++) {

            int twoMul = dp[p1] * 2;
            int threeMul = dp[p2] * 3;
            int fiveMul = dp[p3] * 5;

            dp[i] = min(twoMul, min(threeMul, fiveMul));

            if (dp[i] == twoMul)
                p1++;
            if (dp[i] == threeMul)
                p2++;
            if (dp[i] == fiveMul)
                p3++;
        }

        return dp[n - 1];
      }
    };

Runtime: 6 ms, beating 56.38% of leetcode users solutions using C++.
Memory: 9.72 mb, beating 56.70% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, dynamic programming, for loop, and if statements.

### Solution Aug 19, 2024 (C++, leetcode) 650. 2 Keys Keyboard (Medium)
In .LeetcodeDailySolution folder as Aug19,2024.cpp

#### Prompt:

There is only one character 'A' on the screen of a notepad. You can perform one of two operations on this notepad for each step:

Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).
Paste: You can paste the characters which are copied last time.
Given an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.

#### Solution:

    class Solution {
    public:
    int minSteps(int n) {

        if (n == 1)
            return 0;

        int steps = 0;
        int factor = 2;

        while (n > 1) {
            while (n % factor == 0) {
                steps += factor;
                n /= factor;
            }
            
            factor++;
        }

        return steps;
      }
    };

Runtime: 2 ms, beating 76.41% of leetcode users solutions using C++.
Memory: 7.49 mb, beating 71.95% of leetcode users solutions using C++.

#### Concepts Applied:

Factorization, divison, if statement, and while loops.

### Solution Aug 20, 2024 (C++, leetcode) 1140. Stone Game II (Medium)
In .LeetcodeDailySolution folder as Aug20,2024.cpp

#### Prompt:

Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones. 

Alice and Bob take turns, with Alice starting first.  Initially, M = 1.

On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).

The game continues until all the stones have been taken.

Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.

#### Solution:

    class Solution {
    public:
    int stoneGameII(vector<int>& piles) {

        int n = piles.size();

        vector<vector<int>> dp(n, vector<int>(n + 1, 0));
        vector<int> suffixSum(n, 0);
        
        suffixSum[n - 1] = piles[n - 1];

        for (int i = n - 2; i >= 0; i--) {
            suffixSum[i] = suffixSum[i + 1] + piles[i];
        }

        for (int i = n - 1; i >= 0; i--) {
            for (int m = 1; m <= n; m++) {
                if (i + 2 * m >= n) {
                    dp[i][m] = suffixSum[i];
                } else {
                    for (int x = 1; x <= 2 * m; x++) {
                        dp[i][m] =
                            max(dp[i][m], suffixSum[i] - dp[i + x][max(m, x)]);
                    }
                }
            }
        }

        return dp[0][1];
      }
    };

Runtime: 16 ms, beating 64.93% of leetcode users solutions using C++.
Memory: 12.35 mb, beating 61.31% of leetcode users solutions using C++.

#### Concepts Applied:

Suffix sum, dynamic programming table, arrays, for loops, if statement, and else statement.

### Solution Aug 21, 2024 (C++, leetcode) 664. Strange Printer (Hard)
In .LeetcodeDailySolution folder as Aug21,2024.cpp

#### Prompt:

There is a strange printer with the following two special properties:

The printer can only print a sequence of the same character each time.
At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.
Given a string s, return the minimum number of turns the printer needed to print it.

#### Solution:

    class Solution {
    public:
    int strangePrinter(string s) {

        int n = s.length();
        vector<vector<int>> dp(n, vector<int>(n, -1));
        return Util(0, n - 1, s, dp);
    }
    
    int Util(int i, int j, const string& s, vector<vector<int>>& dp) {

        if (i > j) {
            return 0;
        }

        if (dp[i][j] != -1)
            return dp[i][j];

        char firstLetter = s[i];
        int answer = 1 + Util(i + 1, j, s, dp);

        for (int k = i + 1; k <= j; k++) {
            if (s[k] == firstLetter) {

                int betterAnswer =
                    Util(i, k - 1, s, dp) + Util(k + 1, j, s, dp);

                answer = min(answer, betterAnswer);
            }
        }

        return dp[i][j] = answer;
      }
    };

Runtime: 17 ms, beating 67.58% of leetcode users solutions using C++.
Memory: 11.28 mb, beating 38.69% of leetcode users solutions using C++.

#### Concepts Applied:

Backtracking, arrays, strings, if statements, dynamic programming, and for loop.

### Solution Aug 22, 2024 (C++, leetcode) 476. Number Complement (Easy)
In .LeetcodeDailySolution folder as Aug22,2024.cpp

#### Prompt:

The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.

For example, The integer 5 is "101" in binary and its complement is "010" which is the integer 2.
Given an integer num, return its complement.

#### Solution:

    class Solution {
    public:
    static int findComplement(int num) {

        if (num == 1)
            return 0;

        int ans = 0;

        for (int b = 0; num; b++, num >>= 1) { 
            ans += (1 - (num & 1)) << b;       
        }
        
        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.32 mb, beating 65.77% of leetcode users solutions using C++.

#### Concepts Applied:

If statement, for loop, and bit manipulation.

### Solution Aug 24, 2024 (C++, leetcode) 564. Find the Closest Palindrome (Hard)
In .LeetcodeDailySolution folder as Aug24,2024.cpp

#### Prompt:

Given a string n representing an integer, return the closest integer (not including itself), which is a palindrome. If there is a tie, return the smaller one.

The closest is defined as the absolute difference minimized between two integers.

#### Solution:

    class Solution {
    public:
    string nearestPalindromic(string numberStr) {

        long long number = stoll(numberStr);

        if (number <= 10)
            return to_string(number - 1);
        if (number == 11)
            return "9";

        int length = numberStr.length();
        long long leftHalf = stoll(numberStr.substr(0, (length + 1) / 2));
        vector<long long> palindromeCandidates(5);

        palindromeCandidates[0] =
            generatePalindromeFromLeft(leftHalf - 1, length % 2 == 0);
        palindromeCandidates[1] =
            generatePalindromeFromLeft(leftHalf, length % 2 == 0);
        palindromeCandidates[2] =
            generatePalindromeFromLeft(leftHalf + 1, length % 2 == 0);
        palindromeCandidates[3] = pow(10, length - 1) - 1;
        palindromeCandidates[4] = pow(10, length) + 1;

        long long nearestPalindrome = 0;
        long long minDifference = LLONG_MAX;

        for (long long candidate : palindromeCandidates) {
            if (candidate == number)
                continue;

            long long difference = abs(candidate - number);

            if (difference < minDifference || (difference == minDifference &&
                                               candidate < nearestPalindrome)) {
                minDifference = difference;
                nearestPalindrome = candidate;
            }
        }

        return to_string(nearestPalindrome);
    }

    private:
    long long generatePalindromeFromLeft(long long leftHalf,
                                         bool isEvenLength) {

        long long palindrome = leftHalf;

        if (!isEvenLength)
            leftHalf /= 10;
        while (leftHalf > 0) {
            palindrome = palindrome * 10 + leftHalf % 10;
            leftHalf /= 10;
        }

        return palindrome;
      }
    };

Runtime: 3 ms, beating 46.80% of leetcode users solutions using C++.
Memory: 7.87 mb, beating 96.47% of leetcode users solutions using C++.
 
#### Concepts Applied:

Palindromes, strings, if statements, arrays, for loop, and while loop.

### Solution Aug 26, 2024 (C++, leetcode) 590. N-ary Tree Postorder Traversal (Easy)
In .LeetcodeDailySolution folder as Aug26,2024.cpp

#### Prompt:

Given the root of an n-ary tree, return the postorder traversal of its nodes' values.

Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)

#### Solution:

    class Solution {
    public:
    vector<int> postorder(Node* root) {

        if (!root)
            return {};

        vector<int> res;

        function<void(Node*)> dfs = [&](Node* node) {
            for (Node* child : node->children) {
                dfs(child);
            }

            res.push_back(node->val);
        };

        dfs(root);

        return res;
      }
    };

Runtime: 13 ms, beating 64.20% of leetcode users solutions using C++.
Memory: 15.28 mb, beating 51.23% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, arrays, and for loop.

### Solution Aug 27, 2024 (C++, leetcode) 1. Two Sum (Easy)
In .LeetcodeDailySolution folder as Aug27,2024.cpp

#### Prompt:

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

#### Solution:

    class Solution {
    public:
    vector<int> twoSum(vector<int>& nums, int target) {

        int n = nums.size();

        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if (nums[i] + nums[j] == target) {
                    return {i, j};
                }
            }
        }

        return {};
      }
    };

Runtime: 49 ms, beating 36.90% of leetcode users solutions using C++.
Memory: 13 mb, beating 70.65% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, and if statement.

### Solution Aug 28, 2024 (C++, leetcode) 1905. Count Sub Islands (Medium)
In .LeetcodeDailySolution folder as Aug28,2024.cpp

#### Prompt:

You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.

An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2.

Return the number of islands in grid2 that are considered sub-islands.

#### Solution:

    class Solution {
    public:

    int r, c;
    const int d[5] = {0, 1, 0, -1, 0};

    inline bool outside(int i, int j) {
        return i < 0 || i >= r || j < 0 || j >= c;
    }

    bool dfs(int i, int j, int mark, vector<vector<int>>& grid1,
             vector<vector<int>>& grid2) {

        if (grid1[i][j] != 1)
            return false;

        grid2[i][j] = mark;

        bool isSub = true;

        for (int a = 0; a < 4; a++) {

            int s = i + d[a], t = j + d[a + 1];

            if (outside(s, t) || grid2[s][t] != 1)
                continue;

            if (grid1[s][t] != 1)
                isSub = false;

            if (!dfs(s, t, mark, grid1, grid2))
                isSub = false;
        }

        return isSub;
    }

    int countSubIslands(vector<vector<int>>& grid1,
                        vector<vector<int>>& grid2) {

        r = grid1.size();
        c = grid1[0].size();
        int cnt = 0, mark = 2;

        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                if (grid2[i][j] == 1) {

                    cnt += dfs(i, j, mark++, grid1, grid2);
                }
            }
        }

        return cnt;
      }
    };

Runtime: 212 ms, beating 66.93% of leetcode users solutions using C++.
Memory: 92.80 mb, beating 89.12% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, arrays, depth-first search, if statements, for loops, and grid.

### Solution Aug 29, 2024 (C++, leetcode) 947. Most Stones Removed with Same Row or Column (Medium)
In .LeetcodeDailySolution folder as Aug29,2024.cpp

#### Prompt:

On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.

A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.

Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.

#### Solution:

    class Solution {
    public:
    void dfs(int& n, int idx, vector<bool>& visited,
             vector<vector<int>>& stones) {

        visited[idx] = true;

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                if (stones[idx][0] == stones[i][0])
                    dfs(n, i, visited, stones);

                if (stones[idx][1] == stones[i][1])
                    dfs(n, i, visited, stones);
            }
        }
    }
    int removeStones(vector<vector<int>>& stones) {

        int n = stones.size();
        int group = 0;

        vector<bool> visited(n);

        for (int i = 0; i < n; i++) {
            if (!visited[i]) {
                dfs(n, i, visited, stones);
                group += 1;
            }
        }

        return n - group;
      }
    };

Runtime: 214 ms, beating 5.07% of leetcode users solutions using C++.
Memory: 18 mb, beating 85.97% of leetcode users solutions using C++.

#### Concepts Applied:

Depth-first search, for loops, if statements, arrays, and grid.

### Solution Aug 30, 2024 (C++, leetcode) 2699. Modify Graph Edge Weights (Hard)
In .LeetcodeDailySolution folder as Aug30,2024.cpp

#### Prompt:

You are given an undirected weighted connected graph containing n nodes labeled from 0 to n - 1, and an integer array edges where edges[i] = [ai, bi, wi] indicates that there is an edge between nodes ai and bi with weight wi.

Some edges have a weight of -1 (wi = -1), while others have a positive weight (wi > 0).

Your task is to modify all edges with a weight of -1 by assigning them positive integer values in the range [1, 2 * 109] so that the shortest distance between the nodes source and destination becomes equal to an integer target. If there are multiple modifications that make the shortest distance between source and destination equal to target, any of them will be considered correct.

Return an array containing all edges (even unmodified ones) in any order if it is possible to make the shortest distance from source to destination equal to target, or an empty array if it's impossible.

Note: You are not allowed to modify the weights of edges with initial positive weights.

#### Solution:

    class Solution {
    public:
    using int2 = pair<int, int>;

    int n, m;
    vector<vector<int2>> adj;
    vector<int> wild_edges;

    inline void build_graph(vector<vector<int>>& edges) {

        for (int i = 0; i < m; i++) {

            auto& e = edges[i];
            int u = e[0], v = e[1], w = e[2];

            if (w > 0) {
                adj[u].emplace_back(w, v);
                adj[v].emplace_back(w, u);
            } else {
                wild_edges.push_back(i);
            }
        }
    }
    int dijkstra(int src, int des, vector<vector<int2>>& adj) {

        int dist[100];
        fill(dist, dist + n, INT_MAX);
        priority_queue<int2, vector<int2>, greater<int2>> pq;
        pq.emplace(0, src);
        dist[src] = 0;

        while (!pq.empty()) {

            auto [d0, i] = pq.top();
            pq.pop();

            if (i == des)
                return d0;

            for (auto& [d_next, j] : adj[i]) {

                int new_d = d0 + d_next;

                if (new_d < dist[j]) {
                    dist[j] = new_d;
                    pq.emplace(new_d, j);
                }
            }
        }

        return INT_MAX;
    }
    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges,
                                           int source, int destination,
                                           int target) {

        this -> n = n;
        adj.resize(n);
        m = edges.size();
        build_graph(edges);
        int dist = dijkstra(source, destination, adj);

        if (dist < target)
            return {};

        for (auto i : wild_edges)

            edges[i][2] = target + 1;

        if (dist == target)
            return edges;

        for (auto i : wild_edges) {

            auto& new_edge = edges[i];
            int u = new_edge[0], v = new_edge[1];
            new_edge[2] = 1;
            adj[u].emplace_back(1, v);
            adj[v].emplace_back(1, u);
            dist = dijkstra(source, destination, adj);

            if (dist <= target) {
                new_edge[2] += target - dist;
                
                return edges;
            }
        }

        return {};
      }
    };

Runtime: 586 ms, beating 65.18% of leetcode users solutions using C++.
Memory: 240.66 mb, beating 85.02% of leetcode users solutions using C++.

#### Concepts Applied:

Dijkstra's algorithm, breadth-first search, min heap, arrays, for loops, if statements, while loop, and else statement.

### Solution Aug 31, 2024 (C++, leetcode) 1514. Path with Maximum Probability (Medium)
In .LeetcodeDailySolution folder as Aug31,2024.cpp

#### Prompt:

You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].

Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.

If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.

#### Solution:

    class Solution {
    public:
    double maxProbability(int n, vector<vector<int>>& edges,
                          vector<double>& succProb, int start_node,
                          int end_node) {

        vector<double> maxProb(n, 0.0);
        maxProb[start_node] = 1.0;

        for (int i = 0; i < n - 1; ++i) {

            bool updated = false;

            for (int j = 0; j < edges.size(); ++j) {

                int u = edges[j][0];
                int v = edges[j][1];
                double prob = succProb[j];

                if (maxProb[u] * prob > maxProb[v]) {
                    maxProb[v] = maxProb[u] * prob;
                    updated = true;
                }
                if (maxProb[v] * prob > maxProb[u]) {
                    maxProb[u] = maxProb[v] * prob;
                    updated = true;
                }
            }
            if (!updated)
                break;
        }

        return maxProb[end_node];
      }
    };

Runtime: 102 ms, beating 74.70% of leetcode users solutions using C++.
Memory: 53.28 mb, beating 90.01% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, maximum probability, bellman-ford algorithm, shortest path, for loop, and if statements.

### Solution Sept 1, 2024 (C++, leetcode) 2022. Convert 1D Array Into 2D Array (Easy)
In .LeetcodeDailySolution folder as Sept1,2024.cpp

#### Prompt:

You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.

The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.

Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.

#### Solution:

    class Solution {
    public:
    static vector<vector<int>> construct2DArray(vector<int>& original, int m,
                                                int n) {

        const int sz = original.size();

        if (sz != m * n)
            return {};

        vector<vector<int>> ans(m);

        for (int i = 0; i < m; i++) {
            ans[i].assign(original.begin() + i * n,
                          original.begin() + (i + 1) * n);
        }

        return ans;
      }
    };

Runtime: 76 ms, beating 70.32% of leetcode users solutions using C++.
Memory: 87.57 mb, beating 97.55% of leetcode users solutions using C++.

#### Concepts Applied:

Vector assign, if statement, arrays, and for loop.

### Solution Sept 2, 2024 (C++, leetcode) 1894. Find the Student that Will Replace the Chalk (Medium)
In .LeetcodeDailySolution folder as Sept2,2024.cpp

#### Prompt:

There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.

You are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.

Return the index of the student that will replace the chalk pieces.

#### Solution:

    class Solution {
    public:
    int chalkReplacer(vector<int>& chalk, int initialChalkPieces) {

        long long totalChalkNeeded = 0;

        for (int studentChalkUse : chalk) {
            totalChalkNeeded += studentChalkUse;
        }
        
        int remainingChalk = initialChalkPieces % totalChalkNeeded;
        
        for (int studentIndex = 0; studentIndex < chalk.size(); studentIndex++) {

            if (remainingChalk < chalk[studentIndex]) {
                
                return studentIndex;
            }

            remainingChalk -= chalk[studentIndex];
        }
        
        return 0;
      }
    };

Runtime: 90 ms, beating 75.25% of leetcode users solutions using C++.
Memory: 77.01 mb, beating 53.48% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, modulo, and if statement.

### Solution Sept 5, 2024 (C++, leetcode) 2028. Find Missing Observations (Medium)
In .LeetcodeDailySolution folder as Sept5,2024.cpp

#### Prompt:

You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls. Fortunately, you have also calculated the average value of the n + m rolls.

You are given an integer array rolls of length m where rolls[i] is the value of the ith observation. You are also given the two integers mean and n.

Return an array of length n containing the missing observations such that the average value of the n + m rolls is exactly mean. If there are multiple valid answers, return any of them. If no such array exists, return an empty array.

The average value of a set of k numbers is the sum of the numbers divided by k.

Note that mean is an integer, so the sum of the n + m rolls should be divisible by n + m.

#### Solution:

    class Solution {
    public:
    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {

        int nNumsSum = 0;

        for (int i : rolls)
            nNumsSum += i;

        int m = rolls.size();
        int totalLength = n + m;

        int mNumsSum = mean * totalLength - nNumsSum;

        if (n * 6 < mNumsSum || mNumsSum < n)
            return {};

        int rem = mNumsSum % n;
        int q = mNumsSum / n;

        vector<int> res(n, q);

        for (int i = 1; i <= rem; i++)
            res[i]++;

        return res;
      }
    };

Runtime: 100 ms, beating 48.90% of leetcode users solutions using C++.
Memory: 116.32 mb, beating 69.59% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, total sum, for loops, and if statement.

### Solution Sept 6, 2024 (C++, leetcode) 3217. Delete Nodes From Linked List Present in Array (Medium)
In .LeetcodeDailySolution folder as Sept6,2024.cpp

#### Prompt:

You are given an array of integers nums and the head of a linked list. Return the head of the modified linked list after removing all nodes from the linked list that have a value that exists in nums.

#### Solution:

    class Solution {
    public:
    ListNode* modifiedList(vector<int>& nums, ListNode* head) {

        bitset<100001> hasN = 0;

        for (int x : nums)
            hasN[x] = 1;

        ListNode dummy(0, head);
        ListNode *prev = &dummy, *tmp = NULL;

        for (ListNode* curr = head; curr; curr = curr -> next, delete tmp) {
            if (hasN[curr -> val]) {
                prev -> next = curr -> next;
                tmp = curr;
            } else {
                prev = prev->next;
                tmp = NULL;
            }
        }

        return dummy.next;
      }
    };

Runtime: 357 ms, beating 98.55% of leetcode users solutions using C++.
Memory: 227.94 mb, beating 96.65% of leetcode users solutions using C++.

#### Concepts Applied:

Bitset, linked list, array, for loop, if statement, and else statement.

### Solution Sept 7, 2024 (C++, leetcode) 1367. Linked List in Binary Tree (Medium)
In .LeetcodeDailySolution folder as Sept7,2024.cpp

#### Prompt:

Given a binary tree root and a linked list with head as the first node. 

Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False.

In this context downward path means a path that starts at some node and goes downwards.

#### Solution:

    class Solution {
    private:
    bool check(ListNode* head, TreeNode* root) {

        if (!root)
            return false;
        if (head->val != root->val) {
            return false;
        }
        if (head->next == NULL) {
            return true;
        }

        bool left = false;
        bool right = false;

        if (root->left && head->next && root->left->val == head->next->val) {
            left = check(head->next, root->left);
        }
        if (root->right && head->next && root->right->val == head->next->val) {
            right = check(head->next, root->right);
        }

        return left | right;
    }

    public:
    bool isSubPath(ListNode* head, TreeNode* root) {

        if (!root) {
            return false;
        }
        if (root->val == head->val) {
            if (check(head, root)) {
                return true;
            }
        }

        return isSubPath(head, root->left) | isSubPath(head, root->right);
      }
    };

Runtime: 20 ms, beating 84.05% of leetcode users solutions using C++.
Memory: 30.88 mb, beating 36.88% of leetcode users solutions using C++.

#### Concepts Applied:

Recursion, traversal, if statements, linked list, and binary tree.

### Solution Sept 9, 2024 (C++, leetcode) 2326. Spiral Matrix IV (Medium)
In .LeetcodeDailySolution folder as Sept9,2024.cpp

#### Prompt:

You are given two integers m and n, which represent the dimensions of a matrix.

You are also given the head of a linked list of integers.

Generate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1.

Return the generated matrix.

#### Solution:

    class Solution {
    public:
    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {
        vector<vector<int>> matrix(m, vector<int>(n, -1));

        int topRow = 0, bottomRow = m - 1, leftColumn = 0, rightColumn = n - 1;

        while (head) {

            for (int col = leftColumn; col <= rightColumn && head; ++col) {
                matrix[topRow][col] = head->val;
                head = head->next;
            }

            topRow++;

            for (int row = topRow; row <= bottomRow && head; ++row) {
                matrix[row][rightColumn] = head->val;
                head = head->next;
            }

            rightColumn--;

            for (int col = rightColumn; col >= leftColumn && head; --col) {
                matrix[bottomRow][col] = head->val;
                head = head->next;
            }

            bottomRow--;

            for (int row = bottomRow; row >= topRow && head; --row) {
                matrix[row][leftColumn] = head->val;
                head = head->next;
            }

            leftColumn++;
        }

        return matrix;
      }
    };

Runtime: 153 ms, beating 86.16% of leetcode users solutions using C++.
Memory: 130.59 mb, beating 66.17% of leetcode users solutions using C++.

#### Concepts Applied:

Matrix, arrays, traversal, while loop, and for loops.

### Solution Sept 10, 2024 (C++, leetcode) 2807. Insert Greatest Common Divisors in Linked List (Medium)
In .LeetcodeDailySolution folder as Sept10,2024.cpp

#### Prompt:

Given the head of a linked list head, in which each node contains an integer value.

Between every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.

Return the linked list after insertion.

The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.

#### Solution:

    class Solution {
    public:
    ListNode* insertGreatestCommonDivisors(ListNode* head) {

        if (head == nullptr || head->next == nullptr)
            return head;

        ListNode* node1 = head;
        ListNode* node2 = head->next;

        while (node2 != nullptr) {

            int gcdValue = calculateGCD(node1->val, node2->val);
            ListNode* gcdNode = new ListNode(gcdValue);

            node1->next = gcdNode;
            gcdNode->next = node2;

            node1 = node2;
            node2 = node2->next;
        }

        return head;
    }

    private:
    int calculateGCD(int a, int b) {

        while (b != 0) {

            int temp = b;
            b = a % b;
            a = temp;
        }
        
        return a;
      }
    };

Runtime: 26 ms, beating 97.57% of leetcode users solutions using C++.
Memory: 35.21 mb, beating 98.83% of leetcode users solutions using C++.

#### Concepts Applied:

Linked list, greatest common diviser, if statement, and while loops.

### Solution Sept 11, 2024 (C++, leetcode) 2220. Minimum Bit Flips to Convert Number (Easy)
In .LeetcodeDailySolution folder as Sept11,2024.cpp

#### Prompt:

A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.

For example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.
Given two integers start and goal, return the minimum number of bit flips to convert start to goal.

#### Solution:

    class Solution {
    public:
    int minBitFlips(int start, int goal) {
        
        int xorResult = start ^ goal;
        int ans = 0;

        while (xorResult > 0) {
            ans += xorResult & 1;
            xorResult >>= 1;
        }

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 7.63 mb, beating 44.87% of leetcode users solutions using C++.

#### Concepts Applied:

Bitwise, and while loop.

### Solution Sept 12, 2024 (C++, leetcode) 1684. Count the Number of Consistent Strings (Easy)
In .LeetcodeDailySolution folder as Sept12,2024.cpp

#### Prompt:

You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.

Return the number of consistent strings in the array words.

#### Solution:

    class Solution {
    public:
    int countConsistentStrings(string& allowed, vector<string>& words) {

        bitset<26> ASet = 0;

        for (char c : allowed)

            ASet[c - 'a'] = 1;
        int cnt = 0;

        for (string& w : words) {

            bool consistent = 1;

            for (char c : w) {
                if (ASet[c - 'a'] == 0) {
                    consistent = 0;
                    break;
                }
            }

            cnt += consistent;
        }
        
        return cnt;
      }
    };

Runtime: 32 ms, beating 96.51% of leetcode users solutions using C++.
Memory: 33.84 mb, beating 87.08% of leetcode users solutions using C++.

#### Concepts Applied:

Bitset, traversal, for loops, and if statement.

### Solution Sept 13, 2024 (C++, leetcode) 1310. XOR Queries of a Subarray (Medium)
In .LeetcodeDailySolution folder as Sept13,2024.cpp

#### Prompt:

You are given an array arr of positive integers. You are also given the array queries where queries[i] = [lefti, righti].

For each query i compute the XOR of elements from lefti to righti (that is, arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti] ).

Return an array answer where answer[i] is the answer to the ith query.

#### Solution:

    class Solution {
    public:
    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {

        int n = arr.size();
        vector<int> pre(n);
        pre[0] = arr[0];
        
        for (int i = 1; i < n; ++i) {
            pre[i] = pre[i - 1] ^ arr[i];
        }
        
        vector<int> res(queries.size());
        
        for (int k = 0; k < queries.size(); ++k) {
            int i = queries[k][0];
            int j = queries[k][1];
            if (i == 0) {
                res[k] = pre[j];
            } else {
                res[k] = pre[j] ^ pre[i - 1];
            }
        }
        
        return res;
      }
    };

Runtime: 56 ms, beating 74.42% of leetcode users solutions using C++.
Memory: 41.67 mb, beating 84% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, XOR, for loops, if statement, and else statement.

### Solution Sept 14, 2024 (C++, leetcode) 2419. Longest Subarray With Maximum Bitwise AND (Medium)
In .LeetcodeDailySolution folder as Sept14,2024.cpp

#### Prompt:

You are given an integer array nums of size n.

Consider a non-empty subarray from nums that has the maximum possible bitwise AND.

In other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered.
Return the length of the longest such subarray.

The bitwise AND of an array is the bitwise AND of all the numbers in it.

A subarray is a contiguous sequence of elements within an array.

#### Solution:

    class Solution {
    public:
    static int longestSubarray(vector<int>& nums) {

        const int n = nums.size();
        int m = max_element(nums.begin(), nums.end()) - nums.begin();
        int maxLen = 0, x = nums[m];

        for (int i = m; i < n; i++) {
            int len = 0;

            while (i < n && nums[i] == x) {
                i++;
                len++;
            }

            maxLen = max(maxLen, len);
        }

        return maxLen;
      }
    };

Runtime: 99 ms, beating 76.05% of leetcode users solutions using C++.
Memory: 84.95 mb, beating 34.15% of leetcode users solutions using C++.

#### Concepts Applied:

One pass, arrays, bitwise, for loop, while loop, and max.

### Solution Sept 16, 2024 (C++, leetcode) 539. Minimum Time Difference (Medium)
In .LeetcodeDailySolution folder as Sept16,2024.cpp

#### Prompt:

Given a list of 24-hour clock time points in "HH:MM" format, return the minimum minutes difference between any two time-points in the list.

#### Solution:

    class Solution {
    public:
    int findMinDifference(vector<string>& timePoints) {

        vector<int> minutes(timePoints.size());

        for (int i = 0; i < timePoints.size(); ++i) {
            int h = stoi(timePoints[i].substr(0, 2));
            int m = stoi(timePoints[i].substr(3));
            minutes[i] = h * 60 + m;
        }

        sort(minutes.begin(), minutes.end());

        int minDiff = INT_MAX;

        for (int i = 0; i < minutes.size() - 1; ++i) {
            minDiff = min(minDiff, minutes[i + 1] - minutes[i]);
        }

        minDiff = min(minDiff, 24 * 60 - minutes.back() + minutes.front());

        return minDiff;
      }
    };

Runtime: 12 ms, beating 58.04% of leetcode users solutions using C++.
Memory: 17.44 mb, beating 88.08% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, strings, substrings, for loops, sorting, and min.

### Solution Sept 17, 2024 (C++, leetcode) 884. Uncommon Words from Two Sentences (Easy)
In .LeetcodeDailySolution folder as Sept17,2024.cpp

#### Prompt:

A sentence is a string of single-space separated words where each word consists only of lowercase letters.

A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.

Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.

#### Solution:

    class Solution {
    public:
    vector<string> uncommonFromSentences(string s1, string s2) {

        string s = s1 + " " + s2;
        stringstream str(s);

        cout << s1.max_size();

        unordered_map<string, int> um;
        string tmp;

        while (str >> tmp) {
            um[tmp]++;
        }

        vector<string> ans;

        for (auto& val : um) {

            if (val.second == 1) {
                ans.emplace_back(val.first); 
             }
        }

        return ans;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 8.92 mb, beating 44.93% of leetcode users solutions using C++.

#### Concepts Applied:

Strings, unordered map, while loop, array, for loop, and if statement. 

### Solution Sept 18, 2024 (C++, leetcode) 179. Largest Number (Medium)
In .LeetcodeDailySolution folder as Sept18,2024.cpp

#### Prompt:

Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.

Since the result may be very large, so you need to return a string instead of an integer.

#### Solution:

    class Solution {
    public:
    string largestNumber(vector<int>& nums) {

        vector<string> strs;

        for (int num : nums) {
            strs.push_back(to_string(num));
        }

        sort(strs.begin(), strs.end(), [](string &a, string &b) {
            return a + b > b + a;
        });

        if (strs[0] == "0") {
            return "0";
        }

        string ans = "";
        
        for (string &s : strs) {
            ans += s;
        }

        return ans;
      }
    };

Runtime: 7 ms, beating 61.52% of leetcode users solutions using C++.
Memory: 17.15 mb, beating 55.33% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, strings, sorting, for loops, and if statement.

### Solution Sept 19, 2024 (C++, leetcode) 241. Different Ways to Add Parentheses (Medium)
In .LeetcodeDailySolution folder as Sept19,2024.cpp

#### Prompt:

Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.

The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 104.

#### Solution:

    class Solution {
    public:
    vector<int> diffWaysToCompute(string expression) {

        vector<int> res;

        for (int i = 0; i < expression.size(); ++i) {

            char oper = expression[i];

            if (oper == '+' || oper == '-' || oper == '*') {

                vector<int> s1 = diffWaysToCompute(expression.substr(0, i));
                vector<int> s2 = diffWaysToCompute(expression.substr(i + 1));

                for (int a : s1) {
                    for (int b : s2) {
                        if (oper == '+')
                            res.push_back(a + b);
                        else if (oper == '-')
                            res.push_back(a - b);
                        else if (oper == '*')
                            res.push_back(a * b);
                    }
                }
            }
        }
        if (res.empty())
            res.push_back(stoi(expression));
            
        return res;
      }
    };

Runtime: 0 ms, beating 100% of leetcode users solutions using C++.
Memory: 13.90 mb, beating 23.97% of leetcode users solutions using C++.

#### Concepts Applied:

Divide and conquer, strings, arrays, for loops, if statements, and else-if statements.

### Solution Sept 20, 2024 (C++, leetcode) 214. Shortest Palindrome (Hard)
In .LeetcodeDailySolution folder as Sept20,2024.cpp

#### Prompt:

You are given a string s. You can convert s to a palindrome by adding characters in front of it.

Return the shortest palindrome you can find by performing this transformation.

#### Solution:

    class Solution {
    public:
    string shortestPalindrome(string s) {

        int count = kmp(string(s.rbegin(), s.rend()), s);

        return string(s.rbegin(), s.rend()).substr(0, s.length() - count) + s;
    }

    private:
    int kmp(const string& txt, const string& patt) {

        string newString = patt + '#' + txt;
        vector<int> pi(newString.length(), 0);

        int i = 1, k = 0;

        while (i < newString.length()) {
            if (newString[i] == newString[k]) {
                k++;
                pi[i] = k;
                i++;
            } else {
                if (k > 0) {
                    k = pi[k - 1];
                } else {
                    pi[i] = 0;
                    i++;
                }
            }   
        }

        return pi.back();
      }
    };

Runtime: 7 ms, beating 64.08% of leetcode users solutions using C++.
Memory: 11.98 mb, beating 27.29% of leetcode users solutions using C++.

#### Concepts Applied:

KMP algorithm, strings, arrays, while loop, else statements, and if statement.

### Solution Sept 21, 2024 (C++, leetcode) 386. Lexicographical Numbers (Medium)
In .LeetcodeDailySolution folder as Sept21,2024.cpp

#### Prompt:

Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.

You must write an algorithm that runs in O(n) time and uses O(1) extra space. 

#### Solution:

    class Solution {
    public:
    static vector<int> lexicalOrder(int n) {

        vector<int> ans(n);

        int x = 1;

        for (int i = 0; i < n; i++) {

            ans[i] = x;

            if (x * 10 > n) {
                if (x == n)
                    x /= 10;
                x++;
                while (x % 10 == 0)
                    x /= 10;
            } else
                x *= 10;
        }

        return ans;
      }
    };

Runtime: 8 ms, beating 72.41% of leetcode users solutions using C++. 
Memory: 11.86 mb, beating 96.05% of leetcode users solutions using C++.

#### Concepts Applied:

Array, iteration, for loop, if statement, while loop, and else statement.

### Solution Sept 23, 2024 (C++, leetcode) 2707. Extra Characters in a String (Medium)
In .LeetcodeDailySolution folder as Sept23,2024.cpp

#### Prompt:

You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.

Return the minimum number of extra characters left over if you break up s optimally.

#### Solution:

    const int N = 26;

    struct Trie {

    Trie* next[N];
    bool isEnd = 0;

    Trie() { fill(next, next + N, (Trie*)NULL); }

    ~Trie() {
        for (int i = 0; i < N; ++i) {
            if (next[i] != NULL) {
                delete next[i];
            }
        }
    }

    void insert(string& word) {
        Trie* Node = this;
        for (char c : word) {
            int i = c - 'a';
            if (Node->next[i] == NULL)
                Node->next[i] = new Trie();
            Node = Node->next[i];
        }
        Node->isEnd = 1;
    }
    void insert(vector<string>& dictionary) {
        for (auto& word : dictionary)
            insert(word);
      }
    };

    class Solution {
    public:
    int minExtraChar(string s, vector<string>& dictionary) {

        Trie trie;
        trie.insert(dictionary);

        int n = s.size();
        vector<int> dp(n + 1, 0);

        for (int i = n - 1; i >= 0; i--) {

            dp[i] = dp[i + 1] + 1;
            Trie* node = &trie;

            for (int j = i; j < n; j++) {
                if (node->next[s[j] - 'a'] == NULL)
                    break;

                node = node->next[s[j] - 'a'];

                if (node->isEnd)
                    dp[i] = min(dp[i], dp[j + 1]);
            }
        }

        return dp[0];
      }
    };

Runtime: 63 ms, beating 93.53% of leetcode users solutions using C++.
Memory: 112.20 mb, beating 26.57% of leetcode users solutions using C++.

#### Concepts Applied:

Trie, for loops, if statements, strings, arrays, and dynamic programming.

### Solution Sept 24, 2024 (C++, leetcode) 3043. Find the Length of the Longest Common Prefix (Medium)
In .LeetcodeDailySolution folder as Sept24,2024.cpp

#### Prompt:

You are given two arrays with positive integers arr1 and arr2.

A prefix of a positive integer is an integer formed by one or more of its digits, starting from its leftmost digit. For example, 123 is a prefix of the integer 12345, while 234 is not.

A common prefix of two integers a and b is an integer c, such that c is a prefix of both a and b. For example, 5655359 and 56554 have a common prefix 565 while 1223 and 43456 do not have a common prefix.

You need to find the length of the longest common prefix between all pairs of integers (x, y) such that x belongs to arr1 and y belongs to arr2.

Return the length of the longest common prefix among all pairs. If no common prefix exists among them, return 0.

#### Solution:

    class Solution {
    public:
    int longestCommonPrefix(vector<int>& arr1, vector<int>& arr2) {

        unordered_map<string, int> prefixMap;

        for (int num : arr1) {

            string strNum = to_string(num);
            string prefix = "";

            for (char ch : strNum) {
                prefix += ch;
                prefixMap[prefix]++;
            }
        }

        int maxLength = 0;

        for (int num : arr2) {

            string strNum = to_string(num);
            string prefix = "";

            for (char ch : strNum) {

                prefix += ch;

                if (prefixMap.find(prefix) != prefixMap.end()) {
                    maxLength =
                        max(maxLength, static_cast<int>(prefix.length()));
                }
            }
        }

        return maxLength;
      }
    };

Runtime: 472 ms, beating 33.96% of leetcode users solutions using C++.
Memory: 170.42 mb, beating 31.53% of leetcode users solutions using C++.

#### Concepts Applied:

Arrays, for loops, hashmap, max, and if statement.

### Solution Sept 26, 2024 (C++, leetcode) 729. My Calendar I (Medium)
In .LeetcodeDailySolution folder as Sept26,2024.cpp

#### Prompt:

You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.

A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).

The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.

Implement the MyCalendar class:

MyCalendar() Initializes the calendar object.
boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.

#### Solution:

    class MyCalendar {

    map<int, int> intervals; 

    public:

    MyCalendar() {}

    bool book(int start, int end) {
        auto next = intervals.lower_bound(start); 

        if (next != intervals.end() && next->first < end) {

            return false; 
        }

        if (next != intervals.begin() && prev(next)->second > start) {

            return false; 
        }

        intervals[start] = end; 

        return true;
      }
    };

Runtime: 48 ms, beating 99.89% of leetcode users solutions using C++.
Memory: 42.79 mb, beating 58.59% of leetcode users solutions using C++.

#### Concepts Applied:

Binary search, map, and if statements.

### Solution Sept 27, 2024 (C++, leetcode) 731. My Calendar II (Medium)
In .LeetcodeDailySolution folder as Sept27,2024.cpp

#### Prompt:

You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.

A triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).

The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.

Implement the MyCalendarTwo class:

MyCalendarTwo() Initializes the calendar object.
boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar.

#### Solution:

    class MyCalendarTwo {
    public:
    vector<pair<int, int>> vp;

    MyCalendarTwo() {}

    bool book(int x, int y) {

        for (auto& val : vp) {
            int a = val.first, b = val.second;

            if ((x < b) and (y > a)) {

                int new_x = max(a, x);
                int new_y = min(b, y);

                if (check(new_x, new_y)) {

                    return false;
                }
            }
        }

        vp.push_back({x, y});
        return true;
    }

    bool check(int x, int y) {
        int overlapp_cnt = 0;

        for (int i = 0; i < vp.size(); i++) {
            int a = vp[i].first, b = vp[i].second;

            if ((x < b) and (y > a)) {
                overlapp_cnt++;
                if (overlapp_cnt == 2) {
                    
                    return true;
                }
            }
        }

        return false;
      }
    };

Runtime: 65 ms, beating 94.42% of leetcode users solutions using C++.
Memory: 37.60 mb, beating 99.62% of leetcode users solutions using C++.

#### Concepts Applied:

Brute-force, pair, for loops, if statements, max, and min.

### Solution Sept 28, 2024 (C++, leetcode) 641. Design Circular Deque (Medium)
In .LeetcodeDailySolution folder as Sept28,2024.cpp

#### Prompt:

Design your implementation of the circular double-ended queue (deque).

Implement the MyCircularDeque class:

MyCircularDeque(int k) Initializes the deque with a maximum size of k.
boolean insertFront() Adds an item at the front of Deque. Returns true if the operation is successful, or false otherwise.
boolean insertLast() Adds an item at the rear of Deque. Returns true if the operation is successful, or false otherwise.
boolean deleteFront() Deletes an item from the front of Deque. Returns true if the operation is successful, or false otherwise.
boolean deleteLast() Deletes an item from the rear of Deque. Returns true if the operation is successful, or false otherwise.
int getFront() Returns the front item from the Deque. Returns -1 if the deque is empty.
int getRear() Returns the last item from Deque. Returns -1 if the deque is empty.
boolean isEmpty() Returns true if the deque is empty, or false otherwise.
boolean isFull() Returns true if the deque is full, or false otherwise.

#### Solution:

    class MyCircularDeque {
    public:
    vector<int> v;
    int front, back, sizee, capacity;

    MyCircularDeque(int k) {
        v = vector<int>(k, -1);
        front = 0;
        back = 0;
        sizee = 0;
        capacity = k;
    }

    bool insertFront(int value) {
        if (isFull()) {
            return false;
        }
        if (front == 0) {
            front = capacity - 1;
        } else {
            front--;
        }
        v[front] = value;
        sizee++;
        return true;
    }

    bool insertLast(int value) {
        if (isFull()) {
            return false;
        }
        v[back] = value;
        if (back == capacity - 1) {
            back = 0;
        } else {
            back++;
        }
        sizee++;
        return true;
    }

    bool deleteFront() {
        if (isEmpty()) {
            return false;
        }
        v[front] = -1;
        if (front == capacity - 1) {
            front = 0;
        } else {
            front++;
        }
        sizee--;
        return true;
    }

    bool deleteLast() {
        if (isEmpty()) {
            return false;
        }
        if (back == 0) {
            back = capacity - 1;
        } else {
            back--;
        }
        v[back] = -1;
        sizee--;
        return true;
    }

    int getFront() {
        if (isEmpty()) {
            return -1;
        }
        return v[front];
    }

    int getRear() {
        if (isEmpty()) {
            return -1;
        }
        if (back == 0) {
            return v[capacity - 1];
        } else {
            return v[back - 1];
        }
    }

    bool isEmpty() { return (sizee == 0); }

    bool isFull() { return (sizee == capacity); }
    };
 
Runtime: 16 ms, beating 87.88% of leetcode users solutions using C++.
Memory: 22.72 mb, beating 48.31% of leetcode users solutions using C++.

#### Concepts Applied:

Deque, arrays, if statements, and else statements.

### Solution Sept 29, 2024 (C++, leetcode) 432. All O`one Data Structure (Hard)
In .LeetcodeDailySolution folder as Sept29,2024.cpp

#### Prompt:

Design a data structure to store the strings' count with the ability to return the strings with minimum and maximum counts.

Implement the AllOne class:

AllOne() Initializes the object of the data structure.
inc(String key) Increments the count of the string key by 1. If key does not exist in the data structure, insert it with count 1.
dec(String key) Decrements the count of the string key by 1. If the count of key is 0 after the decrement, remove it from the data structure. It is guaranteed that key exists in the data structure before the decrement.
getMaxKey() Returns one of the keys with the maximal count. If no element exists, return an empty string "".
getMinKey() Returns one of the keys with the minimum count. If no element exists, return an empty string "".
Note that each function must run in O(1) average time complexity.

#### Solution:

    class AllOne {
    unordered_map<string, int> count;
    map<int, unordered_set<string>> freq;

    public:
    AllOne() {}
    void inc(string key) {
        int cnt = count[key]++;
        if (cnt > 0)
            freq[cnt].erase(key);
        freq[cnt + 1].insert(key);
        if (freq[cnt].empty())
            freq.erase(cnt);
    }
    void dec(string key) {
        int cnt = count[key]--;
        if (cnt > 0)
            freq[cnt].erase(key);
        if (cnt == 1)
            count.erase(key);
        else
            freq[cnt - 1].insert(key);
        if (freq[cnt].empty())
            freq.erase(cnt);
    }
    string getMaxKey() {
        return freq.empty() ? "" : *(freq.rbegin()->second.begin());
    }
    string getMinKey() {
        return freq.empty() ? "" : *(freq.begin()->second.begin());
      }
    };

Runtime: 98 ms, beating 54.21% of leetcode users solutions using C++.
Memory: 63.85 mb, beating 11.65% of leetcode users solutions using C++.

#### Concepts Applied:

Unordered map, map, strings, if statements, and else statement.
